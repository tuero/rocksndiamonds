/***********************************************************
* Rocks'n'Diamonds -- McDuffin Strikes Back!               *
*----------------------------------------------------------*
* (c) 1995-2002 Artsoft Entertainment                      *
*               Holger Schemel                             *
*               Detmolder Strasse 189                      *
*               33604 Bielefeld                            *
*               Germany                                    *
*               e-mail: info@artsoft.org                   *
*----------------------------------------------------------*
* editor.c                                                 *
***********************************************************/

#include <math.h>

#include "libgame/libgame.h"

#include "editor.h"
#include "screens.h"
#include "tools.h"
#include "files.h"
#include "game.h"
#include "init.h"
#include "tape.h"


#define INFOTEXT_UNKNOWN_ELEMENT	"unknown"


/*
  -----------------------------------------------------------------------------
  screen and artwork graphic pixel position definitions
  -----------------------------------------------------------------------------
*/

/* positions in the level editor */
#define ED_WIN_MB_LEFT_XPOS		6
#define ED_WIN_MB_LEFT_YPOS		258
#define ED_WIN_MB_MIDDLE_XPOS		42
#define ED_WIN_MB_MIDDLE_YPOS		ED_WIN_MB_LEFT_YPOS
#define ED_WIN_MB_RIGHT_XPOS		78
#define ED_WIN_MB_RIGHT_YPOS		ED_WIN_MB_LEFT_YPOS

/* values for the control window */
#define ED_CTRL_BUTTONS_GFX_YPOS 	236
#define ED_CTRL_BUTTONS_ALT_GFX_YPOS 	142

#define ED_CTRL1_BUTTONS_HORIZ		4
#define ED_CTRL1_BUTTONS_VERT		4
#define ED_CTRL1_BUTTON_XSIZE		22
#define ED_CTRL1_BUTTON_YSIZE		22
#define ED_CTRL1_BUTTONS_XPOS		6
#define ED_CTRL1_BUTTONS_YPOS		6
#define ED_CTRL2_BUTTONS_HORIZ		3
#define ED_CTRL2_BUTTONS_VERT		2
#define ED_CTRL2_BUTTON_XSIZE		30
#define ED_CTRL2_BUTTON_YSIZE		20
#define ED_CTRL2_BUTTONS_XPOS		5
#define ED_CTRL2_BUTTONS_YPOS		99
#define ED_NUM_CTRL1_BUTTONS   (ED_CTRL1_BUTTONS_HORIZ * ED_CTRL1_BUTTONS_VERT)
#define ED_NUM_CTRL2_BUTTONS   (ED_CTRL2_BUTTONS_HORIZ * ED_CTRL2_BUTTONS_VERT)
#define ED_NUM_CTRL_BUTTONS    (ED_NUM_CTRL1_BUTTONS + ED_NUM_CTRL2_BUTTONS)

/* values for the element list */
#define ED_ELEMENTLIST_XPOS		5
#define ED_ELEMENTLIST_YPOS		30
#define ED_ELEMENTLIST_XSIZE		20
#define ED_ELEMENTLIST_YSIZE		20
#define ED_ELEMENTLIST_BUTTONS_HORIZ	4
#define ED_ELEMENTLIST_BUTTONS_VERT	11
#define ED_NUM_ELEMENTLIST_BUTTONS	(ED_ELEMENTLIST_BUTTONS_HORIZ * \
					 ED_ELEMENTLIST_BUTTONS_VERT)

/* standard distances */
#define ED_BORDER_SIZE			3
#define ED_BORDER_TEXT_XSIZE		5
#define ED_BORDER_AREA_YSIZE		1

#define ED_GADGET_DISTANCE		2
#define ED_GADGET_TEXT_DISTANCE		(2 * ED_GADGET_DISTANCE)
#define ED_DRAWINGAREA_TEXT_DISTANCE	(ED_GADGET_TEXT_DISTANCE + \
					 MINI_TILEX / 2)

/* values for the setting windows */
#define ED_SETTINGS_XSTART		(3 * MINI_TILEX / 2)
#define ED_SETTINGS_YSTART		(MINI_TILEY * 10)

#define ED_XOFFSET_CHECKBOX		(ED_CHECKBUTTON_XSIZE + \
					 2 * ED_GADGET_DISTANCE)

#define ED_SETTINGS_XOFFSET		ED_XOFFSET_CHECKBOX
#define ED_SETTINGS_YOFFSET		(3 * MINI_TILEY / 2)

#define ED_SETTINGS_XPOS(n)		(ED_SETTINGS_XSTART + \
	 				 n * ED_SETTINGS_XOFFSET)
#define ED_SETTINGS_YPOS(n)		(ED_SETTINGS_YSTART + \
					 n * ED_SETTINGS_YOFFSET)

#define ED_SETTINGS1_YPOS		MINI_TILEY
#define ED_SETTINGS2_XPOS		MINI_TILEX
#define ED_SETTINGS2_YPOS		(ED_SETTINGS1_YPOS + 12 * TILEY - 2)

/* values for counter gadgets */
#define ED_COUNTER_YSTART		(ED_SETTINGS1_YPOS + 2 * TILEY)
#define ED_COUNTER_YDISTANCE		(3 * MINI_TILEY)
#define ED_COUNTER_YPOS(n)		(ED_COUNTER_YSTART + \
					 n * ED_COUNTER_YDISTANCE)
#define ED_COUNTER2_YPOS(n)		(ED_COUNTER_YSTART + \
					 n * ED_COUNTER_YDISTANCE - 2)

/* values for element content drawing areas */
/* amoeba content */
#define ED_AREA_ELEM_CONTENT_XPOS	( 2 * MINI_TILEX)
#define ED_AREA_ELEM_CONTENT_YPOS	(22 * MINI_TILEY)

/* yamyam content */
#define ED_AREA_YAMYAM_CONTENT_XPOS(n)	(ED_AREA_ELEM_CONTENT_XPOS + \
					 5 * (n % 4) * MINI_TILEX)
#define ED_AREA_YAMYAM_CONTENT_YPOS(n)	(ED_AREA_ELEM_CONTENT_YPOS + \
					 6 * (n / 4) * MINI_TILEY)

/* custom change target */
#define ED_AREA_ELEM_CONTENT2_YPOS	(ED_SETTINGS_YPOS(2) + \
					 ED_GADGET_DISTANCE)
/* optional custom graphic */
#define ED_AREA_ELEM_CONTENT3_YPOS	(ED_SETTINGS_YPOS(1) + \
					 ED_GADGET_DISTANCE)
/* custom element content */
#define ED_AREA_ELEM_CONTENT4_XPOS	(29 * MINI_TILEX)
#define ED_AREA_ELEM_CONTENT4_YPOS	(ED_SETTINGS_YPOS(12) + \
					 ED_GADGET_DISTANCE - MINI_TILEY)
/* custom change trigger element */
#define ED_AREA_ELEM_CONTENT5_YPOS	(ED_SETTINGS_YPOS(6) + \
					 ED_GADGET_DISTANCE)
/* extended custom change target */
#define ED_AREA_ELEM_CONTENT6_XPOS	(29 * MINI_TILEX)
#define ED_AREA_ELEM_CONTENT6_YPOS	(ED_SETTINGS_YPOS(10) + \
					 ED_GADGET_DISTANCE - MINI_TILEY)

/* values for random placement background drawing area */
#define ED_AREA_RANDOM_BACKGROUND_YPOS	(31 * MINI_TILEY)

/* values for scrolling gadgets for drawing area */
#define ED_SCROLLBUTTON_XPOS		24
#define ED_SCROLLBUTTON_YPOS		0
#define ED_SCROLLBAR_XPOS		24
#define ED_SCROLLBAR_YPOS		64

#define ED_SCROLLBUTTON_XSIZE		16
#define ED_SCROLLBUTTON_YSIZE		16

#define ED_SCROLL_UP_XPOS		(SXSIZE - ED_SCROLLBUTTON_XSIZE)
#define ED_SCROLL_UP_YPOS		(0)
#define ED_SCROLL_DOWN_XPOS		ED_SCROLL_UP_XPOS
#define ED_SCROLL_DOWN_YPOS		(SYSIZE - 3 * ED_SCROLLBUTTON_YSIZE)
#define ED_SCROLL_LEFT_XPOS		(0)
#define ED_SCROLL_LEFT_YPOS		(SYSIZE - 2 * ED_SCROLLBUTTON_YSIZE)
#define ED_SCROLL_RIGHT_XPOS		(SXSIZE - 2 * ED_SCROLLBUTTON_XSIZE)
#define ED_SCROLL_RIGHT_YPOS		ED_SCROLL_LEFT_YPOS
#define ED_SCROLL_HORIZONTAL_XPOS (ED_SCROLL_LEFT_XPOS + ED_SCROLLBUTTON_XSIZE)
#define ED_SCROLL_HORIZONTAL_YPOS	ED_SCROLL_LEFT_YPOS
#define ED_SCROLL_HORIZONTAL_XSIZE	(SXSIZE - 3 * ED_SCROLLBUTTON_XSIZE)
#define ED_SCROLL_HORIZONTAL_YSIZE	ED_SCROLLBUTTON_YSIZE
#define ED_SCROLL_VERTICAL_XPOS		ED_SCROLL_UP_XPOS
#define ED_SCROLL_VERTICAL_YPOS	  (ED_SCROLL_UP_YPOS + ED_SCROLLBUTTON_YSIZE)
#define ED_SCROLL_VERTICAL_XSIZE	ED_SCROLLBUTTON_XSIZE
#define ED_SCROLL_VERTICAL_YSIZE	(SYSIZE - 4 * ED_SCROLLBUTTON_YSIZE)

/* values for scrolling gadgets for element list */
#define ED_SCROLLBUTTON2_XPOS		50
#define ED_SCROLLBUTTON2_YPOS		0
#define ED_SCROLLBAR2_XPOS		50
#define ED_SCROLLBAR2_YPOS		20

#define ED_SCROLLBUTTON2_XSIZE		10
#define ED_SCROLLBUTTON2_YSIZE		10

#define ED_SCROLL2_UP_XPOS		85
#define ED_SCROLL2_UP_YPOS		30
#define ED_SCROLL2_DOWN_XPOS		ED_SCROLL2_UP_XPOS
#define ED_SCROLL2_DOWN_YPOS		(ED_SCROLL2_UP_YPOS + \
					 ED_ELEMENTLIST_BUTTONS_VERT * \
					 ED_ELEMENTLIST_YSIZE - \
					 ED_SCROLLBUTTON2_YSIZE)
#define ED_SCROLL2_VERTICAL_XPOS	ED_SCROLL2_UP_XPOS
#define ED_SCROLL2_VERTICAL_YPOS	(ED_SCROLL2_UP_YPOS + \
					 ED_SCROLLBUTTON2_YSIZE)
#define ED_SCROLL2_VERTICAL_XSIZE	ED_SCROLLBUTTON2_XSIZE
#define ED_SCROLL2_VERTICAL_YSIZE	(ED_ELEMENTLIST_BUTTONS_VERT * \
					 ED_ELEMENTLIST_YSIZE - \
					 2 * ED_SCROLLBUTTON2_YSIZE)

/* values for checkbutton gadgets */
#define ED_CHECKBUTTON_XSIZE		ED_BUTTON_COUNT_XSIZE
#define ED_CHECKBUTTON_YSIZE		ED_BUTTON_COUNT_YSIZE
#define ED_CHECKBUTTON_UNCHECKED_XPOS	ED_BUTTON_MINUS_XPOS
#define ED_CHECKBUTTON_CHECKED_XPOS	ED_BUTTON_PLUS_XPOS
#define ED_CHECKBUTTON_YPOS		(ED_BUTTON_MINUS_YPOS + 22)
#define ED_RADIOBUTTON_YPOS		(ED_BUTTON_MINUS_YPOS + 44)
#define ED_STICKYBUTTON_YPOS		(ED_BUTTON_MINUS_YPOS + 66)

/* some positions in the editor control window */
#define ED_BUTTON_ELEM_XPOS		6
#define ED_BUTTON_ELEM_YPOS		30
#define ED_BUTTON_ELEM_XSIZE		22
#define ED_BUTTON_ELEM_YSIZE		22

/* some values for text input, selectbox and counter gadgets */
#define ED_BUTTON_COUNT_YPOS		60
#define ED_BUTTON_COUNT_XSIZE		20
#define ED_BUTTON_COUNT_YSIZE		20
#define ED_WIN_COUNT_XPOS		(2 + ED_BUTTON_COUNT_XSIZE + 2)
#define ED_WIN_COUNT_YPOS		ED_BUTTON_COUNT_YPOS
#define ED_WIN_COUNT_XSIZE		52
#define ED_WIN_COUNT_YSIZE		ED_BUTTON_COUNT_YSIZE
#define ED_WIN_COUNT2_XPOS		27
#define ED_WIN_COUNT2_YPOS		3
#define ED_WIN_COUNT2_XSIZE		46
#define ED_WIN_COUNT2_YSIZE		ED_BUTTON_COUNT_YSIZE

#define ED_BUTTON_MINUS_XPOS		2
#define ED_BUTTON_MINUS_YPOS		ED_BUTTON_COUNT_YPOS
#define ED_BUTTON_MINUS_XSIZE		ED_BUTTON_COUNT_XSIZE
#define ED_BUTTON_MINUS_YSIZE		ED_BUTTON_COUNT_YSIZE
#define ED_BUTTON_PLUS_XPOS		(ED_WIN_COUNT_XPOS + \
	 				 ED_WIN_COUNT_XSIZE + 2)
#define ED_BUTTON_PLUS_YPOS		ED_BUTTON_COUNT_YPOS
#define ED_BUTTON_PLUS_XSIZE		ED_BUTTON_COUNT_XSIZE
#define ED_BUTTON_PLUS_YSIZE		ED_BUTTON_COUNT_YSIZE

#define ED_SELECTBOX_XPOS		ED_WIN_COUNT_XPOS
#define ED_SELECTBOX_YPOS		(ED_WIN_COUNT_YPOS + \
					 2 + ED_WIN_COUNT_YSIZE)
#define ED_SELECTBOX_XSIZE		ED_WIN_COUNT_XSIZE
#define ED_SELECTBOX_YSIZE		ED_WIN_COUNT_YSIZE

#define ED_SELECTBOX_BUTTON_XSIZE	14

#define ED_TEXTBUTTON_XPOS		ED_WIN_COUNT_XPOS
#define ED_TEXTBUTTON_YPOS		(ED_WIN_COUNT_YPOS + \
					 4 * (2 + ED_WIN_COUNT_YSIZE))
#define ED_TEXTBUTTON_INACTIVE_YPOS	ED_TEXTBUTTON_YPOS

#define ED_TEXTBUTTON_TAB_XPOS		ED_WIN_COUNT_XPOS
#define ED_TEXTBUTTON_TAB_YPOS		(ED_WIN_COUNT_YPOS + \
					 2 * (2 + ED_WIN_COUNT_YSIZE))
#define ED_TEXTBUTTON_TAB_INACTIVE_YPOS	(ED_WIN_COUNT_YPOS + \
					 3 * (2 + ED_WIN_COUNT_YSIZE))

#define ED_TEXTBUTTON_XSIZE		ED_WIN_COUNT_XSIZE
#define ED_TEXTBUTTON_YSIZE		ED_WIN_COUNT_YSIZE

/* values for ClearEditorGadgetInfoText() and HandleGadgetInfoText() */
#define INFOTEXT_XPOS			SX
#define INFOTEXT_YPOS			(SY + SYSIZE - MINI_TILEX + 2)
#define INFOTEXT_XSIZE			SXSIZE
#define INFOTEXT_YSIZE			MINI_TILEX


/*
  -----------------------------------------------------------------------------
  editor gadget definitions
  -----------------------------------------------------------------------------
*/

/* drawing toolbox buttons */
#define GADGET_ID_NONE			-1
#define GADGET_ID_TOOLBOX_FIRST		0

#define GADGET_ID_SINGLE_ITEMS		(GADGET_ID_TOOLBOX_FIRST + 0)
#define GADGET_ID_CONNECTED_ITEMS	(GADGET_ID_TOOLBOX_FIRST + 1)
#define GADGET_ID_LINE			(GADGET_ID_TOOLBOX_FIRST + 2)
#define GADGET_ID_ARC			(GADGET_ID_TOOLBOX_FIRST + 3)
#define GADGET_ID_RECTANGLE		(GADGET_ID_TOOLBOX_FIRST + 4)
#define GADGET_ID_FILLED_BOX		(GADGET_ID_TOOLBOX_FIRST + 5)
#define GADGET_ID_WRAP_UP		(GADGET_ID_TOOLBOX_FIRST + 6)
#define GADGET_ID_TEXT			(GADGET_ID_TOOLBOX_FIRST + 7)
#define GADGET_ID_FLOOD_FILL		(GADGET_ID_TOOLBOX_FIRST + 8)
#define GADGET_ID_WRAP_LEFT		(GADGET_ID_TOOLBOX_FIRST + 9)
#define GADGET_ID_PROPERTIES		(GADGET_ID_TOOLBOX_FIRST + 10)
#define GADGET_ID_WRAP_RIGHT		(GADGET_ID_TOOLBOX_FIRST + 11)
#define GADGET_ID_RANDOM_PLACEMENT	(GADGET_ID_TOOLBOX_FIRST + 12)
#define GADGET_ID_GRAB_BRUSH		(GADGET_ID_TOOLBOX_FIRST + 13)
#define GADGET_ID_WRAP_DOWN		(GADGET_ID_TOOLBOX_FIRST + 14)
#define GADGET_ID_PICK_ELEMENT		(GADGET_ID_TOOLBOX_FIRST + 15)
#define GADGET_ID_UNDO			(GADGET_ID_TOOLBOX_FIRST + 16)
#define GADGET_ID_INFO			(GADGET_ID_TOOLBOX_FIRST + 17)
#define GADGET_ID_SAVE			(GADGET_ID_TOOLBOX_FIRST + 18)
#define GADGET_ID_CLEAR			(GADGET_ID_TOOLBOX_FIRST + 19)
#define GADGET_ID_TEST			(GADGET_ID_TOOLBOX_FIRST + 20)
#define GADGET_ID_EXIT			(GADGET_ID_TOOLBOX_FIRST + 21)

/* counter button identifiers */
#define GADGET_ID_COUNTER_FIRST		(GADGET_ID_TOOLBOX_FIRST + 22)

#define GADGET_ID_SELECT_LEVEL_DOWN	(GADGET_ID_COUNTER_FIRST + 0)
#define GADGET_ID_SELECT_LEVEL_TEXT	(GADGET_ID_COUNTER_FIRST + 1)
#define GADGET_ID_SELECT_LEVEL_UP	(GADGET_ID_COUNTER_FIRST + 2)
#define GADGET_ID_LEVEL_XSIZE_DOWN	(GADGET_ID_COUNTER_FIRST + 3)
#define GADGET_ID_LEVEL_XSIZE_TEXT	(GADGET_ID_COUNTER_FIRST + 4)
#define GADGET_ID_LEVEL_XSIZE_UP	(GADGET_ID_COUNTER_FIRST + 5)
#define GADGET_ID_LEVEL_YSIZE_DOWN	(GADGET_ID_COUNTER_FIRST + 6)
#define GADGET_ID_LEVEL_YSIZE_TEXT	(GADGET_ID_COUNTER_FIRST + 7)
#define GADGET_ID_LEVEL_YSIZE_UP	(GADGET_ID_COUNTER_FIRST + 8)
#define GADGET_ID_LEVEL_RANDOM_DOWN	(GADGET_ID_COUNTER_FIRST + 9)
#define GADGET_ID_LEVEL_RANDOM_TEXT	(GADGET_ID_COUNTER_FIRST + 10)
#define GADGET_ID_LEVEL_RANDOM_UP	(GADGET_ID_COUNTER_FIRST + 11)
#define GADGET_ID_LEVEL_GEMSLIMIT_DOWN	(GADGET_ID_COUNTER_FIRST + 12)
#define GADGET_ID_LEVEL_GEMSLIMIT_TEXT	(GADGET_ID_COUNTER_FIRST + 13)
#define GADGET_ID_LEVEL_GEMSLIMIT_UP	(GADGET_ID_COUNTER_FIRST + 14)
#define GADGET_ID_LEVEL_TIMELIMIT_DOWN	(GADGET_ID_COUNTER_FIRST + 15)
#define GADGET_ID_LEVEL_TIMELIMIT_TEXT	(GADGET_ID_COUNTER_FIRST + 16)
#define GADGET_ID_LEVEL_TIMELIMIT_UP	(GADGET_ID_COUNTER_FIRST + 17)
#define GADGET_ID_LEVEL_TIMESCORE_DOWN	(GADGET_ID_COUNTER_FIRST + 18)
#define GADGET_ID_LEVEL_TIMESCORE_TEXT	(GADGET_ID_COUNTER_FIRST + 19)
#define GADGET_ID_LEVEL_TIMESCORE_UP	(GADGET_ID_COUNTER_FIRST + 20)
#define GADGET_ID_ELEMENT_SCORE_DOWN	(GADGET_ID_COUNTER_FIRST + 21)
#define GADGET_ID_ELEMENT_SCORE_TEXT	(GADGET_ID_COUNTER_FIRST + 22)
#define GADGET_ID_ELEMENT_SCORE_UP	(GADGET_ID_COUNTER_FIRST + 23)
#define GADGET_ID_ELEMENT_CONTENT_DOWN	(GADGET_ID_COUNTER_FIRST + 24)
#define GADGET_ID_ELEMENT_CONTENT_TEXT	(GADGET_ID_COUNTER_FIRST + 25)
#define GADGET_ID_ELEMENT_CONTENT_UP	(GADGET_ID_COUNTER_FIRST + 26)
#define GADGET_ID_ENVELOPE_XSIZE_DOWN	(GADGET_ID_COUNTER_FIRST + 27)
#define GADGET_ID_ENVELOPE_XSIZE_TEXT	(GADGET_ID_COUNTER_FIRST + 28)
#define GADGET_ID_ENVELOPE_XSIZE_UP	(GADGET_ID_COUNTER_FIRST + 29)
#define GADGET_ID_ENVELOPE_YSIZE_DOWN	(GADGET_ID_COUNTER_FIRST + 30)
#define GADGET_ID_ENVELOPE_YSIZE_TEXT	(GADGET_ID_COUNTER_FIRST + 31)
#define GADGET_ID_ENVELOPE_YSIZE_UP	(GADGET_ID_COUNTER_FIRST + 32)
#define GADGET_ID_CUSTOM_SCORE_DOWN	(GADGET_ID_COUNTER_FIRST + 33)
#define GADGET_ID_CUSTOM_SCORE_TEXT	(GADGET_ID_COUNTER_FIRST + 34)
#define GADGET_ID_CUSTOM_SCORE_UP	(GADGET_ID_COUNTER_FIRST + 35)
#define GADGET_ID_CUSTOM_GEMCOUNT_DOWN	(GADGET_ID_COUNTER_FIRST + 36)
#define GADGET_ID_CUSTOM_GEMCOUNT_TEXT	(GADGET_ID_COUNTER_FIRST + 37)
#define GADGET_ID_CUSTOM_GEMCOUNT_UP	(GADGET_ID_COUNTER_FIRST + 38)
#define GADGET_ID_PUSH_DELAY_FIX_DOWN	(GADGET_ID_COUNTER_FIRST + 39)
#define GADGET_ID_PUSH_DELAY_FIX_TEXT	(GADGET_ID_COUNTER_FIRST + 40)
#define GADGET_ID_PUSH_DELAY_FIX_UP	(GADGET_ID_COUNTER_FIRST + 41)
#define GADGET_ID_PUSH_DELAY_RND_DOWN	(GADGET_ID_COUNTER_FIRST + 42)
#define GADGET_ID_PUSH_DELAY_RND_TEXT	(GADGET_ID_COUNTER_FIRST + 43)
#define GADGET_ID_PUSH_DELAY_RND_UP	(GADGET_ID_COUNTER_FIRST + 44)
#define GADGET_ID_MOVE_DELAY_FIX_DOWN	(GADGET_ID_COUNTER_FIRST + 45)
#define GADGET_ID_MOVE_DELAY_FIX_TEXT	(GADGET_ID_COUNTER_FIRST + 46)
#define GADGET_ID_MOVE_DELAY_FIX_UP	(GADGET_ID_COUNTER_FIRST + 47)
#define GADGET_ID_MOVE_DELAY_RND_DOWN	(GADGET_ID_COUNTER_FIRST + 48)
#define GADGET_ID_MOVE_DELAY_RND_TEXT	(GADGET_ID_COUNTER_FIRST + 49)
#define GADGET_ID_MOVE_DELAY_RND_UP	(GADGET_ID_COUNTER_FIRST + 50)
#define GADGET_ID_CHANGE_DELAY_FIX_DOWN	(GADGET_ID_COUNTER_FIRST + 51)
#define GADGET_ID_CHANGE_DELAY_FIX_TEXT	(GADGET_ID_COUNTER_FIRST + 52)
#define GADGET_ID_CHANGE_DELAY_FIX_UP	(GADGET_ID_COUNTER_FIRST + 53)
#define GADGET_ID_CHANGE_DELAY_RND_DOWN	(GADGET_ID_COUNTER_FIRST + 54)
#define GADGET_ID_CHANGE_DELAY_RND_TEXT	(GADGET_ID_COUNTER_FIRST + 55)
#define GADGET_ID_CHANGE_DELAY_RND_UP	(GADGET_ID_COUNTER_FIRST + 56)
#define GADGET_ID_CHANGE_CONT_RND_DOWN	(GADGET_ID_COUNTER_FIRST + 57)
#define GADGET_ID_CHANGE_CONT_RND_TEXT	(GADGET_ID_COUNTER_FIRST + 58)
#define GADGET_ID_CHANGE_CONT_RND_UP	(GADGET_ID_COUNTER_FIRST + 59)

/* drawing area identifiers */
#define GADGET_ID_DRAWING_AREA_FIRST	(GADGET_ID_COUNTER_FIRST + 60)

#define GADGET_ID_DRAWING_LEVEL		(GADGET_ID_DRAWING_AREA_FIRST + 0)
#define GADGET_ID_ELEMENT_CONTENT_0	(GADGET_ID_DRAWING_AREA_FIRST + 1)
#define GADGET_ID_ELEMENT_CONTENT_1	(GADGET_ID_DRAWING_AREA_FIRST + 2)
#define GADGET_ID_ELEMENT_CONTENT_2	(GADGET_ID_DRAWING_AREA_FIRST + 3)
#define GADGET_ID_ELEMENT_CONTENT_3	(GADGET_ID_DRAWING_AREA_FIRST + 4)
#define GADGET_ID_ELEMENT_CONTENT_4	(GADGET_ID_DRAWING_AREA_FIRST + 5)
#define GADGET_ID_ELEMENT_CONTENT_5	(GADGET_ID_DRAWING_AREA_FIRST + 6)
#define GADGET_ID_ELEMENT_CONTENT_6	(GADGET_ID_DRAWING_AREA_FIRST + 7)
#define GADGET_ID_ELEMENT_CONTENT_7	(GADGET_ID_DRAWING_AREA_FIRST + 8)
#define GADGET_ID_AMOEBA_CONTENT	(GADGET_ID_DRAWING_AREA_FIRST + 9)
#define GADGET_ID_CUSTOM_GRAPHIC	(GADGET_ID_DRAWING_AREA_FIRST + 10)
#define GADGET_ID_CUSTOM_CONTENT	(GADGET_ID_DRAWING_AREA_FIRST + 11)
#define GADGET_ID_CUSTOM_CHANGE_TARGET	(GADGET_ID_DRAWING_AREA_FIRST + 12)
#define GADGET_ID_CUSTOM_CHANGE_CONTENT	(GADGET_ID_DRAWING_AREA_FIRST + 13)
#define GADGET_ID_CUSTOM_CHANGE_TRIGGER	(GADGET_ID_DRAWING_AREA_FIRST + 14)
#define GADGET_ID_RANDOM_BACKGROUND	(GADGET_ID_DRAWING_AREA_FIRST + 15)

/* text input identifiers */
#define GADGET_ID_TEXT_INPUT_FIRST	(GADGET_ID_DRAWING_AREA_FIRST + 16)

#define GADGET_ID_LEVEL_NAME		(GADGET_ID_TEXT_INPUT_FIRST + 0)
#define GADGET_ID_LEVEL_AUTHOR		(GADGET_ID_TEXT_INPUT_FIRST + 1)
#define GADGET_ID_ELEMENT_NAME		(GADGET_ID_TEXT_INPUT_FIRST + 2)

/* text area identifiers */
#define GADGET_ID_TEXT_AREA_FIRST	(GADGET_ID_TEXT_INPUT_FIRST + 3)

#define GADGET_ID_ENVELOPE_INFO		(GADGET_ID_TEXT_AREA_FIRST + 0)

/* selectbox identifiers */
#define GADGET_ID_SELECTBOX_FIRST	(GADGET_ID_TEXT_AREA_FIRST + 1)

#define GADGET_ID_CUSTOM_WALK_TO_ACTION	(GADGET_ID_SELECTBOX_FIRST + 0)
#define GADGET_ID_CUSTOM_CONSISTENCY	(GADGET_ID_SELECTBOX_FIRST + 1)
#define GADGET_ID_CUSTOM_DEADLINESS	(GADGET_ID_SELECTBOX_FIRST + 2)
#define GADGET_ID_CUSTOM_MOVE_PATTERN	(GADGET_ID_SELECTBOX_FIRST + 3)
#define GADGET_ID_CUSTOM_MOVE_DIRECTION	(GADGET_ID_SELECTBOX_FIRST + 4)
#define GADGET_ID_CUSTOM_MOVE_STEPSIZE	(GADGET_ID_SELECTBOX_FIRST + 5)
#define GADGET_ID_CUSTOM_SMASH_TARGETS	(GADGET_ID_SELECTBOX_FIRST + 6)
#define GADGET_ID_CUSTOM_SLIPPERY_TYPE	(GADGET_ID_SELECTBOX_FIRST + 7)
#define GADGET_ID_CUSTOM_ACCESS_TYPE	(GADGET_ID_SELECTBOX_FIRST + 8)
#define GADGET_ID_CUSTOM_ACCESS_LAYER	(GADGET_ID_SELECTBOX_FIRST + 9)
#define GADGET_ID_CHANGE_TIME_UNITS	(GADGET_ID_SELECTBOX_FIRST + 10)
#define GADGET_ID_CHANGE_DIRECT_ACTION	(GADGET_ID_SELECTBOX_FIRST + 11)
#define GADGET_ID_CHANGE_OTHER_ACTION	(GADGET_ID_SELECTBOX_FIRST + 12)
#define GADGET_ID_CHANGE_SIDES		(GADGET_ID_SELECTBOX_FIRST + 13)
#define GADGET_ID_CHANGE_POWER		(GADGET_ID_SELECTBOX_FIRST + 14)
#define GADGET_ID_SELECT_CHANGE_PAGE	(GADGET_ID_SELECTBOX_FIRST + 15)

/* textbutton identifiers */
#define GADGET_ID_TEXTBUTTON_FIRST	(GADGET_ID_SELECTBOX_FIRST + 16)

#define GADGET_ID_PROPERTIES_INFO	(GADGET_ID_TEXTBUTTON_FIRST + 0)
#define GADGET_ID_PROPERTIES_CONFIG	(GADGET_ID_TEXTBUTTON_FIRST + 1)
#define GADGET_ID_PROPERTIES_ADVANCED	(GADGET_ID_TEXTBUTTON_FIRST + 2)
#define GADGET_ID_SAVE_AS_TEMPLATE	(GADGET_ID_TEXTBUTTON_FIRST + 3)
#define GADGET_ID_ADD_CHANGE_PAGE	(GADGET_ID_TEXTBUTTON_FIRST + 4)
#define GADGET_ID_DEL_CHANGE_PAGE	(GADGET_ID_TEXTBUTTON_FIRST + 5)

/* graphicbutton identifiers */
#define GADGET_ID_GRAPHICBUTTON_FIRST	(GADGET_ID_TEXTBUTTON_FIRST + 6)

#define GADGET_ID_PREV_CHANGE_PAGE	(GADGET_ID_GRAPHICBUTTON_FIRST + 0)
#define GADGET_ID_NEXT_CHANGE_PAGE	(GADGET_ID_GRAPHICBUTTON_FIRST + 1)

/* gadgets for scrolling of drawing area */
#define GADGET_ID_SCROLLING_FIRST	(GADGET_ID_GRAPHICBUTTON_FIRST + 2)

#define GADGET_ID_SCROLL_UP		(GADGET_ID_SCROLLING_FIRST + 0)
#define GADGET_ID_SCROLL_DOWN		(GADGET_ID_SCROLLING_FIRST + 1)
#define GADGET_ID_SCROLL_LEFT		(GADGET_ID_SCROLLING_FIRST + 2)
#define GADGET_ID_SCROLL_RIGHT		(GADGET_ID_SCROLLING_FIRST + 3)
#define GADGET_ID_SCROLL_HORIZONTAL	(GADGET_ID_SCROLLING_FIRST + 4)
#define GADGET_ID_SCROLL_VERTICAL	(GADGET_ID_SCROLLING_FIRST + 5)

/* gadgets for scrolling element list */
#define GADGET_ID_SCROLLING_LIST_FIRST	(GADGET_ID_SCROLLING_FIRST + 6)

#define GADGET_ID_SCROLL_LIST_UP	(GADGET_ID_SCROLLING_LIST_FIRST + 0)
#define GADGET_ID_SCROLL_LIST_DOWN	(GADGET_ID_SCROLLING_LIST_FIRST + 1)
#define GADGET_ID_SCROLL_LIST_VERTICAL	(GADGET_ID_SCROLLING_LIST_FIRST + 2)

/* checkbuttons for level/element properties */
#define GADGET_ID_CHECKBUTTON_FIRST	(GADGET_ID_SCROLLING_LIST_FIRST + 3)

#define GADGET_ID_RANDOM_PERCENTAGE	(GADGET_ID_CHECKBUTTON_FIRST + 0)
#define GADGET_ID_RANDOM_QUANTITY	(GADGET_ID_CHECKBUTTON_FIRST + 1)
#define GADGET_ID_RANDOM_RESTRICTED	(GADGET_ID_CHECKBUTTON_FIRST + 2)
#define GADGET_ID_DOUBLE_SPEED		(GADGET_ID_CHECKBUTTON_FIRST + 3)
#define GADGET_ID_GRAVITY		(GADGET_ID_CHECKBUTTON_FIRST + 4)
#define GADGET_ID_STICK_ELEMENT		(GADGET_ID_CHECKBUTTON_FIRST + 5)
#define GADGET_ID_EM_SLIPPERY_GEMS	(GADGET_ID_CHECKBUTTON_FIRST + 6)
#define GADGET_ID_CUSTOM_EXPLODE_RESULT	(GADGET_ID_CHECKBUTTON_FIRST + 7)
#define GADGET_ID_CUSTOM_EXPLODE_FIRE	(GADGET_ID_CHECKBUTTON_FIRST + 8)
#define GADGET_ID_CUSTOM_EXPLODE_SMASH	(GADGET_ID_CHECKBUTTON_FIRST + 9)
#define GADGET_ID_CUSTOM_EXPLODE_IMPACT	(GADGET_ID_CHECKBUTTON_FIRST + 10)
#define GADGET_ID_CUSTOM_WALK_TO_OBJECT	(GADGET_ID_CHECKBUTTON_FIRST + 11)
#define GADGET_ID_CUSTOM_DEADLY		(GADGET_ID_CHECKBUTTON_FIRST + 12)
#define GADGET_ID_CUSTOM_CAN_MOVE	(GADGET_ID_CHECKBUTTON_FIRST + 13)
#define GADGET_ID_CUSTOM_CAN_FALL	(GADGET_ID_CHECKBUTTON_FIRST + 14)
#define GADGET_ID_CUSTOM_CAN_SMASH	(GADGET_ID_CHECKBUTTON_FIRST + 15)
#define GADGET_ID_CUSTOM_SLIPPERY	(GADGET_ID_CHECKBUTTON_FIRST + 16)
#define GADGET_ID_CUSTOM_ACCESSIBLE	(GADGET_ID_CHECKBUTTON_FIRST + 17)
#define GADGET_ID_CUSTOM_USE_GRAPHIC	(GADGET_ID_CHECKBUTTON_FIRST + 18)
#define GADGET_ID_CUSTOM_USE_TEMPLATE	(GADGET_ID_CHECKBUTTON_FIRST + 19)
#define GADGET_ID_CUSTOM_CAN_CHANGE	(GADGET_ID_CHECKBUTTON_FIRST + 20)
#define GADGET_ID_CHANGE_USE_CONTENT	(GADGET_ID_CHECKBUTTON_FIRST + 21)
#define GADGET_ID_CHANGE_USE_EXPLOSION	(GADGET_ID_CHECKBUTTON_FIRST + 22)
#define GADGET_ID_CHANGE_ONLY_COMPLETE	(GADGET_ID_CHECKBUTTON_FIRST + 23)
#define GADGET_ID_CHANGE_USE_RANDOM	(GADGET_ID_CHECKBUTTON_FIRST + 24)
#define GADGET_ID_CHANGE_DELAY		(GADGET_ID_CHECKBUTTON_FIRST + 25)
#define GADGET_ID_CHANGE_BY_DIRECT_ACT	(GADGET_ID_CHECKBUTTON_FIRST + 26)
#define GADGET_ID_CHANGE_BY_OTHER_ACT	(GADGET_ID_CHECKBUTTON_FIRST + 27)

/* gadgets for buttons in element list */
#define GADGET_ID_ELEMENTLIST_FIRST	(GADGET_ID_CHECKBUTTON_FIRST + 28)
#define GADGET_ID_ELEMENTLIST_LAST	(GADGET_ID_ELEMENTLIST_FIRST +	\
	 				ED_NUM_ELEMENTLIST_BUTTONS - 1)

#define NUM_EDITOR_GADGETS		(GADGET_ID_ELEMENTLIST_LAST + 1)

/* radio button numbers */
#define RADIO_NR_NONE			0
#define RADIO_NR_DRAWING_TOOLBOX	1
#define RADIO_NR_RANDOM_ELEMENTS	2

/* values for counter gadgets */
#define ED_COUNTER_ID_SELECT_LEVEL	0
#define ED_COUNTER_ID_LEVEL_XSIZE	1
#define ED_COUNTER_ID_LEVEL_YSIZE	2
#define ED_COUNTER_ID_LEVEL_GEMSLIMIT	3
#define ED_COUNTER_ID_LEVEL_TIMELIMIT	4
#define ED_COUNTER_ID_LEVEL_TIMESCORE	5
#define ED_COUNTER_ID_LEVEL_RANDOM	6
#define ED_COUNTER_ID_ELEMENT_SCORE	7
#define ED_COUNTER_ID_ELEMENT_CONTENT	8
#define ED_COUNTER_ID_ENVELOPE_XSIZE	9
#define ED_COUNTER_ID_ENVELOPE_YSIZE	10
#define ED_COUNTER_ID_CUSTOM_SCORE	11
#define ED_COUNTER_ID_CUSTOM_GEMCOUNT	12
#define ED_COUNTER_ID_PUSH_DELAY_FIX	13
#define ED_COUNTER_ID_PUSH_DELAY_RND	14
#define ED_COUNTER_ID_MOVE_DELAY_FIX	15
#define ED_COUNTER_ID_MOVE_DELAY_RND	16
#define ED_COUNTER_ID_CHANGE_DELAY_FIX	17
#define ED_COUNTER_ID_CHANGE_DELAY_RND	18
#define ED_COUNTER_ID_CHANGE_CONT_RND	19

#define ED_NUM_COUNTERBUTTONS		20

#define ED_COUNTER_ID_LEVEL_FIRST	ED_COUNTER_ID_LEVEL_XSIZE
#define ED_COUNTER_ID_LEVEL_LAST	ED_COUNTER_ID_LEVEL_RANDOM

#define ED_COUNTER_ID_CUSTOM_FIRST	ED_COUNTER_ID_CUSTOM_SCORE
#define ED_COUNTER_ID_CUSTOM_LAST	ED_COUNTER_ID_MOVE_DELAY_RND

#define ED_COUNTER_ID_CHANGE_FIRST	ED_COUNTER_ID_CHANGE_DELAY_FIX
#define ED_COUNTER_ID_CHANGE_LAST	ED_COUNTER_ID_CHANGE_CONT_RND

/* values for scrollbutton gadgets */
#define ED_SCROLLBUTTON_ID_AREA_UP	0
#define ED_SCROLLBUTTON_ID_AREA_DOWN	1
#define ED_SCROLLBUTTON_ID_AREA_LEFT	2
#define ED_SCROLLBUTTON_ID_AREA_RIGHT	3
#define ED_SCROLLBUTTON_ID_LIST_UP	4
#define ED_SCROLLBUTTON_ID_LIST_DOWN	5

#define ED_NUM_SCROLLBUTTONS		6

#define ED_SCROLLBUTTON_ID_AREA_FIRST	ED_SCROLLBUTTON_ID_AREA_UP
#define ED_SCROLLBUTTON_ID_AREA_LAST	ED_SCROLLBUTTON_ID_AREA_RIGHT

/* values for scrollbar gadgets */
#define ED_SCROLLBAR_ID_AREA_HORIZONTAL	0
#define ED_SCROLLBAR_ID_AREA_VERTICAL	1
#define ED_SCROLLBAR_ID_LIST_VERTICAL	2

#define ED_NUM_SCROLLBARS		3

#define ED_SCROLLBAR_ID_AREA_FIRST	ED_SCROLLBAR_ID_AREA_HORIZONTAL
#define ED_SCROLLBAR_ID_AREA_LAST	ED_SCROLLBAR_ID_AREA_VERTICAL

/* values for text input gadgets */
#define ED_TEXTINPUT_ID_LEVEL_NAME	0
#define ED_TEXTINPUT_ID_LEVEL_AUTHOR	1
#define ED_TEXTINPUT_ID_ELEMENT_NAME	2

#define ED_NUM_TEXTINPUT		3

#define ED_TEXTINPUT_ID_LEVEL_FIRST	ED_TEXTINPUT_ID_LEVEL_NAME
#define ED_TEXTINPUT_ID_LEVEL_LAST	ED_TEXTINPUT_ID_LEVEL_AUTHOR

/* values for text area gadgets */
#define ED_TEXTAREA_ID_ENVELOPE_INFO	0

#define ED_NUM_TEXTAREAS			1

#define ED_TEXTAREA_ID_LEVEL_FIRST	ED_TEXTAREA_ID_ENVELOPE
#define ED_TEXTAREA_ID_LEVEL_LAST	ED_TEXTAREA_ID_ENVELOPE

/* values for selectbox gadgets */
#define ED_SELECTBOX_ID_CUSTOM_ACCESS_TYPE	0
#define ED_SELECTBOX_ID_CUSTOM_ACCESS_LAYER	1
#define ED_SELECTBOX_ID_CUSTOM_WALK_TO_ACTION	2
#define ED_SELECTBOX_ID_CUSTOM_MOVE_PATTERN	3
#define ED_SELECTBOX_ID_CUSTOM_MOVE_DIRECTION	4
#define ED_SELECTBOX_ID_CUSTOM_MOVE_STEPSIZE	5
#define ED_SELECTBOX_ID_CUSTOM_SMASH_TARGETS	6
#define ED_SELECTBOX_ID_CUSTOM_SLIPPERY_TYPE	7
#define ED_SELECTBOX_ID_CUSTOM_DEADLINESS	8
#define ED_SELECTBOX_ID_CUSTOM_CONSISTENCY	9
#define ED_SELECTBOX_ID_CHANGE_TIME_UNITS	10
#define ED_SELECTBOX_ID_CHANGE_DIRECT_ACTION	11
#define ED_SELECTBOX_ID_CHANGE_OTHER_ACTION	12
#define ED_SELECTBOX_ID_CHANGE_SIDES		13
#define ED_SELECTBOX_ID_CHANGE_POWER		14
#define ED_SELECTBOX_ID_SELECT_CHANGE_PAGE	15

#define ED_NUM_SELECTBOX			16

#define ED_SELECTBOX_ID_CUSTOM_FIRST	ED_SELECTBOX_ID_CUSTOM_ACCESS_TYPE
#define ED_SELECTBOX_ID_CUSTOM_LAST	ED_SELECTBOX_ID_CUSTOM_CONSISTENCY

#define ED_SELECTBOX_ID_CHANGE_FIRST	ED_SELECTBOX_ID_CHANGE_TIME_UNITS
#define ED_SELECTBOX_ID_CHANGE_LAST	ED_SELECTBOX_ID_SELECT_CHANGE_PAGE

/* values for textbutton gadgets */
#define ED_TEXTBUTTON_ID_PROPERTIES_INFO	0
#define ED_TEXTBUTTON_ID_PROPERTIES_CONFIG	1
#define ED_TEXTBUTTON_ID_PROPERTIES_ADVANCED	2
#define ED_TEXTBUTTON_ID_SAVE_AS_TEMPLATE	3
#define ED_TEXTBUTTON_ID_ADD_CHANGE_PAGE	4
#define ED_TEXTBUTTON_ID_DEL_CHANGE_PAGE	5

#define ED_NUM_TEXTBUTTONS			6

#define ED_TEXTBUTTON_ID_PROPERTIES_FIRST ED_TEXTBUTTON_ID_PROPERTIES_INFO
#define ED_TEXTBUTTON_ID_PROPERTIES_LAST  ED_TEXTBUTTON_ID_PROPERTIES_ADVANCED

#define ED_TEXTBUTTON_ID_CHANGE_FIRST	ED_TEXTBUTTON_ID_SAVE_AS_TEMPLATE
#define ED_TEXTBUTTON_ID_CHANGE_LAST	ED_TEXTBUTTON_ID_DEL_CHANGE_PAGE

/* values for graphicbutton gadgets */
#define ED_GRAPHICBUTTON_ID_PREV_CHANGE_PAGE	0
#define ED_GRAPHICBUTTON_ID_NEXT_CHANGE_PAGE	1

#define ED_NUM_GRAPHICBUTTONS			2

#define ED_GRAPHICBUTTON_ID_CHANGE_FIRST   ED_GRAPHICBUTTON_ID_PREV_CHANGE_PAGE
#define ED_GRAPHICBUTTON_ID_CHANGE_LAST    ED_GRAPHICBUTTON_ID_NEXT_CHANGE_PAGE

/* values for checkbutton gadgets */
#define ED_CHECKBUTTON_ID_DOUBLE_SPEED		0
#define ED_CHECKBUTTON_ID_GRAVITY		1
#define ED_CHECKBUTTON_ID_RANDOM_RESTRICTED	2
#define ED_CHECKBUTTON_ID_STICK_ELEMENT		3
#define ED_CHECKBUTTON_ID_EM_SLIPPERY_GEMS	4
#define ED_CHECKBUTTON_ID_CUSTOM_ACCESSIBLE	5
#define ED_CHECKBUTTON_ID_CUSTOM_WALK_TO_OBJECT	6
#define ED_CHECKBUTTON_ID_CUSTOM_CAN_MOVE	7
#define ED_CHECKBUTTON_ID_CUSTOM_CAN_FALL	8
#define ED_CHECKBUTTON_ID_CUSTOM_CAN_SMASH	9
#define ED_CHECKBUTTON_ID_CUSTOM_SLIPPERY	10
#define ED_CHECKBUTTON_ID_CUSTOM_DEADLY		11
#define ED_CHECKBUTTON_ID_CUSTOM_EXPLODE_RESULT	12
#define ED_CHECKBUTTON_ID_CUSTOM_EXPLODE_FIRE	13
#define ED_CHECKBUTTON_ID_CUSTOM_EXPLODE_SMASH	14
#define ED_CHECKBUTTON_ID_CUSTOM_EXPLODE_IMPACT	15
#define ED_CHECKBUTTON_ID_CUSTOM_USE_GRAPHIC	16
#define ED_CHECKBUTTON_ID_CUSTOM_CAN_CHANGE	17
#define ED_CHECKBUTTON_ID_CHANGE_DELAY		18
#define ED_CHECKBUTTON_ID_CHANGE_BY_DIRECT_ACT	19
#define ED_CHECKBUTTON_ID_CHANGE_BY_OTHER_ACT	20
#define ED_CHECKBUTTON_ID_CHANGE_USE_EXPLOSION	21
#define ED_CHECKBUTTON_ID_CHANGE_USE_CONTENT	22
#define ED_CHECKBUTTON_ID_CHANGE_ONLY_COMPLETE	23
#define ED_CHECKBUTTON_ID_CHANGE_USE_RANDOM	24
#define ED_CHECKBUTTON_ID_CUSTOM_USE_TEMPLATE	25

#define ED_NUM_CHECKBUTTONS			26

#define ED_CHECKBUTTON_ID_LEVEL_FIRST	ED_CHECKBUTTON_ID_DOUBLE_SPEED
#define ED_CHECKBUTTON_ID_LEVEL_LAST	ED_CHECKBUTTON_ID_RANDOM_RESTRICTED

#define ED_CHECKBUTTON_ID_CUSTOM_FIRST	ED_CHECKBUTTON_ID_CUSTOM_ACCESSIBLE
#define ED_CHECKBUTTON_ID_CUSTOM_LAST	ED_CHECKBUTTON_ID_CUSTOM_EXPLODE_IMPACT

#define ED_CHECKBUTTON_ID_CHANGE_FIRST	ED_CHECKBUTTON_ID_CUSTOM_USE_GRAPHIC
#define ED_CHECKBUTTON_ID_CHANGE_LAST	ED_CHECKBUTTON_ID_CUSTOM_USE_TEMPLATE

/* values for radiobutton gadgets */
#define ED_RADIOBUTTON_ID_PERCENTAGE	0
#define ED_RADIOBUTTON_ID_QUANTITY	1

#define ED_NUM_RADIOBUTTONS		2

#define ED_RADIOBUTTON_ID_LEVEL_FIRST	ED_RADIOBUTTON_ID_PERCENTAGE
#define ED_RADIOBUTTON_ID_LEVEL_LAST	ED_RADIOBUTTON_ID_QUANTITY

/* values for drawing area gadgets */
#define ED_DRAWING_ID_DRAWING_LEVEL		0
#define ED_DRAWING_ID_ELEMENT_CONTENT_0		1
#define ED_DRAWING_ID_ELEMENT_CONTENT_1		2
#define ED_DRAWING_ID_ELEMENT_CONTENT_2		3
#define ED_DRAWING_ID_ELEMENT_CONTENT_3		4
#define ED_DRAWING_ID_ELEMENT_CONTENT_4		5
#define ED_DRAWING_ID_ELEMENT_CONTENT_5		6
#define ED_DRAWING_ID_ELEMENT_CONTENT_6		7
#define ED_DRAWING_ID_ELEMENT_CONTENT_7		8
#define ED_DRAWING_ID_AMOEBA_CONTENT		9
#define ED_DRAWING_ID_CUSTOM_GRAPHIC		10
#define ED_DRAWING_ID_CUSTOM_CONTENT		11
#define ED_DRAWING_ID_CUSTOM_CHANGE_TARGET	12
#define ED_DRAWING_ID_CUSTOM_CHANGE_CONTENT	13
#define ED_DRAWING_ID_CUSTOM_CHANGE_TRIGGER	14
#define ED_DRAWING_ID_RANDOM_BACKGROUND		15

#define ED_NUM_DRAWING_AREAS			16


/*
  -----------------------------------------------------------------------------
  some internally used definitions
  -----------------------------------------------------------------------------
*/

/* values for CopyLevelToUndoBuffer() */
#define UNDO_IMMEDIATE			0
#define UNDO_ACCUMULATE			1

/* values for scrollbars */
#define ED_SCROLL_NO			0
#define ED_SCROLL_LEFT			1
#define ED_SCROLL_RIGHT			2
#define ED_SCROLL_UP			4
#define ED_SCROLL_DOWN			8

/* screens in the level editor */
#define ED_MODE_DRAWING			0
#define ED_MODE_INFO			1
#define ED_MODE_PROPERTIES		2

/* sub-screens in the element properties section */
#define ED_MODE_PROPERTIES_INFO		ED_TEXTBUTTON_ID_PROPERTIES_INFO
#define ED_MODE_PROPERTIES_CONFIG	ED_TEXTBUTTON_ID_PROPERTIES_CONFIG
#define ED_MODE_PROPERTIES_ADVANCED	ED_TEXTBUTTON_ID_PROPERTIES_ADVANCED

/* how many steps can be cancelled */
#define NUM_UNDO_STEPS			(10 + 1)

/* values for elements with score for certain actions */
#define MIN_SCORE			0
#define MAX_SCORE			255

/* values for elements with count for collecting */
#define MIN_COLLECT_COUNT		0
#define MAX_COLLECT_COUNT		100

/* values for random placement */
#define RANDOM_USE_PERCENTAGE		0
#define RANDOM_USE_QUANTITY		1

/* maximal size of level editor drawing area */
#define MAX_ED_FIELDX		(2 * SCR_FIELDX)
#define MAX_ED_FIELDY		(2 * SCR_FIELDY - 1)


/*
  -----------------------------------------------------------------------------
  some internally used data structure definitions
  -----------------------------------------------------------------------------
*/

static struct
{
  char shortcut;
  char *text;
} control_info[ED_NUM_CTRL_BUTTONS] =
{
  { 's',	"draw single items"		},
  { 'd',	"draw connected items"		},
  { 'l',	"draw lines"			},
  { 'a',	"draw arcs"			},
  { 'r',	"draw outline rectangles"	},
  { 'R',	"draw filled rectangles"	},
  { '\0',	"wrap (rotate) level up"	},
  { 't',	"enter text elements"		},
  { 'f',	"flood fill"			},
  { '\0',	"wrap (rotate) level left"	},
  { '?',	"properties of drawing element"	},
  { '\0',	"wrap (rotate) level right"	},
  { '\0',	"random element placement"	},
  { 'b',	"grab brush"			},
  { '\0',	"wrap (rotate) level down"	},
  { ',',	"pick drawing element"		},
  { 'U',	"undo last operation"		},
  { 'I',	"level properties"		},
  { 'S',	"save level"			},
  { 'C',	"clear level"			},
  { 'T',	"test level"			},
  { 'E',	"exit level editor"		}
};

static int random_placement_value = 10;
static int random_placement_method = RANDOM_USE_QUANTITY;
static int random_placement_background_element = EL_SAND;
static boolean random_placement_background_restricted = FALSE;
static boolean stick_element_properties_window = FALSE;
static boolean custom_element_properties[NUM_ELEMENT_PROPERTIES];
static boolean custom_element_change_events[NUM_CHANGE_EVENTS];
static struct ElementChangeInfo custom_element_change;
static struct ElementInfo custom_element;

static struct
{
  int x, y;
  int min_value, max_value;
  int gadget_id_down, gadget_id_up;
  int gadget_id_text;
  int gadget_id_align;
  int *value;
  char *text_above, *text_left, *text_right;
} counterbutton_info[ED_NUM_COUNTERBUTTONS] =
{
  /* ---------- level and editor settings ---------------------------------- */

  {
    DX + 5 - SX,			DY + 3 - SY,
    1,					100,
    GADGET_ID_SELECT_LEVEL_DOWN,	GADGET_ID_SELECT_LEVEL_UP,
    GADGET_ID_SELECT_LEVEL_TEXT,	GADGET_ID_NONE,
    &level_nr,
    NULL,				NULL, NULL
  },
  {
    ED_SETTINGS_XPOS(0),		ED_COUNTER_YPOS(2),
    MIN_LEV_FIELDX,			MAX_LEV_FIELDX,
    GADGET_ID_LEVEL_XSIZE_DOWN,		GADGET_ID_LEVEL_XSIZE_UP,
    GADGET_ID_LEVEL_XSIZE_TEXT,		GADGET_ID_NONE,
    &level.fieldx,
    "playfield size:",			NULL, "width",
  },
  {
    -1,					ED_COUNTER_YPOS(2),
    MIN_LEV_FIELDY,			MAX_LEV_FIELDY,
    GADGET_ID_LEVEL_YSIZE_DOWN,		GADGET_ID_LEVEL_YSIZE_UP,
    GADGET_ID_LEVEL_YSIZE_TEXT,		GADGET_ID_LEVEL_XSIZE_UP,
    &level.fieldy,
    NULL,				" ", "height",
  },
  {
    ED_SETTINGS_XPOS(0),		ED_COUNTER_YPOS(3),
    0,					999,
    GADGET_ID_LEVEL_GEMSLIMIT_DOWN,	GADGET_ID_LEVEL_GEMSLIMIT_UP,
    GADGET_ID_LEVEL_GEMSLIMIT_TEXT,	GADGET_ID_NONE,
    &level.gems_needed,
    "number of emeralds to collect:",	NULL, NULL
  },
  {
    ED_SETTINGS_XPOS(0),		ED_COUNTER_YPOS(4),
    0,					999,
    GADGET_ID_LEVEL_TIMELIMIT_DOWN,	GADGET_ID_LEVEL_TIMELIMIT_UP,
    GADGET_ID_LEVEL_TIMELIMIT_TEXT,	GADGET_ID_NONE,
    &level.time,
    "time available to solve level:",	NULL, "(0 => no time limit)"
  },
  {
    ED_SETTINGS_XPOS(0),		ED_COUNTER_YPOS(5),
    0,					255,
    GADGET_ID_LEVEL_TIMESCORE_DOWN,	GADGET_ID_LEVEL_TIMESCORE_UP,
    GADGET_ID_LEVEL_TIMESCORE_TEXT,	GADGET_ID_NONE,
    &level.score[SC_TIME_BONUS],
    "score for each 10 seconds left:",	NULL, NULL
  },
  {
    ED_SETTINGS_XPOS(0),		ED_COUNTER2_YPOS(8),
    1,					100,
    GADGET_ID_LEVEL_RANDOM_DOWN,	GADGET_ID_LEVEL_RANDOM_UP,
    GADGET_ID_LEVEL_RANDOM_TEXT,	GADGET_ID_NONE,
    &random_placement_value,
    "random element placement:",	NULL, "in"
  },

  /* ---------- element settings: configure (various elements) ------------- */

  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(0),
    MIN_SCORE,				MAX_SCORE,
    GADGET_ID_ELEMENT_SCORE_DOWN,	GADGET_ID_ELEMENT_SCORE_UP,
    GADGET_ID_ELEMENT_SCORE_TEXT,	GADGET_ID_NONE,
    NULL,				/* will be set when used */
    NULL,				NULL, NULL
  },
  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(6),
    MIN_ELEMENT_CONTENTS,		MAX_ELEMENT_CONTENTS,
    GADGET_ID_ELEMENT_CONTENT_DOWN,	GADGET_ID_ELEMENT_CONTENT_UP,
    GADGET_ID_ELEMENT_CONTENT_TEXT,	GADGET_ID_NONE,
    &level.num_yamyam_contents,
    NULL,				NULL, "number of content areas"
  },
  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(0),
    MIN_ENVELOPE_XSIZE,			MAX_ENVELOPE_XSIZE,
    GADGET_ID_ENVELOPE_XSIZE_DOWN,	GADGET_ID_ENVELOPE_XSIZE_UP,
    GADGET_ID_ENVELOPE_XSIZE_TEXT,	GADGET_ID_NONE,
    NULL,
    NULL,				NULL, "width",
  },
  {
    -1,					ED_SETTINGS_YPOS(0),
    MIN_ENVELOPE_YSIZE,			MAX_ENVELOPE_YSIZE,
    GADGET_ID_ENVELOPE_YSIZE_DOWN,	GADGET_ID_ENVELOPE_YSIZE_UP,
    GADGET_ID_ENVELOPE_YSIZE_TEXT,	GADGET_ID_ENVELOPE_XSIZE_UP,
    NULL,
    NULL,				" ", "height",
  },

  /* ---------- element settings: configure (custom elements) ------------- */

  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(3),
    MIN_SCORE,				MAX_SCORE,
    GADGET_ID_CUSTOM_SCORE_DOWN,	GADGET_ID_CUSTOM_SCORE_UP,
    GADGET_ID_CUSTOM_SCORE_TEXT,	GADGET_ID_NONE,
    &custom_element.collect_score,
    NULL,				"score", " "
  },
  {
    -1,					ED_SETTINGS_YPOS(3),
    MIN_COLLECT_COUNT,			MAX_COLLECT_COUNT,
    GADGET_ID_CUSTOM_GEMCOUNT_DOWN,	GADGET_ID_CUSTOM_GEMCOUNT_UP,
    GADGET_ID_CUSTOM_GEMCOUNT_TEXT,	GADGET_ID_CUSTOM_SCORE_UP,
    &custom_element.collect_count,
    NULL,				"count", NULL
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(4),
    0,					999,
    GADGET_ID_PUSH_DELAY_FIX_DOWN,	GADGET_ID_PUSH_DELAY_FIX_UP,
    GADGET_ID_PUSH_DELAY_FIX_TEXT,	GADGET_ID_NONE,
    &custom_element.push_delay_fixed,
    NULL,				"push delay", NULL
  },
  {
    -1,					ED_SETTINGS_YPOS(4),
    0,					999,
    GADGET_ID_PUSH_DELAY_RND_DOWN,	GADGET_ID_PUSH_DELAY_RND_UP,
    GADGET_ID_PUSH_DELAY_RND_TEXT,	GADGET_ID_PUSH_DELAY_FIX_UP,
    &custom_element.push_delay_random,
    NULL,				"+random", NULL
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(7),
    0,					999,
    GADGET_ID_MOVE_DELAY_FIX_DOWN,	GADGET_ID_MOVE_DELAY_FIX_UP,
    GADGET_ID_MOVE_DELAY_FIX_TEXT,	GADGET_ID_NONE,
    &custom_element.move_delay_fixed,
    NULL,				"move delay", NULL
  },
  {
    -1,					ED_SETTINGS_YPOS(7),
    0,					999,
    GADGET_ID_MOVE_DELAY_RND_DOWN,	GADGET_ID_MOVE_DELAY_RND_UP,
    GADGET_ID_MOVE_DELAY_RND_TEXT,	GADGET_ID_MOVE_DELAY_FIX_UP,
    &custom_element.move_delay_random,
    NULL,				"+random", NULL
  },

  /* ---------- element settings: advanced (custom elements) --------------- */

  {
    ED_SETTINGS_XPOS(2),		ED_SETTINGS_YPOS(3),
    0,					999,
    GADGET_ID_CHANGE_DELAY_FIX_DOWN,	GADGET_ID_CHANGE_DELAY_FIX_UP,
    GADGET_ID_CHANGE_DELAY_FIX_TEXT,	GADGET_ID_NONE,
    &custom_element_change.delay_fixed,
    NULL,				"delay", NULL,
  },
  {
    -1,					ED_SETTINGS_YPOS(3),
    0,					999,
    GADGET_ID_CHANGE_DELAY_RND_DOWN,	GADGET_ID_CHANGE_DELAY_RND_UP,
    GADGET_ID_CHANGE_DELAY_RND_TEXT,	GADGET_ID_CHANGE_DELAY_FIX_UP,
    &custom_element_change.delay_random,
    NULL,				"+random", NULL
  },
  {
    ED_SETTINGS_XPOS(3),		ED_SETTINGS_YPOS(12),
    0,					100,
    GADGET_ID_CHANGE_CONT_RND_DOWN,	GADGET_ID_CHANGE_CONT_RND_UP,
    GADGET_ID_CHANGE_CONT_RND_TEXT,	GADGET_ID_NONE,
    &custom_element_change.random,
    NULL,				"use random replace:", "%"
  },
};

static struct
{
  int x, y;
  int gadget_id;
  int size;
  char *value;
  char *text_above, *infotext;
} textinput_info[ED_NUM_TEXTINPUT] =
{
  {
    ED_SETTINGS_XPOS(0),		ED_COUNTER_YPOS(0),
    GADGET_ID_LEVEL_NAME,
    MAX_LEVEL_NAME_LEN,
    level.name,
    "Title:", "Title"
  },
  {
    ED_SETTINGS_XPOS(0),		ED_COUNTER_YPOS(1),
    GADGET_ID_LEVEL_AUTHOR,
    MAX_LEVEL_AUTHOR_LEN,
    level.author,
    "Author:", "Author"
  },
  {
    5 * MINI_TILEX,			5 * MINI_TILEY - ED_BORDER_SIZE,
    GADGET_ID_ELEMENT_NAME,
    MAX_ELEMENT_NAME_LEN - 2,		/* currently 2 chars less editable */
    custom_element.description,
    NULL, "Element name"
  }
};

static struct
{
  int x, y;
  int gadget_id;
  int xsize, ysize;
  char *value;
  char *text_above, *infotext;
} textarea_info[ED_NUM_TEXTAREAS] =
{
  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(2),
    GADGET_ID_ENVELOPE_INFO,
    MAX_ENVELOPE_XSIZE, MAX_ENVELOPE_YSIZE,
    NULL,
    "Envelope Info:", "Envelope Info"
  }
};

static struct ValueTextInfo options_access_type[] =
{
  { EP_WALKABLE,		"walk"				},
  { EP_PASSABLE,		"pass"				},
  { -1,				NULL				}
};

static struct ValueTextInfo options_access_layer[] =
{
  { EP_ACCESSIBLE_OVER,		"over"				},
  { EP_ACCESSIBLE_INSIDE,	"inside"			},
  { EP_ACCESSIBLE_UNDER,	"under"				},
  { -1,				NULL				}
};

static struct ValueTextInfo options_walk_to_action[] =
{
  { EP_DIGGABLE,		"diggable"			},
  { EP_COLLECTIBLE_ONLY,	"collectible"			},
  { EP_DROPPABLE,		"collectible & droppable"	},
  { EP_PUSHABLE,		"pushable"			},
  { -1,				NULL				}
};

static struct ValueTextInfo options_move_pattern[] =
{
  { MV_LEFT,			"left"				},
  { MV_RIGHT,			"right"				},
  { MV_UP,			"up"				},
  { MV_DOWN,			"down"				},
  { MV_HORIZONTAL,		"horizontal"			},
  { MV_VERTICAL,		"vertical"			},
  { MV_ALL_DIRECTIONS,		"all directions"		},
  { MV_TOWARDS_PLAYER,		"towards player"		},
  { MV_AWAY_FROM_PLAYER,	"away from player"		},
  { MV_ALONG_LEFT_SIDE,		"along left side"		},
  { MV_ALONG_RIGHT_SIDE,	"along right side"		},
  { MV_TURNING_LEFT,		"turning left"			},
  { MV_TURNING_RIGHT,		"turning right"			},
  { MV_WHEN_PUSHED,		"when pushed"			},
  { -1,				NULL				}
};

static struct ValueTextInfo options_move_direction[] =
{
  { MV_NO_MOVING,		"automatic"			},
  { MV_LEFT,			"left"				},
  { MV_RIGHT,			"right"				},
  { MV_UP,			"up"				},
  { MV_DOWN,			"down"				},
  { -1,				NULL				}
};

static struct ValueTextInfo options_move_stepsize[] =
{
  { 1,				"very slow"			},
  { 2,				"slow"				},
  { 4,				"normal"			},
  { 8,				"fast"				},
  { 16,				"very fast"			},
  { -1,				NULL				}
};

static struct ValueTextInfo options_smash_targets[] =
{
  { EP_CAN_SMASH_PLAYER,	"player"			},
#if 0
  { EP_CAN_SMASH_ENEMIES,	"enemies"			},
#endif
  { EP_CAN_SMASH_EVERYTHING,	"everything"			},
  { -1,				NULL				}
};

static struct ValueTextInfo options_slippery_type[] =
{
  { SLIPPERY_ANY_RANDOM,	"random"			},
  { SLIPPERY_ANY_LEFT_RIGHT,	"left, right"			},
  { SLIPPERY_ANY_RIGHT_LEFT,	"right, left"			},
  { SLIPPERY_ONLY_LEFT,		"only left"			},
  { SLIPPERY_ONLY_RIGHT,	"only right"			},
  { -1,				NULL				}
};

static struct ValueTextInfo options_deadliness[] =
{
  { EP_DONT_RUN_INTO,		"running into"			},
  { EP_DONT_COLLIDE_WITH,	"colliding with"		},
  { EP_DONT_TOUCH,		"touching"			},
  { -1,				NULL				}
};

static struct ValueTextInfo options_consistency[] =
{
  { EP_CAN_EXPLODE_3X3,		"can explode 3x3"		},
  { EP_CAN_EXPLODE_1X1,		"can explode 1x1"		},
  { EP_INDESTRUCTIBLE,		"indestructible"		},
  { -1,				NULL				}
};

static struct ValueTextInfo options_time_units[] =
{
  { 1,				"frames"			},
  { FRAMES_PER_SECOND,		"seconds"			},
  { -1,				NULL				}
};

static struct ValueTextInfo options_change_direct_action[] =
{
  { CE_TOUCHED_BY_PLAYER,	"touched by player ..."		},
  { CE_PRESSED_BY_PLAYER,	"pressed by player ..."		},
  { CE_PUSHED_BY_PLAYER,	"pushed by player ..."		},
  { CE_ENTERED_BY_PLAYER,	"entered by player ..."		},
  { CE_LEFT_BY_PLAYER,		"left by player ..."		},
  { CE_DROPPED_BY_PLAYER,	"dropped by player"		},
  { CE_COLLISION,		"collision ..."			},
  { CE_IMPACT,			"impact"			},
  { CE_SMASHED,			"smashed"			},
  { -1,				NULL				}
};

static struct ValueTextInfo options_change_other_action[] =
{
  { CE_OTHER_GETS_TOUCHED,	"player touches ..."		},
  { CE_OTHER_GETS_PRESSED,	"player presses ..."		},
  { CE_OTHER_GETS_PUSHED,	"player pushes ..."		},
  { CE_OTHER_GETS_ENTERED,	"player enters ..."		},
  { CE_OTHER_GETS_LEFT,		"player leaves ..."		},
  { CE_OTHER_GETS_DIGGED,	"player digs"			},
  { CE_OTHER_GETS_COLLECTED,	"player collects"		},
  { CE_OTHER_GETS_DROPPED,	"player drops"			},
  { CE_OTHER_IS_TOUCHING,	"touching ..."			},
  { CE_OTHER_IS_CHANGING,	"change of"			},
  { CE_OTHER_IS_EXPLODING,	"explosion of"			},
  { -1,				NULL				}
};

static struct ValueTextInfo options_change_sides[] =
{
  { CH_SIDE_LEFT,		"left side"			},
  { CH_SIDE_RIGHT,		"right side"			},
  { CH_SIDE_TOP,		"top side"			},
  { CH_SIDE_BOTTOM,		"bottom side"			},
  { CH_SIDE_LEFT_RIGHT,		"left/right side"		},
  { CH_SIDE_TOP_BOTTOM,		"top/bottom side"		},
  { CH_SIDE_ANY,		"all sides"			},
  { -1,				NULL				}
};

static struct ValueTextInfo options_change_power[] =
{
  { CP_NON_DESTRUCTIVE,		"empty"				},
  { CP_HALF_DESTRUCTIVE,	"diggable"			},
  { CP_FULL_DESTRUCTIVE,	"destructible"			},
  { -1,				NULL				}
};

static char options_change_page_strings[MAX_CHANGE_PAGES][10];
static struct ValueTextInfo options_change_page[MAX_CHANGE_PAGES + 1] =
{
  { -1,				NULL				}
};

static struct
{
  int x, y;
  int gadget_id;
  int gadget_id_align;
  int size;	/* char size of selectbox or '-1' (dynamically determined) */
  struct ValueTextInfo *options;
  int *value;
  char *text_left, *text_right, *infotext;
} selectbox_info[ED_NUM_SELECTBOX] =
{
  /* ---------- element settings: configure (custom elements) ------------- */

  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(1),
    GADGET_ID_CUSTOM_ACCESS_TYPE,	GADGET_ID_NONE,
    -1,
    options_access_type,
    &custom_element.access_type,
    "player can", NULL,			"type of access to this field"
  },
  {
    -1,					ED_SETTINGS_YPOS(1),
    GADGET_ID_CUSTOM_ACCESS_LAYER,	GADGET_ID_CUSTOM_ACCESS_TYPE,
    -1,
    options_access_layer,
    &custom_element.access_layer,
    NULL, NULL,				"layer of access for this field"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(2),
    GADGET_ID_CUSTOM_WALK_TO_ACTION,	GADGET_ID_NONE,
    -1,
    options_walk_to_action,
    &custom_element.walk_to_action,
    NULL, NULL,				"diggable/collectible/pushable"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(5),
    GADGET_ID_CUSTOM_MOVE_PATTERN,	GADGET_ID_NONE,
    -1,
    options_move_pattern,
    &custom_element.move_pattern,
    "can move", NULL,			"element move direction"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(6),
    GADGET_ID_CUSTOM_MOVE_DIRECTION,	GADGET_ID_NONE,
    -1,
    options_move_direction,
    &custom_element.move_direction_initial,
    "starts moving", NULL,		"initial element move direction"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(8),
    GADGET_ID_CUSTOM_MOVE_STEPSIZE,	GADGET_ID_NONE,
    -1,
    options_move_stepsize,
    &custom_element.move_stepsize,
    "move/fall speed", NULL,		"speed of element movement"
  },
  {
    -1,					ED_SETTINGS_YPOS(9),
    GADGET_ID_CUSTOM_SMASH_TARGETS,	GADGET_ID_CUSTOM_CAN_SMASH,
    -1,
    options_smash_targets,
    &custom_element.smash_targets,
    "can smash", NULL,			"elements that can be smashed"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(10),
    GADGET_ID_CUSTOM_SLIPPERY_TYPE,	GADGET_ID_NONE,
    -1,
    options_slippery_type,
    &custom_element.slippery_type,
    "slippery", NULL,			"where other elements fall down"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(11),
    GADGET_ID_CUSTOM_DEADLINESS,	GADGET_ID_NONE,
    -1,
    options_deadliness,
    &custom_element.deadliness,
    "deadly when", NULL,		"deadliness of element"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(12),
    GADGET_ID_CUSTOM_CONSISTENCY,	GADGET_ID_NONE,
    -1,
    options_consistency,
    &custom_element.consistency,
    NULL, NULL,				"consistency/destructibility"
  },

  /* ---------- element settings: advanced (custom elements) --------------- */

  {
    ED_SETTINGS_XPOS(2),		ED_SETTINGS_YPOS(4),
    GADGET_ID_CHANGE_TIME_UNITS,	GADGET_ID_NONE,
    -1,
    options_time_units,
    &custom_element_change.delay_frames,
    "delay time given in", NULL,	"delay time units for change"
  },
  {
    ED_SETTINGS_XPOS(2),		ED_SETTINGS_YPOS(5),
    GADGET_ID_CHANGE_DIRECT_ACTION,	GADGET_ID_NONE,
    -1,
    options_change_direct_action,
    &custom_element_change.direct_action,
    NULL, NULL,				"type of direct action"
  },
  {
    ED_SETTINGS_XPOS(2),		ED_SETTINGS_YPOS(6),
    GADGET_ID_CHANGE_OTHER_ACTION,	GADGET_ID_NONE,
    -1,
    options_change_other_action,
    &custom_element_change.other_action,
    NULL, "element:",			"type of other element action"
  },
  {
    ED_SETTINGS_XPOS(2),		ED_SETTINGS_YPOS(7),
    GADGET_ID_CHANGE_SIDES,		GADGET_ID_NONE,
    -1,
    options_change_sides,
    &custom_element_change.sides,
    "... at", NULL,			"element side that causes change"
  },
  {
    ED_SETTINGS_XPOS(2),		ED_SETTINGS_YPOS(10),
    GADGET_ID_CHANGE_POWER,		GADGET_ID_NONE,
    -1,
    options_change_power,
    &custom_element_change.power,
    "replace when", NULL,		"which elements can be replaced"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(14),
    GADGET_ID_SELECT_CHANGE_PAGE,	GADGET_ID_NONE,
    3,
    options_change_page,
    &custom_element.current_change_page,
    NULL, NULL,				"element config page"
  },
};

static struct
{
  int x, y;
  int gadget_id;
  int gadget_id_align;
  int size;
  char *text;
  char *text_left, *text_right, *infotext;
} textbutton_info[ED_NUM_TEXTBUTTONS] =
{
  {
    ED_SETTINGS_XPOS(0),		ED_COUNTER_YPOS(1),
    GADGET_ID_PROPERTIES_INFO,		GADGET_ID_NONE,
    11,					"Information",			
    NULL, NULL,				"Show information about element"
  },
  {
    ED_SETTINGS_XPOS(0) + 166,		ED_COUNTER_YPOS(1),
    GADGET_ID_PROPERTIES_CONFIG,	GADGET_ID_NONE,
    11,					"Configure",
    NULL, NULL,				"Configure element properties"
  },
  {
    ED_SETTINGS_XPOS(0) + 332,		ED_COUNTER_YPOS(1),
    GADGET_ID_PROPERTIES_ADVANCED,	GADGET_ID_NONE,
    11,					"Advanced",
    NULL, NULL,				"Advanced element configuration"
  },
  {
    -1,					ED_SETTINGS_YPOS(13),
    GADGET_ID_SAVE_AS_TEMPLATE,		GADGET_ID_CUSTOM_USE_TEMPLATE,
    -1,					"Save as template",
    " ", NULL,				"Save current settings as new template"
  },
  {
    -1,					ED_SETTINGS_YPOS(14),
    GADGET_ID_ADD_CHANGE_PAGE,		GADGET_ID_NEXT_CHANGE_PAGE,
    -1,					"New",
    " ", NULL,				"Add new config page"
  },
  {
    -1,					ED_SETTINGS_YPOS(14),
    GADGET_ID_DEL_CHANGE_PAGE,		GADGET_ID_ADD_CHANGE_PAGE,
    -1,					"Delete",
    NULL, NULL,				"Delete current config page"
  },
};

static struct
{
  int gd_x, gd_y;
  int x, y;
  int width, height;
  int gadget_id;
  int gadget_id_align;
  char *text_left, *text_right, *infotext;
} graphicbutton_info[ED_NUM_GRAPHICBUTTONS] =
{
  {
    ED_BUTTON_MINUS_XPOS,		ED_BUTTON_COUNT_YPOS,
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(14),
    ED_BUTTON_COUNT_XSIZE,		ED_BUTTON_COUNT_YSIZE,
    GADGET_ID_PREV_CHANGE_PAGE,		GADGET_ID_NONE,
    NULL, NULL,				"select previous config page"
  },
  {
    ED_BUTTON_PLUS_XPOS,		ED_BUTTON_COUNT_YPOS,
    -1,					ED_SETTINGS_YPOS(14),
    ED_BUTTON_COUNT_XSIZE,		ED_BUTTON_COUNT_YSIZE,
    GADGET_ID_NEXT_CHANGE_PAGE,		GADGET_ID_SELECT_CHANGE_PAGE,
    NULL, "config page",		"select next config page"
  },
};

static struct
{
  int gd_x, gd_y;
  int x, y;
  int gadget_id;
  char *infotext;
} scrollbutton_info[ED_NUM_SCROLLBUTTONS] =
{
  {
    ED_SCROLLBUTTON_XPOS,   ED_SCROLLBUTTON_YPOS + 0 * ED_SCROLLBUTTON_YSIZE,
    ED_SCROLL_UP_XPOS,      ED_SCROLL_UP_YPOS,
    GADGET_ID_SCROLL_UP,
    "scroll level editing area up"
  },
  {
    ED_SCROLLBUTTON_XPOS,   ED_SCROLLBUTTON_YPOS + 1 * ED_SCROLLBUTTON_YSIZE,
    ED_SCROLL_DOWN_XPOS,    ED_SCROLL_DOWN_YPOS,
    GADGET_ID_SCROLL_DOWN,
    "scroll level editing area down"
  },
  {
    ED_SCROLLBUTTON_XPOS,   ED_SCROLLBUTTON_YPOS + 2 * ED_SCROLLBUTTON_YSIZE,
    ED_SCROLL_LEFT_XPOS,    ED_SCROLL_LEFT_YPOS,
    GADGET_ID_SCROLL_LEFT,
    "scroll level editing area left"
  },
  {
    ED_SCROLLBUTTON_XPOS,   ED_SCROLLBUTTON_YPOS + 3 * ED_SCROLLBUTTON_YSIZE,
    ED_SCROLL_RIGHT_XPOS,   ED_SCROLL_RIGHT_YPOS,
    GADGET_ID_SCROLL_RIGHT,
    "scroll level editing area right"
  },
  {
    ED_SCROLLBUTTON2_XPOS,  ED_SCROLLBUTTON2_YPOS + 0 * ED_SCROLLBUTTON2_YSIZE,
    ED_SCROLL2_UP_XPOS,     ED_SCROLL2_UP_YPOS,
    GADGET_ID_SCROLL_LIST_UP,
    "scroll element list up ('Page Up')"
  },
  {
    ED_SCROLLBUTTON2_XPOS,  ED_SCROLLBUTTON2_YPOS + 1 * ED_SCROLLBUTTON2_YSIZE,
    ED_SCROLL2_DOWN_XPOS,   ED_SCROLL2_DOWN_YPOS,
    GADGET_ID_SCROLL_LIST_DOWN,
    "scroll element list down ('Page Down')"
  },
};

static struct
{
  int gd_x, gd_y;
  int x, y;
  int width, height;
  int type;
  int gadget_id;
  char *infotext;
} scrollbar_info[ED_NUM_SCROLLBARS] =
{
  {
    ED_SCROLLBAR_XPOS,			ED_SCROLLBAR_YPOS,
    SX + ED_SCROLL_HORIZONTAL_XPOS,	SY + ED_SCROLL_HORIZONTAL_YPOS,
    ED_SCROLL_HORIZONTAL_XSIZE,		ED_SCROLL_HORIZONTAL_YSIZE,
    GD_TYPE_SCROLLBAR_HORIZONTAL,
    GADGET_ID_SCROLL_HORIZONTAL,
    "scroll level editing area horizontally"
  },
  {
    ED_SCROLLBAR_XPOS,			ED_SCROLLBAR_YPOS,
    SX + ED_SCROLL_VERTICAL_XPOS,	SY + ED_SCROLL_VERTICAL_YPOS,
    ED_SCROLL_VERTICAL_XSIZE,		ED_SCROLL_VERTICAL_YSIZE,
    GD_TYPE_SCROLLBAR_VERTICAL,
    GADGET_ID_SCROLL_VERTICAL,
    "scroll level editing area vertically"
  },
  {
    ED_SCROLLBAR2_XPOS,			ED_SCROLLBAR2_YPOS,
    DX + ED_SCROLL2_VERTICAL_XPOS,	DY + ED_SCROLL2_VERTICAL_YPOS,
    ED_SCROLL2_VERTICAL_XSIZE,		ED_SCROLL2_VERTICAL_YSIZE,
    GD_TYPE_SCROLLBAR_VERTICAL,
    GADGET_ID_SCROLL_LIST_VERTICAL,
    "scroll element list vertically"
  }
};

static struct
{
  int x, y;
  int gadget_id;
  int gadget_id_align;
  int radio_button_nr;
  int *value;
  int checked_value;
  char *text_left, *text_right, *infotext;
} radiobutton_info[ED_NUM_RADIOBUTTONS] =
{
  {
    -1,					ED_COUNTER2_YPOS(8),
    GADGET_ID_RANDOM_PERCENTAGE,	GADGET_ID_LEVEL_RANDOM_UP,
    RADIO_NR_RANDOM_ELEMENTS,
    &random_placement_method,		RANDOM_USE_PERCENTAGE,
    " ", "percentage",			"use percentage for random elements"
  },
  {
    -1,					ED_COUNTER2_YPOS(8),
    GADGET_ID_RANDOM_QUANTITY,		GADGET_ID_RANDOM_PERCENTAGE,
    RADIO_NR_RANDOM_ELEMENTS,
    &random_placement_method,		RANDOM_USE_QUANTITY,
    " ", "quantity",			"use quantity for random elements"
  }
};

static struct
{
  int x, y;
  int gadget_id;
  int gadget_id_align;
  boolean *value;
  char *text_left, *text_right, *infotext;
} checkbutton_info[ED_NUM_CHECKBUTTONS] =
{
  /* ---------- level and editor settings ---------------------------------- */

  {
    ED_SETTINGS_XPOS(0),		ED_COUNTER_YPOS(6) - MINI_TILEY,
    GADGET_ID_DOUBLE_SPEED,		GADGET_ID_NONE,
    &level.double_speed,
    NULL, "double speed movement",	"set movement speed of player"
  },
  {
    -1,					ED_COUNTER_YPOS(6) - MINI_TILEY,
    GADGET_ID_GRAVITY,			GADGET_ID_DOUBLE_SPEED,
    &level.gravity,
    " ", "gravity",			"set level gravity"
  },
  {
    ED_SETTINGS_XPOS(0),		ED_COUNTER2_YPOS(9) - MINI_TILEY,
    GADGET_ID_RANDOM_RESTRICTED,	GADGET_ID_NONE,
    &random_placement_background_restricted,
    NULL,
    "restrict random placement to:",	"set random placement restriction"
  },

  /* ---------- element settings: configure (various elements) ------------- */

  {
    ED_SETTINGS_XPOS(0),		0,	/* set at runtime */
    GADGET_ID_STICK_ELEMENT,		GADGET_ID_NONE,
    &stick_element_properties_window,
    NULL,
    "stick this screen to edit content","stick this screen to edit content"
  },
  {
    ED_SETTINGS_XPOS(0),		ED_COUNTER_YPOS(4),
    GADGET_ID_EM_SLIPPERY_GEMS,		GADGET_ID_NONE,
    &level.em_slippery_gems,
    NULL,
    "slip down from certain flat walls","use EM style slipping behaviour"
  },

  /* ---------- element settings: configure (custom elements) ------------- */

  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(1),
    GADGET_ID_CUSTOM_ACCESSIBLE,	GADGET_ID_NONE,
    &custom_element_properties[EP_ACCESSIBLE],
    NULL, NULL,				"player can walk to or pass this field"
  },
  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(2),
    GADGET_ID_CUSTOM_WALK_TO_OBJECT,	GADGET_ID_NONE,
    &custom_element_properties[EP_WALK_TO_OBJECT],
    NULL, NULL,				"player can dig/collect/push element"
  },
  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(5),
    GADGET_ID_CUSTOM_CAN_MOVE,		GADGET_ID_NONE,
    &custom_element_properties[EP_CAN_MOVE],
    NULL, NULL,				"element can move in some direction"
  },
  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(9),
    GADGET_ID_CUSTOM_CAN_FALL,		GADGET_ID_NONE,
    &custom_element_properties[EP_CAN_FALL],
    NULL, "can fall",			"element can fall down"
  },
  {
    -1,					ED_SETTINGS_YPOS(9),
    GADGET_ID_CUSTOM_CAN_SMASH,		GADGET_ID_CUSTOM_CAN_FALL,
    &custom_element_properties[EP_CAN_SMASH],
    " ", NULL,				"element can smash other elements"
  },
  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(10),
    GADGET_ID_CUSTOM_SLIPPERY,		GADGET_ID_NONE,
    &custom_element_properties[EP_SLIPPERY],
    NULL, NULL,				"other elements can fall down from it"
  },
  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(11),
    GADGET_ID_CUSTOM_DEADLY,		GADGET_ID_NONE,
    &custom_element_properties[EP_DEADLY],
    NULL, NULL,				"element can kill the player"
  },
  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(12),
    GADGET_ID_CUSTOM_EXPLODE_RESULT,	GADGET_ID_NONE,
    &custom_element_properties[EP_EXPLODE_RESULT],
    NULL, NULL,				"set consistency/destructibility"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(13),
    GADGET_ID_CUSTOM_EXPLODE_FIRE,	GADGET_ID_NONE,
    &custom_element.can_explode_by_fire,
    NULL, "by fire",			"element can explode by fire/explosion"
  },
  {
    -1,					ED_SETTINGS_YPOS(13),
    GADGET_ID_CUSTOM_EXPLODE_SMASH,	GADGET_ID_CUSTOM_EXPLODE_FIRE,
    &custom_element.can_explode_smashed,
    " ", "smashed",			"element can explode when smashed"
  },
  {
    -1,					ED_SETTINGS_YPOS(13),
    GADGET_ID_CUSTOM_EXPLODE_IMPACT,	GADGET_ID_CUSTOM_EXPLODE_SMASH,
    &custom_element.can_explode_impact,
    " ", "impact",			"element can explode on impact"
  },

  /* ---------- element settings: advanced (custom elements) --------------- */

  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(1),
    GADGET_ID_CUSTOM_USE_GRAPHIC,	GADGET_ID_NONE,
    &custom_element.use_gfx_element,
    NULL, "use graphic of element:",	"use graphic for custom element"
  },
  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(2),
    GADGET_ID_CUSTOM_CAN_CHANGE,	GADGET_ID_NONE,
    &custom_element_change.can_change,
    NULL, "element changes to:",	"element can change to other element"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(3),
    GADGET_ID_CHANGE_DELAY,		GADGET_ID_NONE,
    &custom_element_change_events[CE_DELAY],
    NULL, NULL,				"element changes after delay"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(5),
    GADGET_ID_CHANGE_BY_DIRECT_ACT,	GADGET_ID_NONE,
    &custom_element_change_events[CE_BY_DIRECT_ACTION],
    NULL, NULL,				"element changes by direct action"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(6),
    GADGET_ID_CHANGE_BY_OTHER_ACT,	GADGET_ID_NONE,
    &custom_element_change_events[CE_BY_OTHER_ACTION],
    NULL, NULL,				"element changes by other element"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(8),
    GADGET_ID_CHANGE_USE_EXPLOSION,	GADGET_ID_NONE,
    &custom_element_change.explode,
    NULL, "explode instead of change",	"element explodes instead of change"
  },
  {
    ED_SETTINGS_XPOS(1),		ED_SETTINGS_YPOS(9),
    GADGET_ID_CHANGE_USE_CONTENT,	GADGET_ID_NONE,
    &custom_element_change.use_content,
    NULL, "use extended change target:","element changes to more elements"
  },
  {
    ED_SETTINGS_XPOS(2),		ED_SETTINGS_YPOS(11),
    GADGET_ID_CHANGE_ONLY_COMPLETE,	GADGET_ID_NONE,
    &custom_element_change.only_complete,
    NULL, "replace all or nothing",	"only replace when all can be changed"
  },
  {
    ED_SETTINGS_XPOS(2),		ED_SETTINGS_YPOS(12),
    GADGET_ID_CHANGE_USE_RANDOM,	GADGET_ID_NONE,
    &custom_element_change.use_random_change,
    NULL, NULL,				"use percentage for random replace"
  },
  {
    ED_SETTINGS_XPOS(0),		ED_SETTINGS_YPOS(13),
    GADGET_ID_CUSTOM_USE_TEMPLATE,	GADGET_ID_NONE,
    &level.use_custom_template,
    NULL, "use template",		"use template for custom properties"
  },
};

static struct
{
  int x, y;
  int area_xsize, area_ysize;
  int gadget_id;
  int gadget_id_align;
  char *text_left, *text_right, *text_below;
} drawingarea_info[ED_NUM_DRAWING_AREAS] =
{
  /* ---------- level playfield content ------------------------------------ */

  {
    0, 0,
    MAX_ED_FIELDX, MAX_ED_FIELDY,
    GADGET_ID_DRAWING_LEVEL,		GADGET_ID_NONE,
    NULL, NULL,				NULL
  },

  /* ---------- yam yam content -------------------------------------------- */

  {
    ED_AREA_YAMYAM_CONTENT_XPOS(0),	ED_AREA_YAMYAM_CONTENT_YPOS(0),
    3, 3,
    GADGET_ID_ELEMENT_CONTENT_0,	GADGET_ID_NONE,
    NULL, NULL,				"1"
  },
  {
    ED_AREA_YAMYAM_CONTENT_XPOS(1),	ED_AREA_YAMYAM_CONTENT_YPOS(1),
    3, 3,
    GADGET_ID_ELEMENT_CONTENT_1,	GADGET_ID_NONE,
    NULL, NULL,				"2"
  },
  {
    ED_AREA_YAMYAM_CONTENT_XPOS(2),	ED_AREA_YAMYAM_CONTENT_YPOS(2),
    3, 3,
    GADGET_ID_ELEMENT_CONTENT_2,	GADGET_ID_NONE,
    NULL, NULL,				"3"
  },
  {
    ED_AREA_YAMYAM_CONTENT_XPOS(3),	ED_AREA_YAMYAM_CONTENT_YPOS(3),
    3, 3,
    GADGET_ID_ELEMENT_CONTENT_3,	GADGET_ID_NONE,
    NULL, NULL,				"4"
  },
  {
    ED_AREA_YAMYAM_CONTENT_XPOS(4),	ED_AREA_YAMYAM_CONTENT_YPOS(4),
    3, 3,
    GADGET_ID_ELEMENT_CONTENT_4,	GADGET_ID_NONE,
    NULL, NULL,				"5"
  },
  {
    ED_AREA_YAMYAM_CONTENT_XPOS(5),	ED_AREA_YAMYAM_CONTENT_YPOS(5),
    3, 3,
    GADGET_ID_ELEMENT_CONTENT_5,	GADGET_ID_NONE,
    NULL, NULL,				"6"
  },
  {
    ED_AREA_YAMYAM_CONTENT_XPOS(6),	ED_AREA_YAMYAM_CONTENT_YPOS(6),
    3, 3,
    GADGET_ID_ELEMENT_CONTENT_6,	GADGET_ID_NONE,
    NULL, NULL,				"7"
  },
  {
    ED_AREA_YAMYAM_CONTENT_XPOS(7),	ED_AREA_YAMYAM_CONTENT_YPOS(7),
    3, 3,
    GADGET_ID_ELEMENT_CONTENT_7,	GADGET_ID_NONE,
    NULL, NULL,				"8"
  },

  /* ---------- amoeba content --------------------------------------------- */

  {
    ED_AREA_ELEM_CONTENT_XPOS,		ED_AREA_ELEM_CONTENT_YPOS,
    1, 1,
    GADGET_ID_AMOEBA_CONTENT,		GADGET_ID_NONE,
    NULL, "content of amoeba",		NULL
  },

  /* ---------- custom graphic --------------------------------------------- */

  {
    -1,					ED_AREA_ELEM_CONTENT3_YPOS,
    1, 1,
    GADGET_ID_CUSTOM_GRAPHIC,		GADGET_ID_CUSTOM_USE_GRAPHIC,
    NULL, NULL,				NULL
  },

  /* ---------- custom content (when exploding) ---------------------------- */

  {
    ED_AREA_ELEM_CONTENT4_XPOS,		ED_AREA_ELEM_CONTENT4_YPOS,
    3, 3,
    GADGET_ID_CUSTOM_CONTENT,		GADGET_ID_NONE,	/* align three rows */
    "content:", NULL,			NULL
  },

  /* ---------- custom change target --------------------------------------- */

  {
    -1,					ED_AREA_ELEM_CONTENT2_YPOS,
    1, 1,
    GADGET_ID_CUSTOM_CHANGE_TARGET,	GADGET_ID_CUSTOM_CAN_CHANGE,
    NULL, "after/when:",		NULL
  },

  /* ---------- custom change content (extended change target) ------------- */

  {
    ED_AREA_ELEM_CONTENT6_XPOS,		ED_AREA_ELEM_CONTENT6_YPOS,
    3, 3,
    GADGET_ID_CUSTOM_CHANGE_CONTENT,	GADGET_ID_NONE,	/* align three rows */
    NULL, NULL,				NULL
  },

  /* ---------- custom change trigger (element causing change) ------------- */

  {
    -1,					ED_AREA_ELEM_CONTENT5_YPOS,
    1, 1,
    GADGET_ID_CUSTOM_CHANGE_TRIGGER,	GADGET_ID_CHANGE_OTHER_ACTION,
    NULL, NULL,				NULL
  },

  /* ---------- random background (for random painting) -------------------- */

  {
    -1,					ED_AREA_RANDOM_BACKGROUND_YPOS,
    1, 1,
    GADGET_ID_RANDOM_BACKGROUND,	GADGET_ID_RANDOM_RESTRICTED,
    NULL, NULL,				NULL
  },
};


/*
  -----------------------------------------------------------------------------
  some internally used variables
  -----------------------------------------------------------------------------
*/

/* actual size of level editor drawing area */
static int ed_fieldx = MAX_ED_FIELDX - 1, ed_fieldy = MAX_ED_FIELDY - 1;

/* actual position of level editor drawing area in level playfield */
static int level_xpos = -1, level_ypos = -1;

#define IN_ED_FIELD(x,y)  ((x)>=0 && (x)<ed_fieldx && (y)>=0 &&(y)<ed_fieldy)

/* drawing elements on the three mouse buttons */
static int new_element1 = EL_WALL;
static int new_element2 = EL_EMPTY;
static int new_element3 = EL_SAND;

#define BUTTON_ELEMENT(button) ((button) == 1 ? new_element1 : \
				(button) == 2 ? new_element2 : \
				(button) == 3 ? new_element3 : EL_EMPTY)
#define BUTTON_STEPSIZE(button) ((button) == 1 ? 1 : (button) == 2 ? 5 : 10)

/* forward declaration for internal use */
static void ModifyEditorCounter(int, int);
static void ModifyEditorCounterLimits(int, int, int);
static void ModifyEditorSelectbox(int, int);
static void ModifyEditorElementList();
static void RedrawDrawingElements();
static void DrawDrawingWindow();
static void DrawLevelInfoWindow();
static void DrawPropertiesWindow();
static boolean checkPropertiesConfig();
static void CopyLevelToUndoBuffer(int);
static void HandleDrawingAreas(struct GadgetInfo *);
static void HandleCounterButtons(struct GadgetInfo *);
static void HandleTextInputGadgets(struct GadgetInfo *);
static void HandleTextAreaGadgets(struct GadgetInfo *);
static void HandleSelectboxGadgets(struct GadgetInfo *);
static void HandleTextbuttonGadgets(struct GadgetInfo *);
static void HandleGraphicbuttonGadgets(struct GadgetInfo *);
static void HandleRadiobuttons(struct GadgetInfo *);
static void HandleCheckbuttons(struct GadgetInfo *);
static void HandleControlButtons(struct GadgetInfo *);
static void HandleDrawingAreaInfo(struct GadgetInfo *);

static struct GadgetInfo *level_editor_gadget[NUM_EDITOR_GADGETS];
static int right_gadget_border[NUM_EDITOR_GADGETS];

static int drawing_function = GADGET_ID_SINGLE_ITEMS;
static int last_drawing_function = GADGET_ID_SINGLE_ITEMS;
static boolean draw_with_brush = FALSE;
static int properties_element = 0;

static short FieldBackup[MAX_LEV_FIELDX][MAX_LEV_FIELDY];
static short UndoBuffer[NUM_UNDO_STEPS][MAX_LEV_FIELDX][MAX_LEV_FIELDY];
static int undo_buffer_position = 0;
static int undo_buffer_steps = 0;

static int edit_mode;
static int edit_mode_properties;

static int element_shift = 0;

static int editor_hl_boulderdash[] =
{
  EL_CHAR('B'),
  EL_CHAR('O'),
  EL_CHAR('U'),
  EL_CHAR('L'),

  EL_CHAR('-'),
  EL_CHAR('D'),
  EL_CHAR('E'),
  EL_CHAR('R'),

  EL_CHAR('D'),
  EL_CHAR('A'),
  EL_CHAR('S'),
  EL_CHAR('H'),
};

static int editor_el_boulderdash[] =
{
  EL_PLAYER_1,
  EL_EMPTY,
  EL_SAND,
  EL_STEELWALL,

  EL_BD_WALL,
  EL_BD_MAGIC_WALL,
  EL_EXIT_CLOSED,
  EL_EXIT_OPEN,

  EL_BD_DIAMOND,
  EL_BD_BUTTERFLY_UP,
  EL_BD_FIREFLY_UP,
  EL_BD_ROCK,

  EL_BD_BUTTERFLY_LEFT,
  EL_BD_FIREFLY_LEFT,
  EL_BD_BUTTERFLY_RIGHT,
  EL_BD_FIREFLY_RIGHT,

  EL_BD_AMOEBA,
  EL_BD_BUTTERFLY_DOWN,
  EL_BD_FIREFLY_DOWN,
  EL_EMPTY,
};
static int num_editor_hl_boulderdash = SIZEOF_ARRAY_INT(editor_hl_boulderdash);
static int num_editor_el_boulderdash = SIZEOF_ARRAY_INT(editor_el_boulderdash);

static int editor_hl_emerald_mine[] =
{
  EL_CHAR('E'),
  EL_CHAR('M'),
  EL_CHAR('E'),
  EL_CHAR('-'),

  EL_CHAR('R'),
  EL_CHAR('A'),
  EL_CHAR('L'),
  EL_CHAR('D'),

  EL_CHAR('M'),
  EL_CHAR('I'),
  EL_CHAR('N'),
  EL_CHAR('E'),
};

static int editor_el_emerald_mine[] =
{
  EL_PLAYER_1,
  EL_PLAYER_2,
  EL_PLAYER_3,
  EL_PLAYER_4,

  EL_PLAYER_1,
  EL_EMPTY,
  EL_SAND,
  EL_ROCK,

  EL_STEELWALL,
  EL_WALL,
  EL_WALL_SLIPPERY,
  EL_MAGIC_WALL,

  EL_EMERALD,
  EL_DIAMOND,
  EL_NUT,
  EL_BOMB,

  EL_WALL_EMERALD,
  EL_WALL_DIAMOND,
  EL_QUICKSAND_EMPTY,
  EL_QUICKSAND_FULL,

  EL_DYNAMITE,
  EL_DYNAMITE_ACTIVE,
  EL_EXIT_CLOSED,
  EL_EXIT_OPEN,

  EL_YAMYAM,
  EL_BUG_UP,
  EL_SPACESHIP_UP,
  EL_ROBOT,

  EL_BUG_LEFT,
  EL_SPACESHIP_LEFT,
  EL_BUG_RIGHT,
  EL_SPACESHIP_RIGHT,

  EL_ROBOT_WHEEL,
  EL_BUG_DOWN,
  EL_SPACESHIP_DOWN,
  EL_INVISIBLE_WALL,

  EL_ACID_POOL_TOPLEFT,
  EL_ACID,
  EL_ACID_POOL_TOPRIGHT,
  EL_EMPTY,

  EL_ACID_POOL_BOTTOMLEFT,
  EL_ACID_POOL_BOTTOM,
  EL_ACID_POOL_BOTTOMRIGHT,
  EL_EMPTY,

  EL_AMOEBA_DROP,
  EL_AMOEBA_DEAD,
  EL_AMOEBA_WET,
  EL_AMOEBA_DRY,

#if 1
  EL_EM_KEY_1,
  EL_EM_KEY_2,
  EL_EM_KEY_3,
  EL_EM_KEY_4,
#else
  EL_EM_KEY_1_FILE,
  EL_EM_KEY_2_FILE,
  EL_EM_KEY_3_FILE,
  EL_EM_KEY_4_FILE,
#endif

  EL_EM_GATE_1,
  EL_EM_GATE_2,
  EL_EM_GATE_3,
  EL_EM_GATE_4,

  EL_EM_GATE_1_GRAY,
  EL_EM_GATE_2_GRAY,
  EL_EM_GATE_3_GRAY,
  EL_EM_GATE_4_GRAY,
};
static int num_editor_hl_emerald_mine=SIZEOF_ARRAY_INT(editor_hl_emerald_mine);
static int num_editor_el_emerald_mine=SIZEOF_ARRAY_INT(editor_el_emerald_mine);

static int editor_hl_more[] =
{
  EL_CHAR('M'),
  EL_CHAR('O'),
  EL_CHAR('R'),
  EL_CHAR('E'),
};

static int editor_el_more[] =
{
  EL_KEY_1,
  EL_KEY_2,
  EL_KEY_3,
  EL_KEY_4,

  EL_GATE_1,
  EL_GATE_2,
  EL_GATE_3,
  EL_GATE_4,

  EL_GATE_1_GRAY,
  EL_GATE_2_GRAY,
  EL_GATE_3_GRAY,
  EL_GATE_4_GRAY,

  EL_ARROW_LEFT,
  EL_ARROW_RIGHT,
  EL_ARROW_UP,
  EL_ARROW_DOWN,

  EL_AMOEBA_FULL,
  EL_EMERALD_YELLOW,
  EL_EMERALD_RED,
  EL_EMERALD_PURPLE,

  EL_WALL_BD_DIAMOND,
  EL_WALL_EMERALD_YELLOW,
  EL_WALL_EMERALD_RED,
  EL_WALL_EMERALD_PURPLE,

  EL_GAME_OF_LIFE,
  EL_PACMAN_UP,
  EL_TIME_ORB_FULL,
  EL_TIME_ORB_EMPTY,

  EL_PACMAN_LEFT,
  EL_DARK_YAMYAM,
  EL_PACMAN_RIGHT,
  EL_EXPANDABLE_WALL,

  EL_BIOMAZE,
  EL_PACMAN_DOWN,
  EL_LAMP,
  EL_LAMP_ACTIVE,

  EL_DYNABOMB_INCREASE_NUMBER,
  EL_DYNABOMB_INCREASE_SIZE,
  EL_DYNABOMB_INCREASE_POWER,
  EL_STONEBLOCK,

  EL_MOLE,
  EL_PENGUIN,
  EL_PIG,
  EL_DRAGON,

  EL_BUG,
  EL_MOLE_UP,
  EL_BD_BUTTERFLY,
  EL_BD_FIREFLY,

  EL_MOLE_LEFT,
  EL_EMPTY,
  EL_MOLE_RIGHT,
  EL_PACMAN,

  EL_SPACESHIP,
  EL_MOLE_DOWN,
  EL_BALLOON,
  EL_BALLOON_SWITCH_ANY,

  EL_BALLOON_SWITCH_LEFT,
  EL_BALLOON_SWITCH_RIGHT,
  EL_BALLOON_SWITCH_UP,
  EL_BALLOON_SWITCH_DOWN,

  EL_SATELLITE,
  EL_EXPANDABLE_WALL_HORIZONTAL,
  EL_EXPANDABLE_WALL_VERTICAL,
  EL_EXPANDABLE_WALL_ANY,

  EL_INVISIBLE_STEELWALL,
  EL_INVISIBLE_WALL,
  EL_SPEED_PILL,
  EL_BLACK_ORB,

  EL_EMC_STEELWALL_1,
  EL_EMC_WALL_1,
  EL_EMC_WALL_2,
  EL_EMC_WALL_3,

  EL_EMC_WALL_4,
  EL_EMC_WALL_5,
  EL_EMC_WALL_6,
  EL_EMC_WALL_7,
};
static int num_editor_hl_more = SIZEOF_ARRAY_INT(editor_hl_more);
static int num_editor_el_more = SIZEOF_ARRAY_INT(editor_el_more);

static int editor_hl_sokoban[] =
{
  EL_CHAR('S'),
  EL_CHAR('O'),
  EL_CHAR('K'),
  EL_CHAR('O'),

  EL_CHAR('-'),
  EL_CHAR('B'),
  EL_CHAR('A'),
  EL_CHAR('N'),
};

static int editor_el_sokoban[] =
{
  EL_SOKOBAN_OBJECT,
  EL_SOKOBAN_FIELD_EMPTY,
  EL_SOKOBAN_FIELD_FULL,
  EL_STEELWALL,
};
static int num_editor_hl_sokoban = SIZEOF_ARRAY_INT(editor_hl_sokoban);
static int num_editor_el_sokoban = SIZEOF_ARRAY_INT(editor_el_sokoban);

static int editor_hl_supaplex[] =
{
  EL_CHAR('S'),
  EL_CHAR('U'),
  EL_CHAR('P'),
  EL_CHAR('A'),

  EL_CHAR('P'),
  EL_CHAR('L'),
  EL_CHAR('E'),
  EL_CHAR('X'),
};

static int editor_el_supaplex[] =
{
#if 1
  EL_EMPTY,
#else
  EL_SP_EMPTY,
#endif
  EL_SP_ZONK,
  EL_SP_BASE,
  EL_SP_MURPHY,

  EL_SP_INFOTRON,
  EL_SP_CHIP_SINGLE,
  EL_SP_HARDWARE_GRAY,
  EL_SP_EXIT_CLOSED,

  EL_SP_DISK_ORANGE,
  EL_SP_PORT_RIGHT,
  EL_SP_PORT_DOWN,
  EL_SP_PORT_LEFT,

  EL_SP_PORT_UP,
  EL_SP_GRAVITY_PORT_RIGHT,
  EL_SP_GRAVITY_PORT_DOWN,
  EL_SP_GRAVITY_PORT_LEFT,

  EL_SP_GRAVITY_PORT_UP,
  EL_SP_SNIKSNAK,
  EL_SP_DISK_YELLOW,
  EL_SP_TERMINAL,

  EL_SP_DISK_RED,
  EL_SP_PORT_VERTICAL,
  EL_SP_PORT_HORIZONTAL,
  EL_SP_PORT_ANY,

  EL_SP_ELECTRON,
  EL_SP_BUGGY_BASE,
  EL_SP_CHIP_LEFT,
  EL_SP_CHIP_RIGHT,

  EL_SP_HARDWARE_BASE_1,
  EL_SP_HARDWARE_GREEN,
  EL_SP_HARDWARE_BLUE,
  EL_SP_HARDWARE_RED,

  EL_SP_HARDWARE_YELLOW,
  EL_SP_HARDWARE_BASE_2,
  EL_SP_HARDWARE_BASE_3,
  EL_SP_HARDWARE_BASE_4,

  EL_SP_HARDWARE_BASE_5,
  EL_SP_HARDWARE_BASE_6,
  EL_SP_CHIP_TOP,
  EL_SP_CHIP_BOTTOM,
};
static int num_editor_hl_supaplex = SIZEOF_ARRAY_INT(editor_hl_supaplex);
static int num_editor_el_supaplex = SIZEOF_ARRAY_INT(editor_el_supaplex);

static int editor_hl_diamond_caves[] =
{
  EL_CHAR('D'),
  EL_CHAR('I'),
  EL_CHAR('A'),
  EL_CHAR('-'),

  EL_CHAR('M'),
  EL_CHAR('O'),
  EL_CHAR('N'),
  EL_CHAR('D'),

  EL_CHAR('C'),
  EL_CHAR('A'),
  EL_CHAR('V'),
  EL_CHAR('E'),

  EL_CHAR('S'),
  EL_CHAR(' '),
  EL_CHAR('I'),
  EL_CHAR('I'),
};

static int editor_el_diamond_caves[] =
{
  EL_PEARL,
  EL_CRYSTAL,
  EL_WALL_PEARL,
  EL_WALL_CRYSTAL,

  EL_CONVEYOR_BELT_1_LEFT,
  EL_CONVEYOR_BELT_1_MIDDLE,
  EL_CONVEYOR_BELT_1_RIGHT,
  EL_CONVEYOR_BELT_1_SWITCH_MIDDLE,

  EL_CONVEYOR_BELT_2_LEFT,
  EL_CONVEYOR_BELT_2_MIDDLE,
  EL_CONVEYOR_BELT_2_RIGHT,
  EL_CONVEYOR_BELT_2_SWITCH_MIDDLE,

  EL_CONVEYOR_BELT_3_LEFT,
  EL_CONVEYOR_BELT_3_MIDDLE,
  EL_CONVEYOR_BELT_3_RIGHT,
  EL_CONVEYOR_BELT_3_SWITCH_MIDDLE,

  EL_CONVEYOR_BELT_4_LEFT,
  EL_CONVEYOR_BELT_4_MIDDLE,
  EL_CONVEYOR_BELT_4_RIGHT,
  EL_CONVEYOR_BELT_4_SWITCH_MIDDLE,

  EL_CONVEYOR_BELT_1_SWITCH_LEFT,
  EL_CONVEYOR_BELT_2_SWITCH_LEFT,
  EL_CONVEYOR_BELT_3_SWITCH_LEFT,
  EL_CONVEYOR_BELT_4_SWITCH_LEFT,

  EL_CONVEYOR_BELT_1_SWITCH_RIGHT,
  EL_CONVEYOR_BELT_2_SWITCH_RIGHT,
  EL_CONVEYOR_BELT_3_SWITCH_RIGHT,
  EL_CONVEYOR_BELT_4_SWITCH_RIGHT,

  EL_SWITCHGATE_OPEN,
  EL_SWITCHGATE_CLOSED,
  EL_SWITCHGATE_SWITCH_UP,
  EL_EMPTY,

  EL_ENVELOPE_1,
  EL_ENVELOPE_2,
  EL_ENVELOPE_3,
  EL_ENVELOPE_4,

  EL_TIMEGATE_CLOSED,
  EL_TIMEGATE_OPEN,
  EL_TIMEGATE_SWITCH,
  EL_EMPTY,

  EL_LANDMINE,
  EL_INVISIBLE_SAND,
  EL_STEELWALL_SLIPPERY,
  EL_EMPTY,

  EL_SIGN_EXCLAMATION,
  EL_SIGN_STOP,
  EL_LIGHT_SWITCH,
  EL_LIGHT_SWITCH_ACTIVE,

  EL_SHIELD_NORMAL,
  EL_SHIELD_DEADLY,
  EL_EXTRA_TIME,
  EL_EMPTY,
};
static int num_editor_hl_diamond_caves = SIZEOF_ARRAY_INT(editor_hl_diamond_caves);
static int num_editor_el_diamond_caves = SIZEOF_ARRAY_INT(editor_el_diamond_caves);

static int editor_hl_dx_boulderdash[] =
{
  EL_CHAR('D'),
  EL_CHAR('X'),
  EL_CHAR('-'),
  EL_CHAR(' '),

  EL_CHAR('B'),
  EL_CHAR('O'),
  EL_CHAR('U'),
  EL_CHAR('L'),

  EL_CHAR('-'),
  EL_CHAR('D'),
  EL_CHAR('E'),
  EL_CHAR('R'),

  EL_CHAR('D'),
  EL_CHAR('A'),
  EL_CHAR('S'),
  EL_CHAR('H'),
};

static int editor_el_dx_boulderdash[] =
{
  EL_SPRING,
  EL_TUBE_RIGHT_DOWN,
  EL_TUBE_HORIZONTAL_DOWN,
  EL_TUBE_LEFT_DOWN,

  EL_TUBE_HORIZONTAL,
  EL_TUBE_VERTICAL_RIGHT,
  EL_TUBE_ANY,
  EL_TUBE_VERTICAL_LEFT,

  EL_TUBE_VERTICAL,
  EL_TUBE_RIGHT_UP,
  EL_TUBE_HORIZONTAL_UP,
  EL_TUBE_LEFT_UP,

  EL_TRAP,
  EL_DX_SUPABOMB,
  EL_EMPTY,
  EL_EMPTY
};
static int num_editor_hl_dx_boulderdash = SIZEOF_ARRAY_INT(editor_hl_dx_boulderdash);
static int num_editor_el_dx_boulderdash = SIZEOF_ARRAY_INT(editor_el_dx_boulderdash);

static int editor_hl_chars[] =
{
  EL_CHAR('T'),
  EL_CHAR('E'),
  EL_CHAR('X'),
  EL_CHAR('T'),
};

static int editor_el_chars[] =
{
  EL_CHAR(' '),
  EL_CHAR('!'),
  EL_CHAR('"'),
  EL_CHAR('#'),

  EL_CHAR('$'),
  EL_CHAR('%'),
  EL_CHAR('&'),
  EL_CHAR('\''),

  EL_CHAR('('),
  EL_CHAR(')'),
  EL_CHAR('*'),
  EL_CHAR('+'),

  EL_CHAR(','),
  EL_CHAR('-'),
  EL_CHAR('.'),
  EL_CHAR('/'),

  EL_CHAR('0'),
  EL_CHAR('1'),
  EL_CHAR('2'),
  EL_CHAR('3'),

  EL_CHAR('4'),
  EL_CHAR('5'),
  EL_CHAR('6'),
  EL_CHAR('7'),

  EL_CHAR('8'),
  EL_CHAR('9'),
  EL_CHAR(':'),
  EL_CHAR(';'),

  EL_CHAR('<'),
  EL_CHAR('='),
  EL_CHAR('>'),
  EL_CHAR('?'),

  EL_CHAR('@'),
  EL_CHAR('A'),
  EL_CHAR('B'),
  EL_CHAR('C'),

  EL_CHAR('D'),
  EL_CHAR('E'),
  EL_CHAR('F'),
  EL_CHAR('G'),

  EL_CHAR('H'),
  EL_CHAR('I'),
  EL_CHAR('J'),
  EL_CHAR('K'),

  EL_CHAR('L'),
  EL_CHAR('M'),
  EL_CHAR('N'),
  EL_CHAR('O'),

  EL_CHAR('P'),
  EL_CHAR('Q'),
  EL_CHAR('R'),
  EL_CHAR('S'),

  EL_CHAR('T'),
  EL_CHAR('U'),
  EL_CHAR('V'),
  EL_CHAR('W'),

  EL_CHAR('X'),
  EL_CHAR('Y'),
  EL_CHAR('Z'),
  EL_CHAR('['),

  EL_CHAR('\\'),
  EL_CHAR(']'),
  EL_CHAR('^'),
  EL_CHAR('_'),

  EL_CHAR(''),
  EL_CHAR(''),
  EL_CHAR(''),
  EL_CHAR(''),

  EL_CHAR(''),
  EL_CHAR(''),
  EL_CHAR(FONT_ASCII_CURSOR),
  EL_CHAR(' ')
};
static int num_editor_hl_chars = SIZEOF_ARRAY_INT(editor_hl_chars);
static int num_editor_el_chars = SIZEOF_ARRAY_INT(editor_el_chars);

static int editor_hl_custom[] =
{
  EL_CHAR('C'),
  EL_CHAR('U'),
  EL_CHAR('S'),
  EL_CHAR('-'),

  EL_CHAR('T'),
  EL_CHAR('O'),
  EL_CHAR('M'),
  EL_CHAR(' '),

  EL_CHAR('E'),
  EL_CHAR('L'),
  EL_CHAR('E'),
  EL_CHAR('M'),

  EL_CHAR('E'),
  EL_CHAR('N'),
  EL_CHAR('T'),
  EL_CHAR('S'),
};

static int editor_el_custom[] =
{
  EL_CUSTOM_START + 0,
  EL_CUSTOM_START + 1,
  EL_CUSTOM_START + 2,
  EL_CUSTOM_START + 3,

  EL_CUSTOM_START + 4,
  EL_CUSTOM_START + 5,
  EL_CUSTOM_START + 6,
  EL_CUSTOM_START + 7,

  EL_CUSTOM_START + 8,
  EL_CUSTOM_START + 9,
  EL_CUSTOM_START + 10,
  EL_CUSTOM_START + 11,

  EL_CUSTOM_START + 12,
  EL_CUSTOM_START + 13,
  EL_CUSTOM_START + 14,
  EL_CUSTOM_START + 15,

  EL_CUSTOM_START + 16,
  EL_CUSTOM_START + 17,
  EL_CUSTOM_START + 18,
  EL_CUSTOM_START + 19,

  EL_CUSTOM_START + 20,
  EL_CUSTOM_START + 21,
  EL_CUSTOM_START + 22,
  EL_CUSTOM_START + 23,

  EL_CUSTOM_START + 24,
  EL_CUSTOM_START + 25,
  EL_CUSTOM_START + 26,
  EL_CUSTOM_START + 27,

  EL_CUSTOM_START + 28,
  EL_CUSTOM_START + 29,
  EL_CUSTOM_START + 30,
  EL_CUSTOM_START + 31,

  EL_CUSTOM_START + 32,
  EL_CUSTOM_START + 33,
  EL_CUSTOM_START + 34,
  EL_CUSTOM_START + 35,

  EL_CUSTOM_START + 36,
  EL_CUSTOM_START + 37,
  EL_CUSTOM_START + 38,
  EL_CUSTOM_START + 39,

  EL_CUSTOM_START + 40,
  EL_CUSTOM_START + 41,
  EL_CUSTOM_START + 42,
  EL_CUSTOM_START + 43,

  EL_CUSTOM_START + 44,
  EL_CUSTOM_START + 45,
  EL_CUSTOM_START + 46,
  EL_CUSTOM_START + 47,

  EL_CUSTOM_START + 48,
  EL_CUSTOM_START + 49,
  EL_CUSTOM_START + 50,
  EL_CUSTOM_START + 51,

  EL_CUSTOM_START + 52,
  EL_CUSTOM_START + 53,
  EL_CUSTOM_START + 54,
  EL_CUSTOM_START + 55,

  EL_CUSTOM_START + 56,
  EL_CUSTOM_START + 57,
  EL_CUSTOM_START + 58,
  EL_CUSTOM_START + 59,

  EL_CUSTOM_START + 60,
  EL_CUSTOM_START + 61,
  EL_CUSTOM_START + 62,
  EL_CUSTOM_START + 63,

  EL_CUSTOM_START + 64,
  EL_CUSTOM_START + 65,
  EL_CUSTOM_START + 66,
  EL_CUSTOM_START + 67,

  EL_CUSTOM_START + 68,
  EL_CUSTOM_START + 69,
  EL_CUSTOM_START + 70,
  EL_CUSTOM_START + 71,

  EL_CUSTOM_START + 72,
  EL_CUSTOM_START + 73,
  EL_CUSTOM_START + 74,
  EL_CUSTOM_START + 75,

  EL_CUSTOM_START + 76,
  EL_CUSTOM_START + 77,
  EL_CUSTOM_START + 78,
  EL_CUSTOM_START + 79,

  EL_CUSTOM_START + 80,
  EL_CUSTOM_START + 81,
  EL_CUSTOM_START + 82,
  EL_CUSTOM_START + 83,

  EL_CUSTOM_START + 84,
  EL_CUSTOM_START + 85,
  EL_CUSTOM_START + 86,
  EL_CUSTOM_START + 87,

  EL_CUSTOM_START + 88,
  EL_CUSTOM_START + 89,
  EL_CUSTOM_START + 90,
  EL_CUSTOM_START + 91,

  EL_CUSTOM_START + 92,
  EL_CUSTOM_START + 93,
  EL_CUSTOM_START + 94,
  EL_CUSTOM_START + 95,

  EL_CUSTOM_START + 96,
  EL_CUSTOM_START + 97,
  EL_CUSTOM_START + 98,
  EL_CUSTOM_START + 99,

  EL_CUSTOM_START + 100,
  EL_CUSTOM_START + 101,
  EL_CUSTOM_START + 102,
  EL_CUSTOM_START + 103,

  EL_CUSTOM_START + 104,
  EL_CUSTOM_START + 105,
  EL_CUSTOM_START + 106,
  EL_CUSTOM_START + 107,

  EL_CUSTOM_START + 108,
  EL_CUSTOM_START + 109,
  EL_CUSTOM_START + 110,
  EL_CUSTOM_START + 111,

  EL_CUSTOM_START + 112,
  EL_CUSTOM_START + 113,
  EL_CUSTOM_START + 114,
  EL_CUSTOM_START + 115,

  EL_CUSTOM_START + 116,
  EL_CUSTOM_START + 117,
  EL_CUSTOM_START + 118,
  EL_CUSTOM_START + 119,

  EL_CUSTOM_START + 120,
  EL_CUSTOM_START + 121,
  EL_CUSTOM_START + 122,
  EL_CUSTOM_START + 123,

  EL_CUSTOM_START + 124,
  EL_CUSTOM_START + 125,
  EL_CUSTOM_START + 126,
  EL_CUSTOM_START + 127
};
static int num_editor_hl_custom = SIZEOF_ARRAY_INT(editor_hl_custom);
static int num_editor_el_custom = SIZEOF_ARRAY_INT(editor_el_custom);

static int editor_hl_custom_more[] =
{
};

static int editor_el_custom_more[] =
{
  EL_CUSTOM_START + 128,
  EL_CUSTOM_START + 129,
  EL_CUSTOM_START + 130,
  EL_CUSTOM_START + 131,

  EL_CUSTOM_START + 132,
  EL_CUSTOM_START + 133,
  EL_CUSTOM_START + 134,
  EL_CUSTOM_START + 135,

  EL_CUSTOM_START + 136,
  EL_CUSTOM_START + 137,
  EL_CUSTOM_START + 138,
  EL_CUSTOM_START + 139,

  EL_CUSTOM_START + 140,
  EL_CUSTOM_START + 141,
  EL_CUSTOM_START + 142,
  EL_CUSTOM_START + 143,

  EL_CUSTOM_START + 144,
  EL_CUSTOM_START + 145,
  EL_CUSTOM_START + 146,
  EL_CUSTOM_START + 147,

  EL_CUSTOM_START + 148,
  EL_CUSTOM_START + 149,
  EL_CUSTOM_START + 150,
  EL_CUSTOM_START + 151,

  EL_CUSTOM_START + 152,
  EL_CUSTOM_START + 153,
  EL_CUSTOM_START + 154,
  EL_CUSTOM_START + 155,

  EL_CUSTOM_START + 156,
  EL_CUSTOM_START + 157,
  EL_CUSTOM_START + 158,
  EL_CUSTOM_START + 159,

  EL_CUSTOM_START + 160,
  EL_CUSTOM_START + 161,
  EL_CUSTOM_START + 162,
  EL_CUSTOM_START + 163,

  EL_CUSTOM_START + 164,
  EL_CUSTOM_START + 165,
  EL_CUSTOM_START + 166,
  EL_CUSTOM_START + 167,

  EL_CUSTOM_START + 168,
  EL_CUSTOM_START + 169,
  EL_CUSTOM_START + 170,
  EL_CUSTOM_START + 171,

  EL_CUSTOM_START + 172,
  EL_CUSTOM_START + 173,
  EL_CUSTOM_START + 174,
  EL_CUSTOM_START + 175,

  EL_CUSTOM_START + 176,
  EL_CUSTOM_START + 177,
  EL_CUSTOM_START + 178,
  EL_CUSTOM_START + 179,

  EL_CUSTOM_START + 180,
  EL_CUSTOM_START + 181,
  EL_CUSTOM_START + 182,
  EL_CUSTOM_START + 183,

  EL_CUSTOM_START + 184,
  EL_CUSTOM_START + 185,
  EL_CUSTOM_START + 186,
  EL_CUSTOM_START + 187,

  EL_CUSTOM_START + 188,
  EL_CUSTOM_START + 189,
  EL_CUSTOM_START + 190,
  EL_CUSTOM_START + 191,

  EL_CUSTOM_START + 192,
  EL_CUSTOM_START + 193,
  EL_CUSTOM_START + 194,
  EL_CUSTOM_START + 195,

  EL_CUSTOM_START + 196,
  EL_CUSTOM_START + 197,
  EL_CUSTOM_START + 198,
  EL_CUSTOM_START + 199,

  EL_CUSTOM_START + 200,
  EL_CUSTOM_START + 201,
  EL_CUSTOM_START + 202,
  EL_CUSTOM_START + 203,

  EL_CUSTOM_START + 204,
  EL_CUSTOM_START + 205,
  EL_CUSTOM_START + 206,
  EL_CUSTOM_START + 207,

  EL_CUSTOM_START + 208,
  EL_CUSTOM_START + 209,
  EL_CUSTOM_START + 210,
  EL_CUSTOM_START + 211,

  EL_CUSTOM_START + 212,
  EL_CUSTOM_START + 213,
  EL_CUSTOM_START + 214,
  EL_CUSTOM_START + 215,

  EL_CUSTOM_START + 216,
  EL_CUSTOM_START + 217,
  EL_CUSTOM_START + 218,
  EL_CUSTOM_START + 219,

  EL_CUSTOM_START + 220,
  EL_CUSTOM_START + 221,
  EL_CUSTOM_START + 222,
  EL_CUSTOM_START + 223,

  EL_CUSTOM_START + 224,
  EL_CUSTOM_START + 225,
  EL_CUSTOM_START + 226,
  EL_CUSTOM_START + 227,

  EL_CUSTOM_START + 228,
  EL_CUSTOM_START + 229,
  EL_CUSTOM_START + 230,
  EL_CUSTOM_START + 231,

  EL_CUSTOM_START + 232,
  EL_CUSTOM_START + 233,
  EL_CUSTOM_START + 234,
  EL_CUSTOM_START + 235,

  EL_CUSTOM_START + 236,
  EL_CUSTOM_START + 237,
  EL_CUSTOM_START + 238,
  EL_CUSTOM_START + 239,

  EL_CUSTOM_START + 240,
  EL_CUSTOM_START + 241,
  EL_CUSTOM_START + 242,
  EL_CUSTOM_START + 243,

  EL_CUSTOM_START + 244,
  EL_CUSTOM_START + 245,
  EL_CUSTOM_START + 246,
  EL_CUSTOM_START + 247,

  EL_CUSTOM_START + 248,
  EL_CUSTOM_START + 249,
  EL_CUSTOM_START + 250,
  EL_CUSTOM_START + 251,

  EL_CUSTOM_START + 252,
  EL_CUSTOM_START + 253,
  EL_CUSTOM_START + 254,
  EL_CUSTOM_START + 255
};
static int num_editor_hl_custom_more = SIZEOF_ARRAY_INT(editor_hl_custom_more);
static int num_editor_el_custom_more = SIZEOF_ARRAY_INT(editor_el_custom_more);

static int *editor_elements = NULL;	/* dynamically allocated */
static int num_editor_elements = 0;	/* dynamically determined */

static struct
{
  boolean *setup_value;

  int *headline_list;
  int *headline_list_size;

  int *element_list;
  int *element_list_size;

  boolean last_setup_value;
}
editor_elements_info[] =
{
  {
    &setup.editor.el_boulderdash,
    editor_hl_boulderdash,		&num_editor_hl_boulderdash,
    editor_el_boulderdash,		&num_editor_el_boulderdash
  },
  {
    &setup.editor.el_emerald_mine,
    editor_hl_emerald_mine,		&num_editor_hl_emerald_mine,
    editor_el_emerald_mine,		&num_editor_el_emerald_mine
  },
  {
    &setup.editor.el_more,
    editor_hl_more,			&num_editor_hl_more,
    editor_el_more,			&num_editor_el_more
  },
  {
    &setup.editor.el_sokoban,
    editor_hl_sokoban,			&num_editor_hl_sokoban,
    editor_el_sokoban,			&num_editor_el_sokoban
  },
  {
    &setup.editor.el_supaplex,
    editor_hl_supaplex,			&num_editor_hl_supaplex,
    editor_el_supaplex,			&num_editor_el_supaplex
  },
  {
    &setup.editor.el_diamond_caves,
    editor_hl_diamond_caves,		&num_editor_hl_diamond_caves,
    editor_el_diamond_caves,		&num_editor_el_diamond_caves
  },
  {
    &setup.editor.el_dx_boulderdash,
    editor_hl_dx_boulderdash,		&num_editor_hl_dx_boulderdash,
    editor_el_dx_boulderdash,		&num_editor_el_dx_boulderdash
  },
  {
    &setup.editor.el_chars,
    editor_hl_chars,			&num_editor_hl_chars,
    editor_el_chars,			&num_editor_el_chars
  },
  {
    &setup.editor.el_custom,
    editor_hl_custom,			&num_editor_hl_custom,
    editor_el_custom,			&num_editor_el_custom
  },
  {
    &setup.editor.el_custom_more,
    editor_hl_custom_more,		&num_editor_hl_custom_more,
    editor_el_custom_more,		&num_editor_el_custom_more
  },
  {
    NULL,
    NULL,				NULL,
    NULL,				NULL
  }
};


/*
  -----------------------------------------------------------------------------
  functions
  -----------------------------------------------------------------------------
*/

static int getMaxInfoTextLength()
{
  return (SXSIZE / getFontWidth(FONT_TEXT_2));
}

static int getTextWidthForGadget(char *text)
{
  if (text == NULL)
    return 0;

  return (getTextWidth(text, FONT_TEXT_1) + ED_GADGET_TEXT_DISTANCE);
}

static int getTextWidthForDrawingArea(char *text)
{
  if (text == NULL)
    return 0;

  return (getTextWidth(text, FONT_TEXT_1) + ED_DRAWINGAREA_TEXT_DISTANCE);
}

static int getRightGadgetBorder(struct GadgetInfo *gi, char *text)
{
  return (gi->x + gi->width + getTextWidthForGadget(text));
}

static char *getElementInfoText(int element)
{
  char *info_text = NULL;

  if (element < NUM_FILE_ELEMENTS)
  {
    if (strlen(element_info[element].description) > 0)
      info_text = element_info[element].description;
    else if (element_info[element].custom_description != NULL)
      info_text = element_info[element].custom_description;
    else if (element_info[element].editor_description != NULL)
      info_text = element_info[element].editor_description;
  }

  if (info_text == NULL)
    info_text = INFOTEXT_UNKNOWN_ELEMENT;

  return info_text;
}

static void ReinitializeElementList()
{
  static boolean initialized = FALSE;
  int pos = 0;
  int i, j;

  if (editor_elements != NULL)
    free(editor_elements);

  /* do some sanity check for each element from element list at startup */
  if (!initialized)
  {
    for (i=0; editor_elements_info[i].setup_value != NULL; i++)
    {
      for (j=0; j < *editor_elements_info[i].element_list_size; j++)
      {
	int element = editor_elements_info[i].element_list[j];

	if (element >= NUM_FILE_ELEMENTS)
	  Error(ERR_WARN, "editor element %d is runtime element", element);

	if (strcmp(getElementInfoText(element), INFOTEXT_UNKNOWN_ELEMENT) == 0)
	  Error(ERR_WARN, "no element description for element %d", element);
      }
    }

    initialized = TRUE;
  }

  num_editor_elements = 0;

  /* determine size of element list */
  for (i=0; editor_elements_info[i].setup_value != NULL; i++)
  {
    if (*editor_elements_info[i].setup_value)
    {
      if (setup.editor.el_headlines)
	num_editor_elements += *editor_elements_info[i].headline_list_size;

      num_editor_elements += *editor_elements_info[i].element_list_size;
    }
  }

  if (num_editor_elements < ED_NUM_ELEMENTLIST_BUTTONS)
  {
    /* workaround: offer at least as many elements as element buttons exist */
    int list_nr = 1;	/* see above: editor_elements_info for Emerald Mine */

    *editor_elements_info[list_nr].setup_value = TRUE;
    num_editor_elements += *editor_elements_info[list_nr].element_list_size;
  }

  editor_elements = checked_malloc(num_editor_elements * sizeof(int));

  /* fill element list */
  for (i=0; editor_elements_info[i].setup_value != NULL; i++)
  {
    if (*editor_elements_info[i].setup_value)
    {
      if (setup.editor.el_headlines)
	for (j=0; j < *editor_elements_info[i].headline_list_size; j++)
	  editor_elements[pos++] = editor_elements_info[i].headline_list[j];

      for (j=0; j < *editor_elements_info[i].element_list_size; j++)
	editor_elements[pos++] = editor_elements_info[i].element_list[j];
    }
  }

  /* correct position of element list scrollbar */
  if (element_shift < 0)
    element_shift = 0;
  if (element_shift > num_editor_elements - ED_NUM_ELEMENTLIST_BUTTONS)
    element_shift = num_editor_elements - ED_NUM_ELEMENTLIST_BUTTONS;
}

static void ReinitializeElementListButtons()
{
  static boolean last_setup_value_headlines = FALSE;
  static boolean initialization_needed = TRUE;
  int i;

  if (!initialization_needed)	/* check if editor element setup has changed */
  {
    if (last_setup_value_headlines != setup.editor.el_headlines)
      initialization_needed = TRUE;

    for (i=0; editor_elements_info[i].setup_value != NULL; i++)
      if (editor_elements_info[i].last_setup_value !=
	  *editor_elements_info[i].setup_value)
	initialization_needed = TRUE;
  }

  if (!initialization_needed)
    return;

  FreeLevelEditorGadgets();
  CreateLevelEditorGadgets();

  /* store current setup values for next invocation of this function */
  last_setup_value_headlines = setup.editor.el_headlines;
  for (i=0; editor_elements_info[i].setup_value != NULL; i++)
    editor_elements_info[i].last_setup_value =
      *editor_elements_info[i].setup_value;

  initialization_needed = FALSE;
}

static void DrawElementBorder(int dest_x, int dest_y, int width, int height,
			      boolean input)
{
  int border_graphic =
    (input ? IMG_EDITOR_ELEMENT_BORDER_INPUT : IMG_EDITOR_ELEMENT_BORDER);
  Bitmap *src_bitmap;
  int src_x, src_y;
  int num_mini_tilex = width / MINI_TILEX + 1;
  int num_mini_tiley = width / MINI_TILEY + 1;
  int x, y;

  getMiniGraphicSource(border_graphic, &src_bitmap, &src_x, &src_y);

  for (y=0; y < num_mini_tiley; y++)
    for (x=0; x < num_mini_tilex; x++)
      BlitBitmap(src_bitmap, drawto, src_x, src_y, MINI_TILEX, MINI_TILEY,
		 dest_x - MINI_TILEX / 2 + x * MINI_TILEX,
		 dest_y - MINI_TILEY / 2 + y * MINI_TILEY);

  ClearRectangle(drawto, dest_x - 1, dest_y - 1, width + 2, height + 2);
}

static void DrawDrawingArea(int id)
{
  struct GadgetInfo *gi = level_editor_gadget[drawingarea_info[id].gadget_id];
  int x, y;

  if (id == ED_DRAWING_ID_RANDOM_BACKGROUND)
    DrawMiniGraphicExt(drawto, gi->x, gi->y,
		       el2edimg(random_placement_background_element));
  else if (id == ED_DRAWING_ID_AMOEBA_CONTENT)
    DrawMiniGraphicExt(drawto, gi->x, gi->y, el2edimg(level.amoeba_content));
  else if (id == ED_DRAWING_ID_CUSTOM_GRAPHIC)
    DrawMiniGraphicExt(drawto, gi->x, gi->y,
		       el2edimg(custom_element.gfx_element));
  else if (id == ED_DRAWING_ID_CUSTOM_CONTENT)
    for (y=0; y<3; y++)
      for (x=0; x<3; x++)
	DrawMiniGraphicExt(drawto,
			   gi->x + x * MINI_TILEX, gi->y + y * MINI_TILEY,
			   el2edimg(custom_element.content[x][y]));
  else if (id == ED_DRAWING_ID_CUSTOM_CHANGE_TARGET)
    DrawMiniGraphicExt(drawto, gi->x, gi->y,
		       el2edimg(custom_element_change.target_element));
  else if (id == ED_DRAWING_ID_CUSTOM_CHANGE_CONTENT)
    for (y=0; y < 3; y++)
      for (x=0; x < 3; x++)
	DrawMiniGraphicExt(drawto,
			   gi->x + x * MINI_TILEX, gi->y + y * MINI_TILEY,
			   el2edimg(custom_element_change.content[x][y]));
  else if (id == ED_DRAWING_ID_CUSTOM_CHANGE_TRIGGER)
    DrawMiniGraphicExt(drawto, gi->x, gi->y,
		       el2edimg(custom_element_change.trigger_element));
  else if (id >= ED_DRAWING_ID_ELEMENT_CONTENT_0 &&
	   id <= ED_DRAWING_ID_ELEMENT_CONTENT_7)
  {
    int nr = id - ED_DRAWING_ID_ELEMENT_CONTENT_0;

    for (y=0; y < 3; y++)
      for (x=0; x < 3; x++)
	DrawMiniGraphicExt(drawto,
			   gi->x + x * MINI_TILEX, gi->y + y * MINI_TILEY,
			   el2edimg(level.yamyam_content[nr][x][y]));
  }
}

static void ScrollMiniLevel(int from_x, int from_y, int scroll)
{
  int x,y;
  int dx = (scroll == ED_SCROLL_LEFT ? -1 : scroll == ED_SCROLL_RIGHT ? 1 : 0);
  int dy = (scroll == ED_SCROLL_UP   ? -1 : scroll == ED_SCROLL_DOWN  ? 1 : 0);

  BlitBitmap(drawto, drawto,
	     SX + (dx == -1 ? MINI_TILEX : 0),
	     SY + (dy == -1 ? MINI_TILEY : 0),
	     (ed_fieldx * MINI_TILEX) - (dx != 0 ? MINI_TILEX : 0),
	     (ed_fieldy * MINI_TILEY) - (dy != 0 ? MINI_TILEY : 0),
	     SX + (dx == +1 ? MINI_TILEX : 0),
	     SY + (dy == +1 ? MINI_TILEY : 0));
  if (dx)
  {
    x = (dx == 1 ? 0 : ed_fieldx - 1);
    for(y=0; y<ed_fieldy; y++)
      DrawMiniElementOrWall(x, y, from_x, from_y);
  }
  else if (dy)
  {
    y = (dy == 1 ? 0 : ed_fieldy - 1);
    for(x=0; x<ed_fieldx; x++)
      DrawMiniElementOrWall(x, y, from_x, from_y);
  }

  redraw_mask |= REDRAW_FIELD;
  BackToFront();
}

static void CreateControlButtons()
{
  Bitmap *gd_bitmap = graphic_info[IMG_GLOBAL_DOOR].bitmap;
  struct GadgetInfo *gi;
  unsigned long event_mask;
  int i;

  /* create toolbox buttons */
  for (i=0; i<ED_NUM_CTRL_BUTTONS; i++)
  {
    int id = i;
    int width, height;
    int gd_xoffset, gd_yoffset;
    int gd_x1, gd_x2, gd_y1, gd_y2;
    int button_type;
    int radio_button_nr;
    boolean checked;

    if (id == GADGET_ID_SINGLE_ITEMS ||
	id == GADGET_ID_CONNECTED_ITEMS ||
	id == GADGET_ID_LINE ||
	id == GADGET_ID_ARC ||
	id == GADGET_ID_TEXT ||
	id == GADGET_ID_RECTANGLE ||
	id == GADGET_ID_FILLED_BOX ||
	id == GADGET_ID_FLOOD_FILL ||
	id == GADGET_ID_GRAB_BRUSH ||
	id == GADGET_ID_PICK_ELEMENT)
    {
      button_type = GD_TYPE_RADIO_BUTTON;
      radio_button_nr = RADIO_NR_DRAWING_TOOLBOX;
      checked = (id == drawing_function ? TRUE : FALSE);
      event_mask = GD_EVENT_PRESSED;
    }
    else
    {
      button_type = GD_TYPE_NORMAL_BUTTON;
      radio_button_nr = RADIO_NR_NONE;
      checked = FALSE;

      if (id == GADGET_ID_WRAP_LEFT ||
	  id == GADGET_ID_WRAP_RIGHT ||
	  id == GADGET_ID_WRAP_UP ||
	  id == GADGET_ID_WRAP_DOWN)
	event_mask = GD_EVENT_PRESSED | GD_EVENT_REPEATED;
      else
	event_mask = GD_EVENT_RELEASED;
    }

    if (id < ED_NUM_CTRL1_BUTTONS)
    {
      int x = i % ED_CTRL1_BUTTONS_HORIZ;
      int y = i / ED_CTRL1_BUTTONS_HORIZ;

      gd_xoffset = ED_CTRL1_BUTTONS_XPOS + x * ED_CTRL1_BUTTON_XSIZE;
      gd_yoffset = ED_CTRL1_BUTTONS_YPOS + y * ED_CTRL1_BUTTON_YSIZE;
      width = ED_CTRL1_BUTTON_XSIZE;
      height = ED_CTRL1_BUTTON_YSIZE;
    }
    else
    {
      int x = (i - ED_NUM_CTRL1_BUTTONS) % ED_CTRL2_BUTTONS_HORIZ;
      int y = (i - ED_NUM_CTRL1_BUTTONS) / ED_CTRL2_BUTTONS_HORIZ;

      gd_xoffset = ED_CTRL2_BUTTONS_XPOS + x * ED_CTRL2_BUTTON_XSIZE;
      gd_yoffset = ED_CTRL2_BUTTONS_YPOS + y * ED_CTRL2_BUTTON_YSIZE;
      width = ED_CTRL2_BUTTON_XSIZE;
      height = ED_CTRL2_BUTTON_YSIZE;
    }

    gd_x1 = DOOR_GFX_PAGEX8 + gd_xoffset;
    gd_x2 = DOOR_GFX_PAGEX7 + gd_xoffset;
    gd_y1  = DOOR_GFX_PAGEY1 + ED_CTRL_BUTTONS_GFX_YPOS + gd_yoffset;
    gd_y2  = DOOR_GFX_PAGEY1 + ED_CTRL_BUTTONS_ALT_GFX_YPOS + gd_yoffset;

    gi = CreateGadget(GDI_CUSTOM_ID, id,
		      GDI_CUSTOM_TYPE_ID, i,
		      GDI_INFO_TEXT, control_info[i].text,
		      GDI_X, EX + gd_xoffset,
		      GDI_Y, EY + gd_yoffset,
		      GDI_WIDTH, width,
		      GDI_HEIGHT, height,
		      GDI_TYPE, button_type,
		      GDI_STATE, GD_BUTTON_UNPRESSED,
		      GDI_RADIO_NR, radio_button_nr,
		      GDI_CHECKED, checked,
		      GDI_DESIGN_UNPRESSED, gd_bitmap, gd_x1, gd_y1,
		      GDI_DESIGN_PRESSED, gd_bitmap, gd_x2, gd_y1,
		      GDI_ALT_DESIGN_UNPRESSED, gd_bitmap, gd_x1, gd_y2,
		      GDI_ALT_DESIGN_PRESSED, gd_bitmap, gd_x2, gd_y2,
		      GDI_EVENT_MASK, event_mask,
		      GDI_CALLBACK_INFO, HandleEditorGadgetInfoText,
		      GDI_CALLBACK_ACTION, HandleControlButtons,
		      GDI_END);

    if (gi == NULL)
      Error(ERR_EXIT, "cannot create gadget");

    level_editor_gadget[id] = gi;
  }

  /* create buttons for scrolling of drawing area and element list */
  for (i=0; i<ED_NUM_SCROLLBUTTONS; i++)
  {
    int id = scrollbutton_info[i].gadget_id;
    int x, y, width, height;
    int gd_x1, gd_x2, gd_y1, gd_y2;

    x = scrollbutton_info[i].x;
    y = scrollbutton_info[i].y;

    event_mask = GD_EVENT_PRESSED | GD_EVENT_REPEATED;

    if (id == GADGET_ID_SCROLL_LIST_UP ||
	id == GADGET_ID_SCROLL_LIST_DOWN)
    {
      x += DX;
      y += DY;
      width = ED_SCROLLBUTTON2_XSIZE;
      height = ED_SCROLLBUTTON2_YSIZE;
      gd_x1 = DOOR_GFX_PAGEX8 + scrollbutton_info[i].gd_x;
      gd_y1 = DOOR_GFX_PAGEY1 + scrollbutton_info[i].gd_y;
      gd_x2 = gd_x1 - ED_SCROLLBUTTON2_XSIZE;
      gd_y2 = gd_y1;
    }
    else
    {
      x += SX;
      y += SY;
      width = ED_SCROLLBUTTON_XSIZE;
      height = ED_SCROLLBUTTON_YSIZE;
      gd_x1 = DOOR_GFX_PAGEX8 + scrollbutton_info[i].gd_x;
      gd_y1 = DOOR_GFX_PAGEY1 + scrollbutton_info[i].gd_y;
      gd_x2 = gd_x1 - ED_SCROLLBUTTON_XSIZE;
      gd_y2 = gd_y1;
    }

    gi = CreateGadget(GDI_CUSTOM_ID, id,
		      GDI_CUSTOM_TYPE_ID, i,
		      GDI_INFO_TEXT, scrollbutton_info[i].infotext,
		      GDI_X, x,
		      GDI_Y, y,
		      GDI_WIDTH, width,
		      GDI_HEIGHT, height,
		      GDI_TYPE, GD_TYPE_NORMAL_BUTTON,
		      GDI_STATE, GD_BUTTON_UNPRESSED,
		      GDI_DESIGN_UNPRESSED, gd_bitmap, gd_x1, gd_y1,
		      GDI_DESIGN_PRESSED, gd_bitmap, gd_x2, gd_y2,
		      GDI_EVENT_MASK, event_mask,
		      GDI_CALLBACK_INFO, HandleEditorGadgetInfoText,
		      GDI_CALLBACK_ACTION, HandleControlButtons,
		      GDI_END);

    if (gi == NULL)
      Error(ERR_EXIT, "cannot create gadget");

    level_editor_gadget[id] = gi;
  }

  /* create buttons for element list */
  for (i=0; i < ED_NUM_ELEMENTLIST_BUTTONS; i++)
  {
    Bitmap *deco_bitmap;
    int deco_x, deco_y, deco_xpos, deco_ypos;
    int gd_xoffset, gd_yoffset;
    int gd_x1, gd_x2, gd_y;
    int x = i % ED_ELEMENTLIST_BUTTONS_HORIZ;
    int y = i / ED_ELEMENTLIST_BUTTONS_HORIZ;
    int id = GADGET_ID_ELEMENTLIST_FIRST + i;
    int element = editor_elements[i];

    event_mask = GD_EVENT_RELEASED;

    gd_xoffset = ED_ELEMENTLIST_XPOS + x * ED_ELEMENTLIST_XSIZE;
    gd_yoffset = ED_ELEMENTLIST_YPOS + y * ED_ELEMENTLIST_YSIZE;

    gd_x1 = DOOR_GFX_PAGEX6 + ED_ELEMENTLIST_XPOS + ED_ELEMENTLIST_XSIZE;
    gd_x2 = DOOR_GFX_PAGEX6 + ED_ELEMENTLIST_XPOS;
    gd_y  = DOOR_GFX_PAGEY1 + ED_ELEMENTLIST_YPOS;

    getMiniGraphicSource(el2edimg(element), &deco_bitmap, &deco_x, &deco_y);
    deco_xpos = (ED_ELEMENTLIST_XSIZE - MINI_TILEX) / 2;
    deco_ypos = (ED_ELEMENTLIST_YSIZE - MINI_TILEY) / 2;

    gi = CreateGadget(GDI_CUSTOM_ID, id,
		      GDI_CUSTOM_TYPE_ID, i,
		      GDI_INFO_TEXT, getElementInfoText(element),
		      GDI_X, DX + gd_xoffset,
		      GDI_Y, DY + gd_yoffset,
		      GDI_WIDTH, ED_ELEMENTLIST_XSIZE,
		      GDI_HEIGHT, ED_ELEMENTLIST_YSIZE,
		      GDI_TYPE, GD_TYPE_NORMAL_BUTTON,
		      GDI_STATE, GD_BUTTON_UNPRESSED,
		      GDI_DESIGN_UNPRESSED, gd_bitmap, gd_x1, gd_y,
		      GDI_DESIGN_PRESSED, gd_bitmap, gd_x2, gd_y,
		      GDI_DECORATION_DESIGN, deco_bitmap, deco_x, deco_y,
		      GDI_DECORATION_POSITION, deco_xpos, deco_ypos,
		      GDI_DECORATION_SIZE, MINI_TILEX, MINI_TILEY,
		      GDI_DECORATION_SHIFTING, 1, 1,
		      GDI_EVENT_MASK, event_mask,
		      GDI_CALLBACK_INFO, HandleEditorGadgetInfoText,
		      GDI_CALLBACK_ACTION, HandleControlButtons,
		      GDI_END);

    if (gi == NULL)
      Error(ERR_EXIT, "cannot create gadget");

    level_editor_gadget[id] = gi;
  }
}

static void CreateCounterButtons()
{
  int max_infotext_len = getMaxInfoTextLength();
  int i;

  for (i=0; i<ED_NUM_COUNTERBUTTONS; i++)
  {
    int j;
    int x = SX + counterbutton_info[i].x;	/* down count button */
    int y = SY + counterbutton_info[i].y;

    /* determine horizontal position to the right of specified gadget */
    if (counterbutton_info[i].gadget_id_align != GADGET_ID_NONE)
      x = (right_gadget_border[counterbutton_info[i].gadget_id_align] +
	   ED_GADGET_TEXT_DISTANCE);

    /* determine horizontal offset for leading text */
    if (counterbutton_info[i].text_left != NULL)
      x += getTextWidthForGadget(counterbutton_info[i].text_left);

    for (j=0; j<2; j++)
    {
      Bitmap *gd_bitmap = graphic_info[IMG_GLOBAL_DOOR].bitmap;
      struct GadgetInfo *gi;
      int id = (j == 0 ?
		counterbutton_info[i].gadget_id_down :
		counterbutton_info[i].gadget_id_up);
      int gd_xoffset;
      int gd_x, gd_x1, gd_x2, gd_y;
      int x_size, y_size;
      unsigned long event_mask;
      char infotext[max_infotext_len + 1];

      event_mask = GD_EVENT_PRESSED | GD_EVENT_REPEATED;

      if (i == ED_COUNTER_ID_SELECT_LEVEL)
      {
	int sid = (j == 0 ?
		   ED_SCROLLBUTTON_ID_AREA_LEFT :
		   ED_SCROLLBUTTON_ID_AREA_RIGHT);

	event_mask |= GD_EVENT_RELEASED;

	if (j == 1)
	  x += 2 * ED_GADGET_DISTANCE;
	y += ED_GADGET_DISTANCE;

	gd_x1 = DOOR_GFX_PAGEX8 + scrollbutton_info[sid].gd_x;
	gd_x2 = gd_x1 - ED_SCROLLBUTTON_XSIZE;
	gd_y  = DOOR_GFX_PAGEY1 + scrollbutton_info[sid].gd_y;
	x_size = ED_SCROLLBUTTON_XSIZE;
	y_size = ED_SCROLLBUTTON_YSIZE;
      }
      else
      {
	gd_xoffset = (j == 0 ? ED_BUTTON_MINUS_XPOS : ED_BUTTON_PLUS_XPOS);
	gd_x1 = DOOR_GFX_PAGEX4 + gd_xoffset;
	gd_x2 = DOOR_GFX_PAGEX3 + gd_xoffset;
	gd_y  = DOOR_GFX_PAGEY1 + ED_BUTTON_COUNT_YPOS;
	x_size = ED_BUTTON_COUNT_XSIZE;
	y_size = ED_BUTTON_COUNT_YSIZE;
      }

      sprintf(infotext, "%s counter value by 1, 5 or 10",
	      (j == 0 ? "decrease" : "increase"));

      gi = CreateGadget(GDI_CUSTOM_ID, id,
			GDI_CUSTOM_TYPE_ID, i,
			GDI_INFO_TEXT, infotext,
			GDI_X, x,
			GDI_Y, y,
			GDI_WIDTH, x_size,
			GDI_HEIGHT, y_size,
			GDI_TYPE, GD_TYPE_NORMAL_BUTTON,
			GDI_STATE, GD_BUTTON_UNPRESSED,
			GDI_DESIGN_UNPRESSED, gd_bitmap, gd_x1, gd_y,
			GDI_DESIGN_PRESSED, gd_bitmap, gd_x2, gd_y,
			GDI_EVENT_MASK, event_mask,
			GDI_CALLBACK_INFO, HandleEditorGadgetInfoText,
			GDI_CALLBACK_ACTION, HandleCounterButtons,
			GDI_END);

      if (gi == NULL)
	Error(ERR_EXIT, "cannot create gadget");

      level_editor_gadget[id] = gi;
      right_gadget_border[id] =
	getRightGadgetBorder(gi, counterbutton_info[i].text_right);

      x += gi->width + ED_GADGET_DISTANCE;	/* text count button */

      if (j == 0)
      {
	int font_type = FONT_INPUT_1;
	int font_type_active = FONT_INPUT_1_ACTIVE;
	int gd_width = ED_WIN_COUNT_XSIZE;

	id = counterbutton_info[i].gadget_id_text;
	event_mask = GD_EVENT_TEXT_RETURN | GD_EVENT_TEXT_LEAVING;

	if (i == ED_COUNTER_ID_SELECT_LEVEL)
	{
	  font_type = FONT_LEVEL_NUMBER;
	  font_type_active = FONT_LEVEL_NUMBER;

	  x += 2 * ED_GADGET_DISTANCE;
	  y -= ED_GADGET_DISTANCE;

	  gd_x = DOOR_GFX_PAGEX6 + ED_WIN_COUNT2_XPOS;
	  gd_y = DOOR_GFX_PAGEY1 + ED_WIN_COUNT2_YPOS;
	  gd_width = ED_WIN_COUNT2_XSIZE;
	}
	else
	{
	  gd_x = DOOR_GFX_PAGEX4 + ED_WIN_COUNT_XPOS;
	  gd_y = DOOR_GFX_PAGEY1 + ED_WIN_COUNT_YPOS;
	}

	gi = CreateGadget(GDI_CUSTOM_ID, id,
			  GDI_CUSTOM_TYPE_ID, i,
			  GDI_INFO_TEXT, "enter counter value",
			  GDI_X, x,
			  GDI_Y, y,
			  GDI_TYPE, GD_TYPE_TEXT_INPUT_NUMERIC,
			  GDI_NUMBER_VALUE, 0,
			  GDI_NUMBER_MIN, counterbutton_info[i].min_value,
			  GDI_NUMBER_MAX, counterbutton_info[i].max_value,
			  GDI_TEXT_SIZE, 3,
			  GDI_TEXT_FONT, font_type,
			  GDI_TEXT_FONT_ACTIVE, font_type_active,
			  GDI_DESIGN_UNPRESSED, gd_bitmap, gd_x, gd_y,
			  GDI_DESIGN_PRESSED, gd_bitmap, gd_x, gd_y,
			  GDI_BORDER_SIZE, ED_BORDER_SIZE, ED_BORDER_SIZE,
			  GDI_DESIGN_WIDTH, gd_width,
			  GDI_EVENT_MASK, event_mask,
			  GDI_CALLBACK_INFO, HandleEditorGadgetInfoText,
			  GDI_CALLBACK_ACTION, HandleCounterButtons,
			  GDI_END);

	if (gi == NULL)
	  Error(ERR_EXIT, "cannot create gadget");

	level_editor_gadget[id] = gi;
	right_gadget_border[id] =
	  getRightGadgetBorder(gi, counterbutton_info[i].text_right);

	x += gi->width + ED_GADGET_DISTANCE;	/* up count button */
      }
    }
  }
}

static void CreateDrawingAreas()
{
  int i;

  for (i=0; i<ED_NUM_DRAWING_AREAS; i++)
  {
    struct GadgetInfo *gi;
    unsigned long event_mask;
    int id = drawingarea_info[i].gadget_id;
    int x = SX + drawingarea_info[i].x;
    int y = SY + drawingarea_info[i].y;
    int area_xsize = drawingarea_info[i].area_xsize;
    int area_ysize = drawingarea_info[i].area_ysize;

    event_mask =
      GD_EVENT_PRESSED | GD_EVENT_RELEASED | GD_EVENT_MOVING |
      GD_EVENT_OFF_BORDERS;

    /* determine horizontal position to the right of specified gadget */
    if (drawingarea_info[i].gadget_id_align != GADGET_ID_NONE)
      x = (right_gadget_border[drawingarea_info[i].gadget_id_align] +
	   ED_DRAWINGAREA_TEXT_DISTANCE);

    /* determine horizontal offset for leading text */
    if (drawingarea_info[i].text_left != NULL)
      x += getTextWidthForDrawingArea(drawingarea_info[i].text_left);

    gi = CreateGadget(GDI_CUSTOM_ID, id,
		      GDI_CUSTOM_TYPE_ID, i,
		      GDI_X, x,
		      GDI_Y, y,
		      GDI_TYPE, GD_TYPE_DRAWING_AREA,
		      GDI_AREA_SIZE, area_xsize, area_ysize,
		      GDI_ITEM_SIZE, MINI_TILEX, MINI_TILEY,
		      GDI_EVENT_MASK, event_mask,
		      GDI_CALLBACK_INFO, HandleDrawingAreaInfo,
		      GDI_CALLBACK_ACTION, HandleDrawingAreas,
		      GDI_END);

    if (gi == NULL)
      Error(ERR_EXIT, "cannot create gadget");

    level_editor_gadget[id] = gi;
    right_gadget_border[id] =
      getRightGadgetBorder(gi, drawingarea_info[i].text_right);
  }
}

static void CreateTextInputGadgets()
{
  int max_infotext_len = getMaxInfoTextLength();
  int i;

  for (i=0; i<ED_NUM_TEXTINPUT; i++)
  {
    Bitmap *gd_bitmap = graphic_info[IMG_GLOBAL_DOOR].bitmap;
    int gd_x, gd_y;
    struct GadgetInfo *gi;
    unsigned long event_mask;
    char infotext[MAX_OUTPUT_LINESIZE + 1];
    int id = textinput_info[i].gadget_id;

    event_mask = GD_EVENT_TEXT_RETURN | GD_EVENT_TEXT_LEAVING;

    gd_x = DOOR_GFX_PAGEX4 + ED_WIN_COUNT_XPOS;
    gd_y = DOOR_GFX_PAGEY1 + ED_WIN_COUNT_YPOS;

    sprintf(infotext, "Enter %s", textinput_info[i].infotext);
    infotext[max_infotext_len] = '\0';

    gi = CreateGadget(GDI_CUSTOM_ID, id,
		      GDI_CUSTOM_TYPE_ID, i,
		      GDI_INFO_TEXT, infotext,
		      GDI_X, SX + textinput_info[i].x,
		      GDI_Y, SY + textinput_info[i].y,
		      GDI_TYPE, GD_TYPE_TEXT_INPUT_ALPHANUMERIC,
		      GDI_TEXT_VALUE, textinput_info[i].value,
		      GDI_TEXT_SIZE, textinput_info[i].size,
		      GDI_TEXT_FONT, FONT_INPUT_1,
		      GDI_TEXT_FONT_ACTIVE, FONT_INPUT_1_ACTIVE,
		      GDI_DESIGN_UNPRESSED, gd_bitmap, gd_x, gd_y,
		      GDI_DESIGN_PRESSED, gd_bitmap, gd_x, gd_y,
		      GDI_BORDER_SIZE, ED_BORDER_SIZE, ED_BORDER_SIZE,
		      GDI_DESIGN_WIDTH, ED_WIN_COUNT_XSIZE,
		      GDI_EVENT_MASK, event_mask,
		      GDI_CALLBACK_INFO, HandleEditorGadgetInfoText,
		      GDI_CALLBACK_ACTION, HandleTextInputGadgets,
		      GDI_END);

    if (gi == NULL)
      Error(ERR_EXIT, "cannot create gadget");

    level_editor_gadget[id] = gi;
  }
}

static void CreateTextAreaGadgets()
{
  int max_infotext_len = getMaxInfoTextLength();
  int i;

  for (i=0; i<ED_NUM_TEXTAREAS; i++)
  {
    Bitmap *gd_bitmap = graphic_info[IMG_GLOBAL_DOOR].bitmap;
    int gd_x, gd_y;
    struct GadgetInfo *gi;
    unsigned long event_mask;
    char infotext[MAX_OUTPUT_LINESIZE + 1];
    int id = textarea_info[i].gadget_id;
    int area_xsize = textarea_info[i].xsize;
    int area_ysize = textarea_info[i].ysize;

    event_mask = GD_EVENT_TEXT_LEAVING;

    gd_x = DOOR_GFX_PAGEX4 + ED_WIN_COUNT_XPOS;
    gd_y = DOOR_GFX_PAGEY1 + ED_WIN_COUNT_YPOS;

    sprintf(infotext, "Enter %s", textarea_info[i].infotext);
    infotext[max_infotext_len] = '\0';

    gi = CreateGadget(GDI_CUSTOM_ID, id,
		      GDI_CUSTOM_TYPE_ID, i,
		      GDI_INFO_TEXT, infotext,
		      GDI_X, SX + textarea_info[i].x,
		      GDI_Y, SY + textarea_info[i].y,
		      GDI_TYPE, GD_TYPE_TEXT_AREA,
		      GDI_AREA_SIZE, area_xsize, area_ysize,
		      GDI_TEXT_FONT, FONT_INPUT_1,
		      GDI_TEXT_FONT_ACTIVE, FONT_INPUT_1_ACTIVE,
		      GDI_DESIGN_UNPRESSED, gd_bitmap, gd_x, gd_y,
		      GDI_DESIGN_PRESSED, gd_bitmap, gd_x, gd_y,
		      GDI_BORDER_SIZE, ED_BORDER_SIZE, ED_BORDER_SIZE,
		      GDI_DESIGN_WIDTH, ED_WIN_COUNT_XSIZE,
		      GDI_EVENT_MASK, event_mask,
		      GDI_CALLBACK_INFO, HandleEditorGadgetInfoText,
		      GDI_CALLBACK_ACTION, HandleTextAreaGadgets,
		      GDI_END);

    if (gi == NULL)
      Error(ERR_EXIT, "cannot create gadget");

    level_editor_gadget[id] = gi;
  }
}

static void CreateSelectboxGadgets()
{
  int max_infotext_len = getMaxInfoTextLength();
  int i, j;

  for (i=0; i<ED_NUM_SELECTBOX; i++)
  {
    Bitmap *gd_bitmap = graphic_info[IMG_GLOBAL_DOOR].bitmap;
    int gd_x, gd_y;
    struct GadgetInfo *gi;
    unsigned long event_mask;
    char infotext[MAX_OUTPUT_LINESIZE + 1];
    int id = selectbox_info[i].gadget_id;
    int x = SX + selectbox_info[i].x;
    int y = SY + selectbox_info[i].y;

    if (selectbox_info[i].size == -1)	/* dynamically determine size */
    {
      /* (we cannot use -1 for uninitialized values if we directly compare
	 with results from strlen(), because the '<' and '>' operation will
	 implicitely cast -1 to an unsigned integer value!) */
      selectbox_info[i].size = 0;

      for (j=0; selectbox_info[i].options[j].text != NULL; j++)
	if (strlen(selectbox_info[i].options[j].text) > selectbox_info[i].size)
	  selectbox_info[i].size = strlen(selectbox_info[i].options[j].text);

      selectbox_info[i].size++;		/* add one character empty space */
    }

    event_mask = GD_EVENT_RELEASED |
      GD_EVENT_TEXT_RETURN | GD_EVENT_TEXT_LEAVING;

    gd_x = DOOR_GFX_PAGEX4 + ED_SELECTBOX_XPOS;
    gd_y = DOOR_GFX_PAGEY1 + ED_SELECTBOX_YPOS;

    /* determine horizontal position to the right of specified gadget */
    if (selectbox_info[i].gadget_id_align != GADGET_ID_NONE)
      x = (right_gadget_border[selectbox_info[i].gadget_id_align] +
	   ED_GADGET_TEXT_DISTANCE);

    /* determine horizontal offset for leading text */
    if (selectbox_info[i].text_left != NULL)
      x += getTextWidthForGadget(selectbox_info[i].text_left);

    sprintf(infotext, "Select %s", selectbox_info[i].infotext);
    infotext[max_infotext_len] = '\0';

    gi = CreateGadget(GDI_CUSTOM_ID, id,
		      GDI_CUSTOM_TYPE_ID, i,
		      GDI_INFO_TEXT, infotext,
		      GDI_X, x,
		      GDI_Y, y,
		      GDI_TYPE, GD_TYPE_SELECTBOX,
		      GDI_SELECTBOX_OPTIONS, selectbox_info[i].options,
		      GDI_TEXT_SIZE, selectbox_info[i].size,
		      GDI_TEXT_FONT, FONT_INPUT_1,
		      GDI_TEXT_FONT_ACTIVE, FONT_INPUT_1_ACTIVE,
		      GDI_DESIGN_UNPRESSED, gd_bitmap, gd_x, gd_y,
		      GDI_DESIGN_PRESSED, gd_bitmap, gd_x, gd_y,
		      GDI_BORDER_SIZE, ED_BORDER_SIZE, ED_BORDER_SIZE,
		      GDI_BORDER_SIZE_SELECTBUTTON, ED_SELECTBOX_BUTTON_XSIZE,
		      GDI_DESIGN_WIDTH, ED_WIN_COUNT_XSIZE,
		      GDI_EVENT_MASK, event_mask,
		      GDI_CALLBACK_INFO, HandleEditorGadgetInfoText,
		      GDI_CALLBACK_ACTION, HandleSelectboxGadgets,
		      GDI_END);

    if (gi == NULL)
      Error(ERR_EXIT, "cannot create gadget");

    level_editor_gadget[id] = gi;
    right_gadget_border[id] =
      getRightGadgetBorder(gi, selectbox_info[i].text_right);
  }
}

static void CreateTextbuttonGadgets()
{
  int max_infotext_len = getMaxInfoTextLength();
  int i;

  for (i=0; i<ED_NUM_TEXTBUTTONS; i++)
  {
    Bitmap *gd_bitmap = graphic_info[IMG_GLOBAL_DOOR].bitmap;
    int gd_x1, gd_x2, gd_y1, gd_y2;
    struct GadgetInfo *gi;
    unsigned long event_mask;
    char infotext[MAX_OUTPUT_LINESIZE + 1];
    int id = textbutton_info[i].gadget_id;
    int x = SX + textbutton_info[i].x;
    int y = SY + textbutton_info[i].y;

    if (textbutton_info[i].size == -1)	/* dynamically determine size */
      textbutton_info[i].size = strlen(textbutton_info[i].text);

    event_mask = GD_EVENT_RELEASED;

    if (id >= GADGET_ID_PROPERTIES_INFO && id <= GADGET_ID_PROPERTIES_ADVANCED)
    {
      gd_x1 = DOOR_GFX_PAGEX4 + ED_TEXTBUTTON_TAB_XPOS;
      gd_x2 = DOOR_GFX_PAGEX3 + ED_TEXTBUTTON_TAB_XPOS;
      gd_y1 = DOOR_GFX_PAGEY1 + ED_TEXTBUTTON_TAB_YPOS;
      gd_y2 = DOOR_GFX_PAGEY1 + ED_TEXTBUTTON_TAB_INACTIVE_YPOS;
    }
    else
    {
      gd_x1 = DOOR_GFX_PAGEX4 + ED_TEXTBUTTON_XPOS;
      gd_x2 = DOOR_GFX_PAGEX3 + ED_TEXTBUTTON_XPOS;
      gd_y1 = DOOR_GFX_PAGEY1 + ED_TEXTBUTTON_YPOS;
      gd_y2 = DOOR_GFX_PAGEY1 + ED_TEXTBUTTON_INACTIVE_YPOS;
    }

    sprintf(infotext, "%s", textbutton_info[i].infotext);
    infotext[max_infotext_len] = '\0';

    /* determine horizontal position to the right of specified gadget */
    if (textbutton_info[i].gadget_id_align != GADGET_ID_NONE)
      x = (right_gadget_border[textbutton_info[i].gadget_id_align] +
	   ED_GADGET_TEXT_DISTANCE);

    /* determine horizontal offset for leading text */
    if (textbutton_info[i].text_left != NULL)
      x += getTextWidthForGadget(textbutton_info[i].text_left);

    gi = CreateGadget(GDI_CUSTOM_ID, id,
		      GDI_CUSTOM_TYPE_ID, i,
		      GDI_INFO_TEXT, infotext,
		      GDI_X, x,
		      GDI_Y, y,
		      GDI_TYPE, GD_TYPE_TEXT_BUTTON,
		      GDI_TEXT_VALUE, textbutton_info[i].text,
		      GDI_TEXT_SIZE, textbutton_info[i].size,
		      GDI_TEXT_FONT, FONT_INPUT_2_ACTIVE,
		      GDI_TEXT_FONT_ACTIVE, FONT_INPUT_2,
		      GDI_DESIGN_UNPRESSED, gd_bitmap, gd_x1, gd_y1,
		      GDI_DESIGN_PRESSED, gd_bitmap, gd_x2, gd_y1,
		      GDI_ALT_DESIGN_UNPRESSED, gd_bitmap, gd_x1, gd_y2,
		      GDI_BORDER_SIZE, ED_BORDER_TEXT_XSIZE, ED_BORDER_SIZE,
		      GDI_DESIGN_WIDTH, ED_WIN_COUNT_XSIZE,
		      GDI_DECORATION_SHIFTING, 1, 1,
		      GDI_EVENT_MASK, event_mask,
		      GDI_CALLBACK_INFO, HandleEditorGadgetInfoText,
		      GDI_CALLBACK_ACTION, HandleTextbuttonGadgets,
		      GDI_END);

    if (gi == NULL)
      Error(ERR_EXIT, "cannot create gadget");

    level_editor_gadget[id] = gi;
    right_gadget_border[id] =
      getRightGadgetBorder(gi, textbutton_info[i].text_right);
  }
}

static void CreateGraphicbuttonGadgets()
{
  Bitmap *gd_bitmap = graphic_info[IMG_GLOBAL_DOOR].bitmap;
  struct GadgetInfo *gi;
  unsigned long event_mask;
  int i;

  /* create buttons for scrolling of drawing area and element list */
  for (i=0; i < ED_NUM_GRAPHICBUTTONS; i++)
  {
    int id = graphicbutton_info[i].gadget_id;
    int gd_x1, gd_x2, gd_y1, gd_y2;
    int x = SX + graphicbutton_info[i].x;
    int y = SY + graphicbutton_info[i].y;

    event_mask = GD_EVENT_PRESSED | GD_EVENT_REPEATED;

    gd_x1 = DOOR_GFX_PAGEX4 + graphicbutton_info[i].gd_x;
    gd_x2 = DOOR_GFX_PAGEX3 + graphicbutton_info[i].gd_x;
    gd_y1 = DOOR_GFX_PAGEY1 + graphicbutton_info[i].gd_y;
    gd_y2 = gd_y1;

    /* determine horizontal position to the right of specified gadget */
    if (graphicbutton_info[i].gadget_id_align != GADGET_ID_NONE)
      x = (right_gadget_border[graphicbutton_info[i].gadget_id_align] +
	   ED_GADGET_TEXT_DISTANCE);

    /* determine horizontal offset for leading text */
    if (graphicbutton_info[i].text_left != NULL)
      x += getTextWidthForGadget(graphicbutton_info[i].text_left);

    gi = CreateGadget(GDI_CUSTOM_ID, id,
		      GDI_CUSTOM_TYPE_ID, i,
		      GDI_INFO_TEXT, graphicbutton_info[i].infotext,
		      GDI_X, x,
		      GDI_Y, y,
		      GDI_WIDTH, graphicbutton_info[i].width,
		      GDI_HEIGHT, graphicbutton_info[i].height,
		      GDI_TYPE, GD_TYPE_NORMAL_BUTTON,
		      GDI_STATE, GD_BUTTON_UNPRESSED,
		      GDI_DESIGN_UNPRESSED, gd_bitmap, gd_x1, gd_y1,
		      GDI_DESIGN_PRESSED, gd_bitmap, gd_x2, gd_y2,
		      GDI_EVENT_MASK, event_mask,
		      GDI_CALLBACK_INFO, HandleEditorGadgetInfoText,
		      GDI_CALLBACK_ACTION, HandleGraphicbuttonGadgets,
		      GDI_END);

    if (gi == NULL)
      Error(ERR_EXIT, "cannot create gadget");

    level_editor_gadget[id] = gi;
    right_gadget_border[id] =
      getRightGadgetBorder(gi, graphicbutton_info[i].text_right);
  }
}

static void CreateScrollbarGadgets()
{
  int i;

  for (i=0; i<ED_NUM_SCROLLBARS; i++)
  {
    int id = scrollbar_info[i].gadget_id;
    Bitmap *gd_bitmap = graphic_info[IMG_GLOBAL_DOOR].bitmap;
    int gd_x1, gd_x2, gd_y1, gd_y2;
    struct GadgetInfo *gi;
    int items_max, items_visible, item_position;
    unsigned long event_mask;

    if (i == ED_SCROLLBAR_ID_LIST_VERTICAL)
    {
      items_max = num_editor_elements / ED_ELEMENTLIST_BUTTONS_HORIZ;
      items_visible = ED_ELEMENTLIST_BUTTONS_VERT;
      item_position = element_shift / ED_ELEMENTLIST_BUTTONS_HORIZ;
    }
    else	/* drawing area scrollbars */
    {
      if (scrollbar_info[i].type == GD_TYPE_SCROLLBAR_HORIZONTAL)
      {
	items_max = MAX(lev_fieldx + 2, ed_fieldx);
	items_visible = ed_fieldx;
	item_position = 0;
      }
      else
      {
	items_max = MAX(lev_fieldy + 2, ed_fieldy);
	items_visible = ed_fieldy;
	item_position = 0;
      }
    }

    event_mask = GD_EVENT_MOVING | GD_EVENT_OFF_BORDERS;

    gd_x1 = DOOR_GFX_PAGEX8 + scrollbar_info[i].gd_x;
    gd_x2 = (gd_x1 - (scrollbar_info[i].type == GD_TYPE_SCROLLBAR_HORIZONTAL ?
		      scrollbar_info[i].height : scrollbar_info[i].width));
    gd_y1 = DOOR_GFX_PAGEY1 + scrollbar_info[i].gd_y;
    gd_y2 = DOOR_GFX_PAGEY1 + scrollbar_info[i].gd_y;

    gi = CreateGadget(GDI_CUSTOM_ID, id,
		      GDI_CUSTOM_TYPE_ID, i,
		      GDI_INFO_TEXT, scrollbar_info[i].infotext,
		      GDI_X, scrollbar_info[i].x,
		      GDI_Y, scrollbar_info[i].y,
		      GDI_WIDTH, scrollbar_info[i].width,
		      GDI_HEIGHT, scrollbar_info[i].height,
		      GDI_TYPE, scrollbar_info[i].type,
		      GDI_SCROLLBAR_ITEMS_MAX, items_max,
		      GDI_SCROLLBAR_ITEMS_VISIBLE, items_visible,
		      GDI_SCROLLBAR_ITEM_POSITION, item_position,
		      GDI_STATE, GD_BUTTON_UNPRESSED,
		      GDI_DESIGN_UNPRESSED, gd_bitmap, gd_x1, gd_y1,
		      GDI_DESIGN_PRESSED, gd_bitmap, gd_x2, gd_y2,
		      GDI_BORDER_SIZE, ED_BORDER_SIZE, ED_BORDER_SIZE,
		      GDI_EVENT_MASK, event_mask,
		      GDI_CALLBACK_INFO, HandleEditorGadgetInfoText,
		      GDI_CALLBACK_ACTION, HandleControlButtons,
		      GDI_END);

    if (gi == NULL)
      Error(ERR_EXIT, "cannot create gadget");

    level_editor_gadget[id] = gi;
  }
}

static void CreateCheckbuttonGadgets()
{
  Bitmap *gd_bitmap = graphic_info[IMG_GLOBAL_DOOR].bitmap;
  struct GadgetInfo *gi;
  unsigned long event_mask;
  int gd_x1, gd_x2, gd_x3, gd_x4, gd_y;
  int i;

  event_mask = GD_EVENT_PRESSED;

  gd_x1 = DOOR_GFX_PAGEX4 + ED_CHECKBUTTON_UNCHECKED_XPOS;
  gd_x2 = DOOR_GFX_PAGEX3 + ED_CHECKBUTTON_UNCHECKED_XPOS;
  gd_x3 = DOOR_GFX_PAGEX4 + ED_CHECKBUTTON_CHECKED_XPOS;
  gd_x4 = DOOR_GFX_PAGEX3 + ED_CHECKBUTTON_CHECKED_XPOS;
  gd_y  = DOOR_GFX_PAGEY1 + ED_RADIOBUTTON_YPOS;

  for (i=0; i<ED_NUM_CHECKBUTTONS; i++)
  {
    int id = checkbutton_info[i].gadget_id;
    int x = SX + checkbutton_info[i].x;
    int y = SY + checkbutton_info[i].y;

    if (id == GADGET_ID_STICK_ELEMENT)
      gd_y  = DOOR_GFX_PAGEY1 + ED_STICKYBUTTON_YPOS;
    else
      gd_y  = DOOR_GFX_PAGEY1 + ED_CHECKBUTTON_YPOS;

    /* determine horizontal position to the right of specified gadget */
    if (checkbutton_info[i].gadget_id_align != GADGET_ID_NONE)
      x = (right_gadget_border[checkbutton_info[i].gadget_id_align] +
	   ED_GADGET_TEXT_DISTANCE);

    /* determine horizontal offset for leading text */
    if (checkbutton_info[i].text_left != NULL)
      x += getTextWidthForGadget(checkbutton_info[i].text_left);

    gi = CreateGadget(GDI_CUSTOM_ID, id,
		      GDI_CUSTOM_TYPE_ID, i,
		      GDI_INFO_TEXT, checkbutton_info[i].infotext,
		      GDI_X, x,
		      GDI_Y, y,
		      GDI_WIDTH, ED_CHECKBUTTON_XSIZE,
		      GDI_HEIGHT, ED_CHECKBUTTON_YSIZE,
		      GDI_TYPE, GD_TYPE_CHECK_BUTTON,
		      GDI_CHECKED, *checkbutton_info[i].value,
		      GDI_DESIGN_UNPRESSED, gd_bitmap, gd_x1, gd_y,
		      GDI_DESIGN_PRESSED, gd_bitmap, gd_x2, gd_y,
		      GDI_ALT_DESIGN_UNPRESSED, gd_bitmap, gd_x3, gd_y,
		      GDI_ALT_DESIGN_PRESSED, gd_bitmap, gd_x4, gd_y,
		      GDI_EVENT_MASK, event_mask,
		      GDI_CALLBACK_INFO, HandleEditorGadgetInfoText,
		      GDI_CALLBACK_ACTION, HandleCheckbuttons,
		      GDI_END);

    if (gi == NULL)
      Error(ERR_EXIT, "cannot create gadget");

    level_editor_gadget[id] = gi;
    right_gadget_border[id] =
      getRightGadgetBorder(gi, checkbutton_info[i].text_right);
  }
}

static void CreateRadiobuttonGadgets()
{
  Bitmap *gd_bitmap = graphic_info[IMG_GLOBAL_DOOR].bitmap;
  struct GadgetInfo *gi;
  unsigned long event_mask;
  int gd_x1, gd_x2, gd_x3, gd_x4, gd_y;
  int i;

  event_mask = GD_EVENT_PRESSED;

  gd_x1 = DOOR_GFX_PAGEX4 + ED_CHECKBUTTON_UNCHECKED_XPOS;
  gd_x2 = DOOR_GFX_PAGEX3 + ED_CHECKBUTTON_UNCHECKED_XPOS;
  gd_x3 = DOOR_GFX_PAGEX4 + ED_CHECKBUTTON_CHECKED_XPOS;
  gd_x4 = DOOR_GFX_PAGEX3 + ED_CHECKBUTTON_CHECKED_XPOS;
  gd_y  = DOOR_GFX_PAGEY1 + ED_RADIOBUTTON_YPOS;

  for (i=0; i<ED_NUM_RADIOBUTTONS; i++)
  {
    int id = radiobutton_info[i].gadget_id;
    int x = SX + radiobutton_info[i].x;
    int y = SY + radiobutton_info[i].y;

    int checked =
      (*radiobutton_info[i].value == radiobutton_info[i].checked_value);

    /* determine horizontal position to the right of specified gadget */
    if (radiobutton_info[i].gadget_id_align != GADGET_ID_NONE)
      x = (right_gadget_border[radiobutton_info[i].gadget_id_align] +
	   ED_GADGET_TEXT_DISTANCE);

    /* determine horizontal offset for leading text */
    if (radiobutton_info[i].text_left != NULL)
      x += getTextWidthForGadget(radiobutton_info[i].text_left);

    gi = CreateGadget(GDI_CUSTOM_ID, id,
		      GDI_CUSTOM_TYPE_ID, i,
		      GDI_INFO_TEXT, radiobutton_info[i].infotext,
		      GDI_X, x,
		      GDI_Y, y,
		      GDI_WIDTH, ED_CHECKBUTTON_XSIZE,
		      GDI_HEIGHT, ED_CHECKBUTTON_YSIZE,
		      GDI_TYPE, GD_TYPE_RADIO_BUTTON,
		      GDI_RADIO_NR, radiobutton_info[i].radio_button_nr,
		      GDI_CHECKED, checked,
		      GDI_DESIGN_UNPRESSED, gd_bitmap, gd_x1, gd_y,
		      GDI_DESIGN_PRESSED, gd_bitmap, gd_x2, gd_y,
		      GDI_ALT_DESIGN_UNPRESSED, gd_bitmap, gd_x3, gd_y,
		      GDI_ALT_DESIGN_PRESSED, gd_bitmap, gd_x4, gd_y,
		      GDI_EVENT_MASK, event_mask,
		      GDI_CALLBACK_INFO, HandleEditorGadgetInfoText,
		      GDI_CALLBACK_ACTION, HandleRadiobuttons,
		      GDI_END);

    if (gi == NULL)
      Error(ERR_EXIT, "cannot create gadget");

    level_editor_gadget[id] = gi;
    right_gadget_border[id] =
      getRightGadgetBorder(gi, radiobutton_info[i].text_right);
  }
}

void CreateLevelEditorGadgets()
{
  int old_game_status = game_status;

  /* setting 'game_status' is needed to get the right fonts for the editor */
  game_status = GAME_MODE_EDITOR;

  ReinitializeElementList();

  CreateControlButtons();
  CreateScrollbarGadgets();

  /* order of function calls is important because of cross-references */
  CreateCheckbuttonGadgets();
  CreateCounterButtons();
  CreateRadiobuttonGadgets();
  CreateTextInputGadgets();
  CreateTextAreaGadgets();
  CreateSelectboxGadgets();
  CreateGraphicbuttonGadgets();
  CreateTextbuttonGadgets();
  CreateDrawingAreas();

  game_status = old_game_status;
}

void FreeLevelEditorGadgets()
{
  int i;

  for (i=0; i<NUM_EDITOR_GADGETS; i++)
    FreeGadget(level_editor_gadget[i]);
}

static void MapCounterButtons(int id)
{
  int gadget_id_down = counterbutton_info[id].gadget_id_down;
  int gadget_id_up   = counterbutton_info[id].gadget_id_up;
  struct GadgetInfo *gi_down = level_editor_gadget[gadget_id_down];
  struct GadgetInfo *gi_up   = level_editor_gadget[gadget_id_up];
#if 0
  char infotext[MAX_OUTPUT_LINESIZE + 1];
  int max_infotext_len = getMaxInfoTextLength();
  int xoffset_left = 0;
  int yoffset_left = ED_BORDER_SIZE;
  int xoffset_right = getCounterGadgetWidth();
  int yoffset_right = ED_BORDER_SIZE;
#else
  int xoffset_left = getTextWidthForGadget(counterbutton_info[id].text_left);
  int xoffset_right = ED_GADGET_TEXT_DISTANCE;
  int yoffset_above = MINI_TILEX + ED_GADGET_DISTANCE;
  int yoffset = ED_BORDER_SIZE;
  int x_left = gi_down->x - xoffset_left;
  int x_right = gi_up->x + gi_up->width + xoffset_right;
  int y_above = gi_down->y - yoffset_above;
  int x = gi_down->x;
  int y = gi_up->y + yoffset;
#endif

  if (counterbutton_info[id].text_above)
    DrawText(x, y_above, counterbutton_info[id].text_above, FONT_TEXT_1);

  if (counterbutton_info[id].text_left)
    DrawText(x_left, y, counterbutton_info[id].text_left, FONT_TEXT_1);

  if (counterbutton_info[id].text_right)
    DrawText(x_right, y, counterbutton_info[id].text_right, FONT_TEXT_1);

  ModifyEditorCounter(id, *counterbutton_info[id].value);

  MapGadget(level_editor_gadget[counterbutton_info[id].gadget_id_down]);
  MapGadget(level_editor_gadget[counterbutton_info[id].gadget_id_text]);
  MapGadget(level_editor_gadget[counterbutton_info[id].gadget_id_up]);
}

static void MapControlButtons()
{
  int counter_id;
  int i;

  /* map toolbox buttons */
  for (i=0; i<ED_NUM_CTRL_BUTTONS; i++)
    MapGadget(level_editor_gadget[i]);

  /* map buttons to select elements */
  for (i=0; i<ED_NUM_ELEMENTLIST_BUTTONS; i++)
    MapGadget(level_editor_gadget[GADGET_ID_ELEMENTLIST_FIRST + i]);
  MapGadget(level_editor_gadget[GADGET_ID_SCROLL_LIST_VERTICAL]);
  MapGadget(level_editor_gadget[GADGET_ID_SCROLL_LIST_UP]);
  MapGadget(level_editor_gadget[GADGET_ID_SCROLL_LIST_DOWN]);

  /* map buttons to select level */
  counter_id = ED_COUNTER_ID_SELECT_LEVEL;
  ModifyEditorCounterLimits(counter_id,
			    leveldir_current->first_level,
			    leveldir_current->last_level);
  MapCounterButtons(counter_id);
}

static void MapDrawingArea(int id)
{
  struct GadgetInfo *gi = level_editor_gadget[drawingarea_info[id].gadget_id];
  int area_xsize = gi->drawing.area_xsize;
  int area_ysize = gi->drawing.area_ysize;
  int xoffset_left= getTextWidthForDrawingArea(drawingarea_info[id].text_left);
  int xoffset_below= getTextWidth(drawingarea_info[id].text_below,FONT_TEXT_1);
  int x_left  = gi->x - xoffset_left;
  int x_right = gi->x + gi->width + ED_DRAWINGAREA_TEXT_DISTANCE;
  int x_below = gi->x + (gi->width - xoffset_below) / 2;
  int y_side  = gi->y + (gi->height - getFontHeight(FONT_TEXT_1)) / 2;
  int y_below = gi->y + gi->height + ED_DRAWINGAREA_TEXT_DISTANCE;

  if (drawingarea_info[id].text_left)
    DrawText(x_left, y_side, drawingarea_info[id].text_left, FONT_TEXT_1);

  if (drawingarea_info[id].text_right)
    DrawText(x_right, y_side, drawingarea_info[id].text_right, FONT_TEXT_1);

  if (drawingarea_info[id].text_below)
    DrawText(x_below, y_below, drawingarea_info[id].text_below, FONT_TEXT_1);

  if (id != ED_DRAWING_ID_DRAWING_LEVEL)
  {
    DrawElementBorder(gi->x, gi->y,
		      area_xsize * MINI_TILEX, area_ysize * MINI_TILEY, TRUE);

    DrawDrawingArea(id);
  }

  MapGadget(gi);
}

static void MapTextInputGadget(int id)
{
  struct GadgetInfo *gi = level_editor_gadget[textinput_info[id].gadget_id];
  int xoffset_above = 0;
  int yoffset_above = -(MINI_TILEX + ED_GADGET_DISTANCE);
  int x_above = textinput_info[id].x + xoffset_above;
  int y_above = textinput_info[id].y + yoffset_above;

  if (textinput_info[id].text_above)
    DrawTextF(x_above, y_above, FONT_TEXT_1, textinput_info[id].text_above);

  ModifyGadget(gi, GDI_TEXT_VALUE, textinput_info[id].value, GDI_END);

  MapGadget(gi);
}

static void MapTextAreaGadget(int id)
{
  struct GadgetInfo *gi = level_editor_gadget[textarea_info[id].gadget_id];
  int xoffset_above = 0;
  int yoffset_above = -(MINI_TILEX + ED_GADGET_DISTANCE);
  int x_above = textarea_info[id].x + xoffset_above;
  int y_above = textarea_info[id].y + yoffset_above;

  if (textarea_info[id].text_above)
    DrawTextF(x_above, y_above, FONT_TEXT_1, textarea_info[id].text_above);

  ModifyGadget(gi, GDI_TEXT_VALUE, textarea_info[id].value, GDI_END);

  MapGadget(gi);
}

static void MapSelectboxGadget(int id)
{
  struct GadgetInfo *gi = level_editor_gadget[selectbox_info[id].gadget_id];
  int xoffset_left = getTextWidthForGadget(selectbox_info[id].text_left);
  int xoffset_right = ED_GADGET_TEXT_DISTANCE;
  int yoffset = ED_BORDER_SIZE;
  int x_left = gi->x - xoffset_left;
  int x_right = gi->x + gi->width + xoffset_right;
  int y = gi->y + yoffset;

  if (selectbox_info[id].text_left)
    DrawText(x_left, y, selectbox_info[id].text_left, FONT_TEXT_1);

  if (selectbox_info[id].text_right)
    DrawText(x_right, y, selectbox_info[id].text_right, FONT_TEXT_1);

  ModifyEditorSelectbox(id, *selectbox_info[id].value);

  MapGadget(gi);
}

static void MapTextbuttonGadget(int id)
{
  struct GadgetInfo *gi = level_editor_gadget[textbutton_info[id].gadget_id];
  int xoffset_left = getTextWidthForGadget(textbutton_info[id].text_left);
  int xoffset_right = ED_GADGET_TEXT_DISTANCE;
  int yoffset = ED_BORDER_SIZE;
  int x_left = gi->x - xoffset_left;
  int x_right = gi->x + gi->width + xoffset_right;
  int y = gi->y + yoffset;

  /* only show button to delete change pages when more than minimum pages */
  if (id == ED_TEXTBUTTON_ID_DEL_CHANGE_PAGE &&
      custom_element.num_change_pages == MIN_CHANGE_PAGES)
    return;

  if (textbutton_info[id].text_left)
    DrawText(x_left, y, textbutton_info[id].text_left, FONT_TEXT_1);

  if (textbutton_info[id].text_right)
    DrawText(x_right, y, textbutton_info[id].text_right, FONT_TEXT_1);

  MapGadget(gi);
}

static void MapGraphicbuttonGadget(int id)
{
  struct GadgetInfo *gi= level_editor_gadget[graphicbutton_info[id].gadget_id];
  int xoffset_left = getTextWidthForGadget(graphicbutton_info[id].text_left);
  int xoffset_right = ED_GADGET_TEXT_DISTANCE;
  int yoffset = ED_BORDER_SIZE;
  int x_left = gi->x - xoffset_left;
  int x_right = gi->x + gi->width + xoffset_right;
  int y = gi->y + yoffset;

  if (graphicbutton_info[id].text_left)
    DrawText(x_left, y, graphicbutton_info[id].text_left, FONT_TEXT_1);

  if (graphicbutton_info[id].text_right)
    DrawText(x_right, y, graphicbutton_info[id].text_right, FONT_TEXT_1);

  MapGadget(gi);
}

static void MapRadiobuttonGadget(int id)
{
  struct GadgetInfo *gi = level_editor_gadget[radiobutton_info[id].gadget_id];
  int xoffset_left = getTextWidthForGadget(checkbutton_info[id].text_left);
  int xoffset_right = ED_GADGET_TEXT_DISTANCE;
  int yoffset = ED_BORDER_SIZE;
  int x_left = gi->x - xoffset_left;
  int x_right = gi->x + gi->width + xoffset_right;
  int y = gi->y + yoffset;
  boolean checked =
    (*radiobutton_info[id].value == radiobutton_info[id].checked_value);

  if (radiobutton_info[id].text_left)
    DrawText(x_left, y, radiobutton_info[id].text_left, FONT_TEXT_1);

  if (radiobutton_info[id].text_right)
    DrawText(x_right, y, radiobutton_info[id].text_right, FONT_TEXT_1);

  ModifyGadget(gi, GDI_CHECKED, checked, GDI_END);

  MapGadget(gi);
}

static void MapCheckbuttonGadget(int id)
{
  struct GadgetInfo *gi = level_editor_gadget[checkbutton_info[id].gadget_id];
  int xoffset_left = getTextWidthForGadget(checkbutton_info[id].text_left);
  int xoffset_right = ED_GADGET_TEXT_DISTANCE;
  int yoffset = ED_BORDER_SIZE;
  int x_left = gi->x - xoffset_left;
  int x_right = gi->x + gi->width + xoffset_right;
  int y = gi->y + yoffset;

  /* special case needed for "sticky" gadget */
  ModifyGadget(gi, GDI_CHECKED, *checkbutton_info[id].value,
	       GDI_Y, SY + checkbutton_info[id].y, GDI_END);
  y = gi->y + yoffset;

  if (checkbutton_info[id].text_left)
    DrawText(x_left, y, checkbutton_info[id].text_left, FONT_TEXT_1);

  if (checkbutton_info[id].text_right)
    DrawText(x_right, y, checkbutton_info[id].text_right, FONT_TEXT_1);

  MapGadget(gi);
}

static void MapMainDrawingArea()
{
  boolean no_horizontal_scrollbar = (lev_fieldx + 2 <= ed_fieldx);
  boolean no_vertical_scrollbar = (lev_fieldy + 2 <= ed_fieldy);
  int i;

  for (i=ED_SCROLLBUTTON_ID_AREA_FIRST; i<=ED_SCROLLBUTTON_ID_AREA_LAST; i++)
  {
    if (((i == ED_SCROLLBUTTON_ID_AREA_LEFT ||
	  i == ED_SCROLLBUTTON_ID_AREA_RIGHT) &&
	 no_horizontal_scrollbar) ||
	((i == ED_SCROLLBUTTON_ID_AREA_UP ||
	  i == ED_SCROLLBUTTON_ID_AREA_DOWN) &&
	 no_vertical_scrollbar))
      continue;

    MapGadget(level_editor_gadget[scrollbutton_info[i].gadget_id]);
  }

  for (i=ED_SCROLLBAR_ID_AREA_FIRST; i<=ED_SCROLLBAR_ID_AREA_LAST; i++)
  {
    if ((i == ED_SCROLLBAR_ID_AREA_HORIZONTAL && no_horizontal_scrollbar) ||
	(i == ED_SCROLLBAR_ID_AREA_VERTICAL && no_vertical_scrollbar))
      continue;

    MapGadget(level_editor_gadget[scrollbar_info[i].gadget_id]);
  }

  MapDrawingArea(ED_DRAWING_ID_DRAWING_LEVEL);
}

static void UnmapDrawingArea(int id)
{
  UnmapGadget(level_editor_gadget[id]);
}

void UnmapLevelEditorWindowGadgets()
{
  int i;

  for (i=0; i<NUM_EDITOR_GADGETS; i++)
    if (level_editor_gadget[i]->x < SX + SXSIZE)
      UnmapGadget(level_editor_gadget[i]);
}

void UnmapLevelEditorGadgets()
{
  int i;

  for (i=0; i<NUM_EDITOR_GADGETS; i++)
    UnmapGadget(level_editor_gadget[i]);
}

static void ResetUndoBuffer()
{
  undo_buffer_position = -1;
  undo_buffer_steps = -1;
  CopyLevelToUndoBuffer(UNDO_IMMEDIATE);
}

static void DrawEditModeWindow()
{
  ModifyEditorElementList();
  RedrawDrawingElements();

  if (edit_mode == ED_MODE_INFO)
    DrawLevelInfoWindow();
  else if (edit_mode == ED_MODE_PROPERTIES)
    DrawPropertiesWindow();
  else	/* edit_mode == ED_MODE_DRAWING */
    DrawDrawingWindow();
}

static boolean LevelChanged()
{
  boolean level_changed = FALSE;
  int x, y;

  for(y=0; y<lev_fieldy; y++) 
    for(x=0; x<lev_fieldx; x++)
      if (Feld[x][y] != level.field[x][y])
	level_changed = TRUE;

  return level_changed;
}

static boolean LevelContainsPlayer()
{
  boolean player_found = FALSE;
  int x, y;

  for(y=0; y<lev_fieldy; y++) 
    for(x=0; x<lev_fieldx; x++)
      if (Feld[x][y] == EL_PLAYER_1 ||
	  Feld[x][y] == EL_SP_MURPHY) 
	player_found = TRUE;

  return player_found;
}

static void CopyPlayfield(short src[MAX_LEV_FIELDX][MAX_LEV_FIELDY],
			  short dst[MAX_LEV_FIELDX][MAX_LEV_FIELDY])
{
  int x, y;

  for(x=0; x<lev_fieldx; x++)
    for(y=0; y<lev_fieldy; y++) 
      dst[x][y] = src[x][y];
}

static int setSelectboxValue(int selectbox_id, int new_value)
{
  int new_index_value = 0;
  int i;

  for(i=0; selectbox_info[selectbox_id].options[i].text != NULL; i++)
    if (selectbox_info[selectbox_id].options[i].value == new_value)
      new_index_value = i;

  *selectbox_info[selectbox_id].value =
    selectbox_info[selectbox_id].options[new_index_value].value;

  return new_index_value;
}

static void CopyCustomElementPropertiesToEditor(int element)
{
  int i;
  int current_change_page = element_info[element].current_change_page;

  /* dynamically (re)build selectbox for selecting change page */
  for (i=0; i < element_info[element].num_change_pages; i++)
  {
    sprintf(options_change_page_strings[i], "%d", i + 1);

    options_change_page[i].value = i;
    options_change_page[i].text = options_change_page_strings[i];
  }

  options_change_page[i].value = -1;
  options_change_page[i].text = NULL;

  /* needed here to initialize combined element properties */
  InitElementPropertiesEngine(level.game_version);

  element_info[element].change =
    &element_info[element].change_page[current_change_page];

  custom_element = element_info[element];
  custom_element_change = *element_info[element].change;

  /* needed to initially set selectbox value variables to reliable defaults */
  for (i=0; i < ED_NUM_SELECTBOX; i++)
    setSelectboxValue(i, *selectbox_info[i].value);

  for (i=0; i < NUM_ELEMENT_PROPERTIES; i++)
    custom_element_properties[i] = HAS_PROPERTY(element, i);

  for (i=0; i < NUM_CHANGE_EVENTS; i++)
    custom_element_change_events[i] = HAS_CHANGE_EVENT(element, i);

  /* ---------- element settings: configure (custom elements) ------------- */

  /* set accessible layer selectbox help value */
  custom_element.access_type =
    (IS_WALKABLE(element) ? EP_WALKABLE :
     IS_PASSABLE(element) ? EP_PASSABLE :
     custom_element.access_type);
  custom_element.access_layer =
    (IS_ACCESSIBLE_OVER(element) ? EP_ACCESSIBLE_OVER :
     IS_ACCESSIBLE_INSIDE(element) ? EP_ACCESSIBLE_INSIDE :
     IS_ACCESSIBLE_UNDER(element) ? EP_ACCESSIBLE_UNDER :
     custom_element.access_layer);
  custom_element_properties[EP_ACCESSIBLE] =
    (IS_ACCESSIBLE_OVER(element) ||
     IS_ACCESSIBLE_INSIDE(element) ||
     IS_ACCESSIBLE_UNDER(element));

  /* set walk-to-object action selectbox help value */
  custom_element.walk_to_action =
    (IS_DIGGABLE(element) ? EP_DIGGABLE :
     IS_COLLECTIBLE_ONLY(element) ? EP_COLLECTIBLE_ONLY :
     IS_DROPPABLE(element) ? EP_DROPPABLE :
     IS_PUSHABLE(element) ? EP_PUSHABLE :
     custom_element.walk_to_action);
  custom_element_properties[EP_WALK_TO_OBJECT] =
    (IS_DIGGABLE(element) ||
     IS_COLLECTIBLE_ONLY(element) ||
     IS_DROPPABLE(element) ||
     IS_PUSHABLE(element));

  /* set smash targets selectbox help value */
  custom_element.smash_targets =
    (CAN_SMASH_EVERYTHING(element) ? EP_CAN_SMASH_EVERYTHING :
     CAN_SMASH_ENEMIES(element) ? EP_CAN_SMASH_ENEMIES :
     CAN_SMASH_PLAYER(element) ? EP_CAN_SMASH_PLAYER :
     custom_element.smash_targets);
  custom_element_properties[EP_CAN_SMASH] =
    (CAN_SMASH_EVERYTHING(element) ||
     CAN_SMASH_ENEMIES(element) ||
     CAN_SMASH_PLAYER(element));

  /* set deadliness selectbox help value */
  custom_element.deadliness =
    (DONT_TOUCH(element) ? EP_DONT_TOUCH :
     DONT_COLLIDE_WITH(element) ? EP_DONT_COLLIDE_WITH :
     DONT_RUN_INTO(element) ? EP_DONT_RUN_INTO :
     custom_element.deadliness);
  custom_element_properties[EP_DEADLY] =
    (DONT_TOUCH(element) ||
     DONT_COLLIDE_WITH(element) ||
     DONT_RUN_INTO(element));

  /* set consistency selectbox help value */
  custom_element.consistency =
    (IS_INDESTRUCTIBLE(element) ? EP_INDESTRUCTIBLE :
     CAN_EXPLODE_1X1(element) ? EP_CAN_EXPLODE_1X1 :
     CAN_EXPLODE_3X3(element) ? EP_CAN_EXPLODE_3X3 :
     custom_element.consistency);
  custom_element_properties[EP_EXPLODE_RESULT] =
    (IS_INDESTRUCTIBLE(element) ||
     CAN_EXPLODE_1X1(element) ||
     CAN_EXPLODE_3X3(element));

  /* special case: sub-settings dependent from main setting */
  if (CAN_EXPLODE_BY_FIRE(element))
    custom_element.can_explode_by_fire = TRUE;
  if (CAN_EXPLODE_SMASHED(element))
    custom_element.can_explode_smashed = TRUE;
  if (CAN_EXPLODE_IMPACT(element))
    custom_element.can_explode_impact  = TRUE;

  /* ---------- element settings: advanced (custom elements) --------------- */

  /* set "change by direct action" selectbox help value */
  custom_element_change.direct_action =
    (HAS_CHANGE_EVENT(element, CE_TOUCHED_BY_PLAYER) ? CE_TOUCHED_BY_PLAYER :
     HAS_CHANGE_EVENT(element, CE_PRESSED_BY_PLAYER) ? CE_PRESSED_BY_PLAYER :
     HAS_CHANGE_EVENT(element, CE_PUSHED_BY_PLAYER) ? CE_PUSHED_BY_PLAYER :
     HAS_CHANGE_EVENT(element, CE_ENTERED_BY_PLAYER) ? CE_ENTERED_BY_PLAYER :
     HAS_CHANGE_EVENT(element, CE_LEFT_BY_PLAYER) ? CE_LEFT_BY_PLAYER :
     HAS_CHANGE_EVENT(element, CE_DROPPED_BY_PLAYER) ? CE_DROPPED_BY_PLAYER :
     HAS_CHANGE_EVENT(element, CE_COLLISION) ? CE_COLLISION :
     HAS_CHANGE_EVENT(element, CE_IMPACT) ? CE_IMPACT :
     HAS_CHANGE_EVENT(element, CE_SMASHED) ? CE_SMASHED :
     custom_element_change.direct_action);

  /* set "change by other element action" selectbox help value */
  custom_element_change.other_action =
    (HAS_CHANGE_EVENT(element, CE_OTHER_GETS_TOUCHED) ? CE_OTHER_GETS_TOUCHED :
     HAS_CHANGE_EVENT(element, CE_OTHER_GETS_PRESSED) ? CE_OTHER_GETS_PRESSED :
     HAS_CHANGE_EVENT(element, CE_OTHER_GETS_PUSHED) ? CE_OTHER_GETS_PUSHED :
     HAS_CHANGE_EVENT(element, CE_OTHER_GETS_ENTERED) ? CE_OTHER_GETS_ENTERED :
     HAS_CHANGE_EVENT(element, CE_OTHER_GETS_LEFT) ? CE_OTHER_GETS_LEFT :
     HAS_CHANGE_EVENT(element, CE_OTHER_GETS_DIGGED) ? CE_OTHER_GETS_DIGGED :
     HAS_CHANGE_EVENT(element, CE_OTHER_GETS_COLLECTED) ? CE_OTHER_GETS_COLLECTED :
     HAS_CHANGE_EVENT(element, CE_OTHER_GETS_DROPPED) ? CE_OTHER_GETS_DROPPED :
     HAS_CHANGE_EVENT(element, CE_OTHER_IS_TOUCHING) ? CE_OTHER_IS_TOUCHING :
     HAS_CHANGE_EVENT(element, CE_OTHER_IS_CHANGING) ? CE_OTHER_IS_CHANGING :
     HAS_CHANGE_EVENT(element, CE_OTHER_IS_EXPLODING) ? CE_OTHER_IS_EXPLODING :
     custom_element_change.other_action);
}

static void CopyCustomElementPropertiesToGame(int element)
{
  int i;
  int access_type_and_layer;

  /* mark that this custom element has been modified */
  custom_element.modified_settings = TRUE;

  if (level.use_custom_template)
  {
    if (Request("Copy and modify level tem- plate ?", REQ_ASK))
    {
      level.use_custom_template = FALSE;
      ModifyGadget(level_editor_gadget[GADGET_ID_CUSTOM_USE_TEMPLATE],
		   GDI_CHECKED, FALSE, GDI_END);
    }
    else
    {
      LoadLevelTemplate(-1);	/* this resets all element modifications ... */

      DrawEditModeWindow();	/* ... and copies them to 'custom_element' */
    }
  }

  element_info[element] = custom_element;
  *element_info[element].change = custom_element_change;

  /* ---------- element settings: configure (custom elements) ------------- */

  /* set accessible property from checkbox and selectbox */
  custom_element_properties[EP_WALKABLE_OVER] = FALSE;
  custom_element_properties[EP_WALKABLE_INSIDE] = FALSE;
  custom_element_properties[EP_WALKABLE_UNDER] = FALSE;
  custom_element_properties[EP_PASSABLE_OVER] = FALSE;
  custom_element_properties[EP_PASSABLE_INSIDE] = FALSE;
  custom_element_properties[EP_PASSABLE_UNDER] = FALSE;
  access_type_and_layer = ((custom_element.access_type == EP_WALKABLE ?
			    EP_WALKABLE_OVER : EP_PASSABLE_OVER) +
			   (custom_element.access_layer - EP_ACCESSIBLE_OVER));
  custom_element_properties[access_type_and_layer] =
    custom_element_properties[EP_ACCESSIBLE];

  /* set walk-to-object property from checkbox and selectbox */
  custom_element_properties[EP_DIGGABLE] = FALSE;
  custom_element_properties[EP_COLLECTIBLE_ONLY] = FALSE;
  custom_element_properties[EP_DROPPABLE] = FALSE;
  custom_element_properties[EP_PUSHABLE] = FALSE;
  custom_element_properties[custom_element.walk_to_action] =
    custom_element_properties[EP_WALK_TO_OBJECT];

  /* set smash property from checkbox and selectbox */
  custom_element_properties[EP_CAN_SMASH_PLAYER] = FALSE;
  custom_element_properties[EP_CAN_SMASH_ENEMIES] = FALSE;
  custom_element_properties[EP_CAN_SMASH_EVERYTHING] = FALSE;
  custom_element_properties[custom_element.smash_targets] =
    custom_element_properties[EP_CAN_SMASH];

  /* set deadliness property from checkbox and selectbox */
  custom_element_properties[EP_DONT_RUN_INTO] = FALSE;
  custom_element_properties[EP_DONT_COLLIDE_WITH] = FALSE;
  custom_element_properties[EP_DONT_TOUCH] = FALSE;
  custom_element_properties[custom_element.deadliness] =
    custom_element_properties[EP_DEADLY];

  /* set consistency property from checkbox and selectbox */
  custom_element_properties[EP_INDESTRUCTIBLE] = FALSE;
  custom_element_properties[EP_CAN_EXPLODE_1X1] = FALSE;
  custom_element_properties[EP_CAN_EXPLODE_3X3] = FALSE;
  custom_element_properties[EP_CAN_EXPLODE_BY_FIRE] = FALSE;
  custom_element_properties[EP_CAN_EXPLODE_SMASHED] = FALSE;
  custom_element_properties[EP_CAN_EXPLODE_IMPACT] = FALSE;
  custom_element_properties[custom_element.consistency] =
    custom_element_properties[EP_EXPLODE_RESULT];

  /* special case: sub-settings dependent from main setting */
  if (custom_element_properties[EP_CAN_EXPLODE_3X3] ||
      custom_element_properties[EP_CAN_EXPLODE_1X1])
  {
    custom_element_properties[EP_CAN_EXPLODE_BY_FIRE] =
      custom_element.can_explode_by_fire;
    custom_element_properties[EP_CAN_EXPLODE_SMASHED] =
      custom_element.can_explode_smashed;
    custom_element_properties[EP_CAN_EXPLODE_IMPACT] =
      custom_element.can_explode_impact;
  }

  /* ---------- element settings: advanced (custom elements) --------------- */

  /* set player change event from checkbox and selectbox */
  custom_element_change_events[CE_TOUCHED_BY_PLAYER] = FALSE;
  custom_element_change_events[CE_PRESSED_BY_PLAYER] = FALSE;
  custom_element_change_events[CE_PUSHED_BY_PLAYER] = FALSE;
  custom_element_change_events[CE_ENTERED_BY_PLAYER] = FALSE;
  custom_element_change_events[CE_LEFT_BY_PLAYER] = FALSE;
  custom_element_change_events[CE_DROPPED_BY_PLAYER] = FALSE;
  custom_element_change_events[CE_COLLISION] = FALSE;
  custom_element_change_events[CE_IMPACT] = FALSE;
  custom_element_change_events[CE_SMASHED] = FALSE;
  custom_element_change_events[custom_element_change.direct_action] =
    custom_element_change_events[CE_BY_DIRECT_ACTION];

  /* set other element action change event from checkbox and selectbox */
  custom_element_change_events[CE_OTHER_GETS_TOUCHED] = FALSE;
  custom_element_change_events[CE_OTHER_GETS_PRESSED] = FALSE;
  custom_element_change_events[CE_OTHER_GETS_PUSHED] = FALSE;
  custom_element_change_events[CE_OTHER_GETS_ENTERED] = FALSE;
  custom_element_change_events[CE_OTHER_GETS_LEFT] = FALSE;
  custom_element_change_events[CE_OTHER_GETS_DIGGED] = FALSE;
  custom_element_change_events[CE_OTHER_GETS_COLLECTED] = FALSE;
  custom_element_change_events[CE_OTHER_GETS_DROPPED] = FALSE;
  custom_element_change_events[CE_OTHER_IS_TOUCHING] = FALSE;
  custom_element_change_events[CE_OTHER_IS_CHANGING] = FALSE;
  custom_element_change_events[CE_OTHER_IS_EXPLODING] = FALSE;
  custom_element_change_events[custom_element_change.other_action] =
    custom_element_change_events[CE_BY_OTHER_ACTION];

  for (i=0; i < NUM_ELEMENT_PROPERTIES; i++)
    SET_PROPERTY(element, i, custom_element_properties[i]);

  for (i=0; i < NUM_CHANGE_EVENTS; i++)
    SET_CHANGE_EVENT(element, i, custom_element_change_events[i]);

  /* copy change events also to special level editor variable */
  custom_element = element_info[element];
  custom_element_change = *element_info[element].change;
}

void DrawLevelEd()
{
  CloseDoor(DOOR_CLOSE_ALL);
  OpenDoor(DOOR_OPEN_2 | DOOR_NO_DELAY);

  if (level_editor_test_game)
  {
    CopyPlayfield(level.field, Feld);
    CopyPlayfield(FieldBackup, level.field);

    level_editor_test_game = FALSE;
  }
  else
  {
    edit_mode = ED_MODE_DRAWING;
    edit_mode_properties = ED_MODE_PROPERTIES_INFO;

    ResetUndoBuffer();

    level_xpos = -1;
    level_ypos = -1;
  }

  /* copy default editor door content to main double buffer */
  BlitBitmap(graphic_info[IMG_GLOBAL_DOOR].bitmap, drawto,
	     DOOR_GFX_PAGEX6, DOOR_GFX_PAGEY1, DXSIZE, DYSIZE, DX, DY);

#if 0
  /* draw mouse button brush elements */
  RedrawDrawingElements();
#endif

  /* draw bigger door */
  DrawSpecialEditorDoor();

  /* draw new control window */
  BlitBitmap(graphic_info[IMG_GLOBAL_DOOR].bitmap, drawto,
	     DOOR_GFX_PAGEX8, 236, EXSIZE, EYSIZE, EX, EY);

  redraw_mask |= REDRAW_ALL;

  ReinitializeElementListButtons();	/* only needed after setup changes */
#if 0
  ModifyEditorElementList();		/* may be needed for custom elements */
#endif

  UnmapTapeButtons();
  MapControlButtons();

  DrawEditModeWindow();

  /* copy actual editor door content to door double buffer for OpenDoor() */
  BlitBitmap(drawto, bitmap_db_door,
	     DX, DY, DXSIZE, DYSIZE, DOOR_GFX_PAGEX1, DOOR_GFX_PAGEY1);

  OpenDoor(DOOR_OPEN_1);
}

static void AdjustDrawingAreaGadgets()
{
  int ed_xsize = lev_fieldx + 2;
  int ed_ysize = lev_fieldy + 2;
  int max_ed_fieldx = MAX_ED_FIELDX;
  int max_ed_fieldy = MAX_ED_FIELDY;
  boolean horizontal_scrollbar_needed;
  boolean vertical_scrollbar_needed;
  int x, y, width, height;
  int xoffset, yoffset;

  /* check if we need any scrollbars */
  horizontal_scrollbar_needed = (ed_xsize > max_ed_fieldx);
  vertical_scrollbar_needed = (ed_ysize > max_ed_fieldy);

  /* check if we have a smaller editor field because of scrollbars */
  if (horizontal_scrollbar_needed)
    max_ed_fieldy = MAX_ED_FIELDY - 1;
  if (vertical_scrollbar_needed)
    max_ed_fieldx = MAX_ED_FIELDX - 1;

  /* check again if we now need more scrollbars because of less space */
  horizontal_scrollbar_needed = (ed_xsize > max_ed_fieldx);
  vertical_scrollbar_needed = (ed_ysize > max_ed_fieldy);

  /* check if editor field gets even smaller after adding new scrollbars */
  if (horizontal_scrollbar_needed)
    max_ed_fieldy = MAX_ED_FIELDY - 1;
  if (vertical_scrollbar_needed)
    max_ed_fieldx = MAX_ED_FIELDX - 1;

  ed_fieldx = (ed_xsize < MAX_ED_FIELDX ? ed_xsize : max_ed_fieldx);
  ed_fieldy = (ed_ysize < MAX_ED_FIELDY ? ed_ysize : max_ed_fieldy);

  ModifyGadget(level_editor_gadget[GADGET_ID_DRAWING_LEVEL],
	       GDI_WIDTH, ed_fieldx * MINI_TILEX,
	       GDI_HEIGHT, ed_fieldy * MINI_TILEY,
	       GDI_AREA_SIZE, ed_fieldx, ed_fieldy,
	       GDI_END);

  xoffset = (ed_fieldx == MAX_ED_FIELDX ? ED_SCROLLBUTTON_XSIZE : 0);
  yoffset = (ed_fieldy == MAX_ED_FIELDY ? ED_SCROLLBUTTON_YSIZE : 0);

  x = SX + scrollbutton_info[ED_SCROLLBUTTON_ID_AREA_RIGHT].x + xoffset;
  y = SX + scrollbutton_info[ED_SCROLLBUTTON_ID_AREA_DOWN].y + yoffset;

  ModifyGadget(level_editor_gadget[GADGET_ID_SCROLL_RIGHT], GDI_X, x, GDI_END);
  ModifyGadget(level_editor_gadget[GADGET_ID_SCROLL_DOWN], GDI_Y, y, GDI_END);

  width = scrollbar_info[ED_SCROLLBAR_ID_AREA_HORIZONTAL].width + xoffset;
  height = scrollbar_info[ED_SCROLLBAR_ID_AREA_VERTICAL].height + yoffset;

  ModifyGadget(level_editor_gadget[GADGET_ID_SCROLL_HORIZONTAL],
	       GDI_WIDTH, width,
	       GDI_SCROLLBAR_ITEMS_VISIBLE, ed_fieldx,
	       GDI_END);
  ModifyGadget(level_editor_gadget[GADGET_ID_SCROLL_VERTICAL],
	       GDI_HEIGHT, height,
	       GDI_SCROLLBAR_ITEMS_VISIBLE, ed_fieldy,
	       GDI_END);
}

static void AdjustLevelScrollPosition()
{
  if (level_xpos < -1)
    level_xpos = -1;
  if (level_xpos > lev_fieldx - ed_fieldx + 1)
    level_xpos = lev_fieldx - ed_fieldx + 1;
  if (lev_fieldx < ed_fieldx - 2)
    level_xpos = -1;

  if (level_ypos < -1)
    level_ypos = -1;
  if (level_ypos > lev_fieldy - ed_fieldy + 1)
    level_ypos = lev_fieldy - ed_fieldy + 1;
  if (lev_fieldy < ed_fieldy - 2)
    level_ypos = -1;
}

static void AdjustEditorScrollbar(int id)
{
  struct GadgetInfo *gi = level_editor_gadget[id];
  int items_max, items_visible, item_position;

  if (id == GADGET_ID_SCROLL_HORIZONTAL)
  {
    items_max = MAX(lev_fieldx + 2, ed_fieldx);
    items_visible = ed_fieldx;
    item_position = level_xpos + 1;
  }
  else
  {
    items_max = MAX(lev_fieldy + 2, ed_fieldy);
    items_visible = ed_fieldy;
    item_position = level_ypos + 1;
  }

  if (item_position > items_max - items_visible)
    item_position = items_max - items_visible;

  ModifyGadget(gi, GDI_SCROLLBAR_ITEMS_MAX, items_max,
	       GDI_SCROLLBAR_ITEM_POSITION, item_position, GDI_END);
}

static void ModifyEditorCounter(int counter_id, int new_value)
{
  int *counter_value = counterbutton_info[counter_id].value;
  int gadget_id = counterbutton_info[counter_id].gadget_id_text;
  struct GadgetInfo *gi = level_editor_gadget[gadget_id];

  ModifyGadget(gi, GDI_NUMBER_VALUE, new_value, GDI_END);

  if (counter_value != NULL)
    *counter_value = gi->textinput.number_value;
}

static void ModifyEditorCounterLimits(int counter_id, int min, int max)
{
  int gadget_id = counterbutton_info[counter_id].gadget_id_text;
  struct GadgetInfo *gi = level_editor_gadget[gadget_id];

  ModifyGadget(gi, GDI_NUMBER_MIN, min, GDI_NUMBER_MAX, max, GDI_END);
}

static void ModifyEditorSelectbox(int selectbox_id, int new_value)
{
  int gadget_id = selectbox_info[selectbox_id].gadget_id;
  struct GadgetInfo *gi = level_editor_gadget[gadget_id];
  int new_index_value = setSelectboxValue(selectbox_id, new_value);

  ModifyGadget(gi, GDI_SELECTBOX_INDEX, new_index_value, GDI_END);
}

static void ModifyEditorElementList()
{
  int i;

  for (i=0; i<ED_NUM_ELEMENTLIST_BUTTONS; i++)
  {
    int gadget_id = GADGET_ID_ELEMENTLIST_FIRST + i;
    struct GadgetInfo *gi = level_editor_gadget[gadget_id];
    struct GadgetDesign *gd = &gi->deco.design;
    int element = editor_elements[element_shift + i];

    UnmapGadget(gi);
    getMiniGraphicSource(el2edimg(element), &gd->bitmap, &gd->x, &gd->y);
    ModifyGadget(gi, GDI_INFO_TEXT, getElementInfoText(element), GDI_END);
    MapGadget(gi);
  }
}

static void PickDrawingElement(int button, int element)
{
  if (button < 1 || button > 3)
    return;

  if (button == 1)
  {
    new_element1 = element;
    DrawMiniGraphicExt(drawto,
		       DX + ED_WIN_MB_LEFT_XPOS, DY + ED_WIN_MB_LEFT_YPOS,
		       el2edimg(new_element1));
  }
  else if (button == 2)
  {
    new_element2 = element;
    DrawMiniGraphicExt(drawto,
		       DX + ED_WIN_MB_MIDDLE_XPOS, DY + ED_WIN_MB_MIDDLE_YPOS,
		       el2edimg(new_element2));
  }
  else
  {
    new_element3 = element;
    DrawMiniGraphicExt(drawto,
		       DX + ED_WIN_MB_RIGHT_XPOS, DY + ED_WIN_MB_RIGHT_YPOS,
		       el2edimg(new_element3));
  }

  redraw_mask |= REDRAW_DOOR_1;
}

static void RedrawDrawingElements()
{
  PickDrawingElement(1, new_element1);
  PickDrawingElement(2, new_element2);
  PickDrawingElement(3, new_element3);
}

static void DrawDrawingWindow()
{
  stick_element_properties_window = FALSE;

  SetMainBackgroundImage(IMG_UNDEFINED);
  ClearWindow();
  UnmapLevelEditorWindowGadgets();

  AdjustDrawingAreaGadgets();
  AdjustLevelScrollPosition();
  AdjustEditorScrollbar(GADGET_ID_SCROLL_HORIZONTAL);
  AdjustEditorScrollbar(GADGET_ID_SCROLL_VERTICAL);

  DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos, level_ypos);
  MapMainDrawingArea();
}

static void DrawLevelInfoWindow()
{
  int i;

  stick_element_properties_window = FALSE;

  SetMainBackgroundImage(IMG_BACKGROUND_EDITOR);
  ClearWindow();
  UnmapLevelEditorWindowGadgets();

  DrawText(SX + ED_SETTINGS2_XPOS, SY + ED_SETTINGS1_YPOS,
	   "Level Settings", FONT_TITLE_1);
  DrawText(SX + ED_SETTINGS2_XPOS, SY + ED_SETTINGS2_YPOS,
	   "Editor Settings", FONT_TITLE_1);

  /* draw counter gadgets */
  for (i=ED_COUNTER_ID_LEVEL_FIRST; i<=ED_COUNTER_ID_LEVEL_LAST; i++)
    MapCounterButtons(i);

  /* draw checkbutton gadgets */
  for (i=ED_CHECKBUTTON_ID_LEVEL_FIRST; i<=ED_CHECKBUTTON_ID_LEVEL_LAST; i++)
    MapCheckbuttonGadget(i);

  /* draw radiobutton gadgets */
  for (i=ED_RADIOBUTTON_ID_LEVEL_FIRST; i<=ED_RADIOBUTTON_ID_LEVEL_LAST; i++)
    MapRadiobuttonGadget(i);

  /* draw text input gadgets */
  for (i=ED_TEXTINPUT_ID_LEVEL_FIRST; i<=ED_TEXTINPUT_ID_LEVEL_LAST; i++)
    MapTextInputGadget(i);

  /* draw drawing area */
  MapDrawingArea(ED_DRAWING_ID_RANDOM_BACKGROUND);
}

static void DrawCustomContentArea()
{
  int id = ED_DRAWING_ID_CUSTOM_CONTENT;
  struct GadgetInfo *gi = level_editor_gadget[drawingarea_info[id].gadget_id];
  int x1 = right_gadget_border[GADGET_ID_CUSTOM_DEADLINESS];
  int x2 = right_gadget_border[GADGET_ID_CUSTOM_CONSISTENCY];
  int x3 = right_gadget_border[GADGET_ID_CUSTOM_EXPLODE_IMPACT];
  int xoffset = ED_DRAWINGAREA_TEXT_DISTANCE;

  /* add distance for potential left text (without drawing area border) */
  x2 += getTextWidthForGadget(drawingarea_info[id].text_left);

  ModifyGadget(gi, GDI_X, MAX(x1, MAX(x2, x3)) + xoffset, GDI_END);

  MapDrawingArea(ED_DRAWING_ID_CUSTOM_CONTENT);
}

static void DrawCustomChangeContentArea()
{
  int id = ED_DRAWING_ID_CUSTOM_CHANGE_CONTENT;
  struct GadgetInfo *gi = level_editor_gadget[drawingarea_info[id].gadget_id];
  int x1 = right_gadget_border[GADGET_ID_CHANGE_USE_CONTENT];
  int x2 = right_gadget_border[GADGET_ID_CHANGE_POWER];
  int x3 = right_gadget_border[GADGET_ID_CHANGE_ONLY_COMPLETE];
  int xoffset = ED_DRAWINGAREA_TEXT_DISTANCE;

  ModifyGadget(gi, GDI_X, MAX(x1, MAX(x2, x3)) + xoffset, GDI_END);

  MapDrawingArea(id);
}

static void DrawElementContentAreas()
{
  int x = SX + ED_AREA_YAMYAM_CONTENT_XPOS(3) + 4 * MINI_TILEX;
  int y = SY + ED_AREA_YAMYAM_CONTENT_YPOS(0) + ED_BORDER_AREA_YSIZE;
  int i;

  /* display counter to choose number of element content areas */
  MapCounterButtons(ED_COUNTER_ID_ELEMENT_CONTENT);

  for (i=0; i < MAX_ELEMENT_CONTENTS; i++)
  {
    int id = ED_DRAWING_ID_ELEMENT_CONTENT_0 + i;
    int font_height = getFontHeight(FONT_TEXT_1);

    if (i < level.num_yamyam_contents)
      MapDrawingArea(id);
    else
    {
      UnmapDrawingArea(id);

      /* delete content areas in case of reducing number of them */
      DrawBackground(SX + drawingarea_info[id].x - MINI_TILEX / 2,
		     SY + drawingarea_info[id].y - MINI_TILEY / 2,
		     4 * MINI_TILEX,
		     4 * MINI_TILEX + ED_GADGET_TEXT_DISTANCE + font_height);
    }
  }

  DrawText(x, y + 0 * MINI_TILEY, "content", FONT_TEXT_1);
  DrawText(x, y + 1 * MINI_TILEY, "when",    FONT_TEXT_1);
  DrawText(x, y + 2 * MINI_TILEY, "smashed", FONT_TEXT_1);
}

static void DrawEnvelopeTextArea(int envelope_nr)
{
  int id = ED_TEXTAREA_ID_ENVELOPE_INFO;
  struct GadgetInfo *gi = level_editor_gadget[textarea_info[id].gadget_id];

  UnmapGadget(gi);
  DrawBackground(gi->x, gi->y, gi->width, gi->height);

  if (envelope_nr != -1)
    textarea_info[id].value = level.envelope_text[envelope_nr];

  ModifyGadget(gi, GDI_AREA_SIZE,
	       *counterbutton_info[ED_COUNTER_ID_ENVELOPE_XSIZE].value,
	       *counterbutton_info[ED_COUNTER_ID_ENVELOPE_YSIZE].value,
	       GDI_END);

  MapTextAreaGadget(ED_TEXTAREA_ID_ENVELOPE_INFO);
}

char *getElementDescriptionFilename(int element)
{
  char *docs_dir = options.docs_directory;
  char *elements_subdir = "elements";
  static char *filename = NULL;
  char basename[MAX_FILENAME_LEN];

  if (filename != NULL)
    free(filename);

  /* 1st try: look for element description file for exactly this element */
  sprintf(basename, "%s.txt", element_info[element].token_name);
  filename = getPath3(docs_dir, elements_subdir, basename);
  if (fileExists(filename))
    return filename;

  free(filename);

  /* 2nd try: look for element description file for this element's class */
  sprintf(basename, "%s.txt", element_info[element].class_name);
  filename = getPath3(docs_dir, elements_subdir, basename);
  if (fileExists(filename))
    return filename;

  return NULL;
}

static boolean PrintInfoText(char *text, int font_nr, int screen_line)
{
  int font_height = getFontHeight(font_nr);
  int pad_x = ED_SETTINGS_XPOS(0);
  int pad_y = ED_SETTINGS_YPOS(0) + ED_BORDER_SIZE;
  int sx = SX + pad_x;
  int sy = SY + pad_y;
  int max_lines_per_screen = (SYSIZE - pad_y) / font_height - 1;

  if (screen_line >= max_lines_per_screen)
    return FALSE;

  DrawText(sx, sy + screen_line * font_height, text, font_nr);

  return TRUE;
}

static int PrintElementDescriptionFromFile(char *filename, int screen_line)
{
  int font_nr = FONT_TEXT_2;
  int font_width = getFontWidth(font_nr);
  int pad_x = ED_SETTINGS_XPOS(0);
  int max_chars_per_line = (SXSIZE - 2 * pad_x) / font_width;
  char line[MAX_LINE_LEN];
  char buffer[max_chars_per_line + 1];
  int buffer_len;
  int lines_printed = 0;
  FILE *file;

  if (filename == NULL)
    return 0;

  if (!(file = fopen(filename, MODE_READ)))
    return 0;

  buffer[0] = '\0';
  buffer_len = 0;

  while(!feof(file))
  {
    char *line_ptr, *word_ptr;
    boolean last_line_was_empty = TRUE;

    /* read next line of input file */
    if (!fgets(line, MAX_LINE_LEN, file))
      break;

    /* skip comments (lines directly beginning with '#') */
    if (line[0] == '#')
      continue;

    /* cut trailing newline from input line */
    for (line_ptr = line; *line_ptr; line_ptr++)
    {
      if (*line_ptr == '\n' || *line_ptr == '\r')
      {
	*line_ptr = '\0';
	break;
      }
    }

    if (strlen(line) == 0)		/* special case: force empty line */
      strcpy(line, "\n");

    word_ptr = line;

    while (*word_ptr)
    {
      boolean print_buffer = FALSE;
      int word_len;

      /* skip leading whitespaces */
      while (*word_ptr == ' ' || *word_ptr == '\t')
	word_ptr++;

      line_ptr = word_ptr;
      word_len = 0;

      /* look for end of next word */
      while (*line_ptr != ' ' && *line_ptr != '\t' && *line_ptr != '\0')
      {
	line_ptr++;
	word_len++;
      }

      if (word_len == 0)
      {
	continue;
      }
      else if (*word_ptr == '\n')	/* special case: force empty line */
      {
	if (buffer_len == 0)
	  word_ptr++;

	/* prevent printing of multiple empty lines */
	if (buffer_len > 0 || !last_line_was_empty)
	  print_buffer = TRUE;
      }
      else if (word_len < max_chars_per_line - buffer_len)
      {
	/* word fits into text buffer -- add word */

	if (buffer_len > 0)
	  buffer[buffer_len++] = ' ';

	strncpy(&buffer[buffer_len], word_ptr, word_len);
	buffer_len += word_len;
	buffer[buffer_len] = '\0';
	word_ptr += word_len;
      }
      else if (buffer_len > 0)
      {
	/* not enough space left for word in text buffer -- print buffer */

	print_buffer = TRUE;
      }
      else
      {
	/* word does not fit at all into empty text buffer -- cut word */

	strncpy(buffer, word_ptr, max_chars_per_line);
	buffer[max_chars_per_line] = '\0';
	word_ptr += max_chars_per_line;
	print_buffer = TRUE;
      }

      if (print_buffer)
      {
	if (!PrintInfoText(buffer, font_nr, screen_line + lines_printed))
	  return lines_printed;

	last_line_was_empty = (buffer_len == 0);
	lines_printed++;

	buffer[0] = '\0';
	buffer_len = 0;
	print_buffer = FALSE;
      }
    }
  }

  fclose(file);

  if (buffer_len > 0)
    if (PrintInfoText(buffer, font_nr, screen_line + lines_printed))
      lines_printed++;

  return lines_printed;
}

static void DrawPropertiesTabulatorGadgets()
{
  struct GadgetInfo *gd_gi = level_editor_gadget[GADGET_ID_PROPERTIES_INFO];
  struct GadgetDesign *gd = &gd_gi->alt_design[GD_BUTTON_UNPRESSED];
  int gd_x = gd->x + gd_gi->border.width / 2;
  int gd_y = gd->y + gd_gi->height - 1;
  Pixel tab_color = GetPixel(gd->bitmap, gd_x, gd_y);
  int id_first = ED_TEXTBUTTON_ID_PROPERTIES_INFO;
  int id_last  = ED_TEXTBUTTON_ID_PROPERTIES_CONFIG;
  int i;

  /* draw additional "advanced" tabulator for custom elements */
  if (IS_CUSTOM_ELEMENT(properties_element))
    id_last = ED_TEXTBUTTON_ID_PROPERTIES_ADVANCED;

  for (i=id_first; i <= id_last; i++)
  {
    int gadget_id = textbutton_info[i].gadget_id;
    struct GadgetInfo *gi = level_editor_gadget[gadget_id];
    boolean active = (i != edit_mode_properties);

    /* draw background line below tabulator button */
    ClearRectangleOnBackground(drawto, gi->x, gi->y + gi->height, gi->width,1);

    /* draw solid line below inactive tabulator buttons */
    if (!active && tab_color != BLACK_PIXEL)	/* black => transparent */
      FillRectangle(drawto, gi->x, gi->y + gi->height, gi->width,1, tab_color);

    ModifyGadget(gi, GDI_ACTIVE, active, GDI_END);
    MapTextbuttonGadget(i);
  }

  /* draw little border line below tabulator buttons */
  if (tab_color != BLACK_PIXEL)			/* black => transparent */
    FillRectangle(drawto, gd_gi->x, gd_gi->y + gd_gi->height + 1,
		  3 * gd_gi->width + 2 * ED_GADGET_DISTANCE,
		  ED_GADGET_DISTANCE, tab_color);
}

static void DrawPropertiesInfo()
{
  static struct
  {
    int value;
    char *text;
  }
  properties[] =
  {
    /* configurable properties */

    { EP_WALKABLE_OVER,		"- player can walk over it"		},
    { EP_WALKABLE_INSIDE,	"- player can walk inside it"		},
    { EP_WALKABLE_UNDER,	"- player can walk under it"		},
    { EP_PASSABLE_OVER,		"- player can pass over it"		},
    { EP_PASSABLE_INSIDE,	"- player can pass through it"		},
    { EP_PASSABLE_UNDER,	"- player can pass under it"		},

    { EP_DIGGABLE,		"- can be digged away"			},
    { EP_COLLECTIBLE,		"- can be collected"			},
    { EP_DROPPABLE,		"- can be dropped after collecting"	},
    { EP_PUSHABLE,		"- can be pushed"			},

    { EP_CAN_MOVE,		"- can move"				},
    { EP_CAN_FALL,		"- can fall"				},

    { EP_CAN_SMASH_PLAYER,	"- can smash player"			},
#if 0
    { EP_CAN_SMASH_ENEMIES,	"- can smash good and bad guys"		},
#endif
    { EP_CAN_SMASH_EVERYTHING,	"- can smash everything smashable"	},

    { EP_SLIPPERY,		"- slippery for falling objects"	},
    { EP_EM_SLIPPERY_WALL,	"- slippery for some gems (EM style)"	},

    { EP_DONT_RUN_INTO,		"- deadly when running into"		},
    { EP_DONT_COLLIDE_WITH,	"- deadly when colliding with"		},
    { EP_DONT_TOUCH,		"- deadly when touching"		},

    { EP_INDESTRUCTIBLE,	"- indestructible"			},

    { EP_CAN_EXPLODE_BY_FIRE,	"- can explode by fire or explosions"	},
    { EP_CAN_EXPLODE_SMASHED,	"- can explode when smashed"		},
    { EP_CAN_EXPLODE_IMPACT,	"- can explode on impact"		},

    { EP_CAN_CHANGE,		"- can change to other element"		},

    /* pre-defined properties */
    { EP_CAN_PASS_MAGIC_WALL,	"- can pass magic walls"		},
    { EP_HAS_CONTENT,		"- can contain other elements"		},

    { -1,			NULL					}
  };
  char *filename = getElementDescriptionFilename(properties_element);
  char *percentage_text = "In this level:";
  char *properties_text = "Standard properties:";
  float percentage;
  int num_elements_in_level;
  int num_standard_properties = 0;
  int font1_nr = FONT_TEXT_1;
  int font2_nr = FONT_TEXT_2;
  int font1_width = getFontWidth(font1_nr);
  int font2_height = getFontHeight(font2_nr);
  int pad_x = ED_SETTINGS_XPOS(0);
  int pad_y = ED_SETTINGS_YPOS(0) + ED_BORDER_SIZE;
  int screen_line = 0;
  int i, x, y;

  /* ----- print number of elements / percentage of this element in level */

  num_elements_in_level = 0;
  for (y=0; y<lev_fieldy; y++) 
    for (x=0; x<lev_fieldx; x++)
      if (Feld[x][y] == properties_element)
	num_elements_in_level++;
  percentage = num_elements_in_level * 100.0 / (lev_fieldx * lev_fieldy);

  DrawTextF(pad_x, pad_y + screen_line * font2_height, font1_nr,
	    percentage_text);
  DrawTextF(pad_x + strlen(percentage_text) * font1_width,
	    pad_y + screen_line++ * font2_height, font2_nr,
	    "%d (%.2f%%)", num_elements_in_level, percentage);

  screen_line++;

  /* ----- print standard properties of this element */

  DrawTextF(pad_x, pad_y + screen_line++ * font2_height, font1_nr,
	    properties_text);

  for (i=0; properties[i].value != -1; i++)
  {
    if (!HAS_PROPERTY(properties_element, properties[i].value))
      continue;

    DrawTextF(pad_x, pad_y + screen_line++ * font2_height, font2_nr,
	      properties[i].text);
    num_standard_properties++;
  }

  if (num_standard_properties == 0)
    DrawTextF(pad_x + strlen(properties_text) * font1_width,
	      pad_y + (screen_line - 1) * font2_height, font2_nr, "none");

  screen_line++;

  /* ----- print special description of this element */

  PrintInfoText("Description:", FONT_TEXT_1, screen_line);
  if (PrintElementDescriptionFromFile(filename, screen_line + 1) == 0)
    PrintInfoText("No description available.", FONT_TEXT_1, screen_line);
}

#define TEXT_COLLECTING		"Score for collecting"
#define TEXT_SMASHING		"Score for smashing"
#define TEXT_CRACKING		"Score for cracking"
#define TEXT_SPEED		"Speed of amoeba growth"
#define TEXT_DURATION		"Duration when activated"

static struct
{
  int element;
  int *value;
  char *text;
} elements_with_counter[] =
{
  { EL_EMERALD,		&level.score[SC_EMERALD],	TEXT_COLLECTING	},
  { EL_BD_DIAMOND,	&level.score[SC_EMERALD],	TEXT_COLLECTING	},
  { EL_EMERALD_YELLOW,	&level.score[SC_EMERALD],	TEXT_COLLECTING	},
  { EL_EMERALD_RED,	&level.score[SC_EMERALD],	TEXT_COLLECTING	},
  { EL_EMERALD_PURPLE,	&level.score[SC_EMERALD],	TEXT_COLLECTING	},
  { EL_SP_INFOTRON,	&level.score[SC_EMERALD],	TEXT_COLLECTING	},
  { EL_DIAMOND,		&level.score[SC_DIAMOND],	TEXT_COLLECTING	},
  { EL_CRYSTAL,		&level.score[SC_CRYSTAL],	TEXT_COLLECTING	},
  { EL_PEARL,		&level.score[SC_PEARL],		TEXT_COLLECTING	},
  { EL_BUG_RIGHT,	&level.score[SC_BUG],		TEXT_SMASHING	},
  { EL_BUG_UP,		&level.score[SC_BUG],		TEXT_SMASHING	},
  { EL_BUG_LEFT,	&level.score[SC_BUG],		TEXT_SMASHING	},
  { EL_BUG_DOWN,	&level.score[SC_BUG],		TEXT_SMASHING	},
  { EL_BD_BUTTERFLY_RIGHT,&level.score[SC_BUG],		TEXT_SMASHING	},
  { EL_BD_BUTTERFLY_UP,   &level.score[SC_BUG],		TEXT_SMASHING	},
  { EL_BD_BUTTERFLY_LEFT, &level.score[SC_BUG],		TEXT_SMASHING	},
  { EL_BD_BUTTERFLY_DOWN, &level.score[SC_BUG],		TEXT_SMASHING	},
  { EL_SP_ELECTRON,	&level.score[SC_BUG],		TEXT_SMASHING	},
  { EL_SPACESHIP_RIGHT,	&level.score[SC_SPACESHIP],	TEXT_SMASHING	},
  { EL_SPACESHIP_UP,	&level.score[SC_SPACESHIP],	TEXT_SMASHING	},
  { EL_SPACESHIP_LEFT,	&level.score[SC_SPACESHIP],	TEXT_SMASHING	},
  { EL_SPACESHIP_DOWN,	&level.score[SC_SPACESHIP],	TEXT_SMASHING	},
  { EL_BD_FIREFLY_RIGHT,&level.score[SC_SPACESHIP],	TEXT_SMASHING	},
  { EL_BD_FIREFLY_UP,	&level.score[SC_SPACESHIP],	TEXT_SMASHING	},
  { EL_BD_FIREFLY_LEFT, &level.score[SC_SPACESHIP],	TEXT_SMASHING	},
  { EL_BD_FIREFLY_DOWN, &level.score[SC_SPACESHIP],	TEXT_SMASHING	},
  { EL_SP_SNIKSNAK,	&level.score[SC_SPACESHIP],	TEXT_SMASHING	},
  { EL_YAMYAM,		&level.score[SC_YAMYAM],	TEXT_SMASHING	},
  { EL_DARK_YAMYAM,	&level.score[SC_YAMYAM],	TEXT_SMASHING	},
  { EL_ROBOT,		&level.score[SC_ROBOT],		TEXT_SMASHING	},
  { EL_PACMAN_RIGHT,	&level.score[SC_PACMAN],	TEXT_SMASHING	},
  { EL_PACMAN_UP,	&level.score[SC_PACMAN],	TEXT_SMASHING	},
  { EL_PACMAN_LEFT,	&level.score[SC_PACMAN],	TEXT_SMASHING	},
  { EL_PACMAN_DOWN,	&level.score[SC_PACMAN],	TEXT_SMASHING	},
  { EL_NUT,		&level.score[SC_NUT],		TEXT_CRACKING	},
  { EL_DYNAMITE,	&level.score[SC_DYNAMITE],	TEXT_COLLECTING	},
  { EL_DYNABOMB_INCREASE_NUMBER,&level.score[SC_DYNAMITE],TEXT_COLLECTING },
  { EL_DYNABOMB_INCREASE_SIZE,	&level.score[SC_DYNAMITE],TEXT_COLLECTING },
  { EL_DYNABOMB_INCREASE_POWER,	&level.score[SC_DYNAMITE],TEXT_COLLECTING },
  { EL_SHIELD_NORMAL,	&level.score[SC_SHIELD],	TEXT_COLLECTING	},
  { EL_SHIELD_DEADLY,	&level.score[SC_SHIELD],	TEXT_COLLECTING	},
  { EL_EXTRA_TIME,	&level.score[SC_TIME_BONUS],	TEXT_COLLECTING	},
  { EL_KEY_1,		&level.score[SC_KEY],		TEXT_COLLECTING	},
  { EL_KEY_2,		&level.score[SC_KEY],		TEXT_COLLECTING	},
  { EL_KEY_3,		&level.score[SC_KEY],		TEXT_COLLECTING	},
  { EL_KEY_4,		&level.score[SC_KEY],		TEXT_COLLECTING	},
#if 1
  { EL_EM_KEY_1,	&level.score[SC_KEY],		TEXT_COLLECTING	},
  { EL_EM_KEY_2,	&level.score[SC_KEY],		TEXT_COLLECTING	},
  { EL_EM_KEY_3,	&level.score[SC_KEY],		TEXT_COLLECTING	},
  { EL_EM_KEY_4,	&level.score[SC_KEY],		TEXT_COLLECTING	},
#else
  { EL_EM_KEY_1_FILE,	&level.score[SC_KEY],		TEXT_COLLECTING	},
  { EL_EM_KEY_2_FILE,	&level.score[SC_KEY],		TEXT_COLLECTING	},
  { EL_EM_KEY_3_FILE,	&level.score[SC_KEY],		TEXT_COLLECTING	},
  { EL_EM_KEY_4_FILE,	&level.score[SC_KEY],		TEXT_COLLECTING	},
#endif
  { EL_AMOEBA_WET,	&level.amoeba_speed,		TEXT_SPEED	},
  { EL_AMOEBA_DRY,	&level.amoeba_speed,		TEXT_SPEED	},
  { EL_AMOEBA_FULL,	&level.amoeba_speed,		TEXT_SPEED	},
  { EL_BD_AMOEBA,	&level.amoeba_speed,		TEXT_SPEED	},
  { EL_MAGIC_WALL,	&level.time_magic_wall,		TEXT_DURATION	},
  { EL_ROBOT_WHEEL,	&level.time_wheel,		TEXT_DURATION	},
  { -1,			NULL,				NULL		}
};

static boolean checkPropertiesConfig()
{
  int i;

  if (IS_GEM(properties_element) ||
      IS_CUSTOM_ELEMENT(properties_element) ||
      IS_ENVELOPE(properties_element) ||
      HAS_CONTENT(properties_element))
    return TRUE;
  else
    for (i=0; elements_with_counter[i].element != -1; i++)
      if (elements_with_counter[i].element == properties_element)
	return TRUE;

  return FALSE;
}

static void DrawPropertiesConfig()
{
  int i;

  if (!checkPropertiesConfig())
  {
    PrintInfoText("No configuration options available.", FONT_TEXT_1, 0);

    return;
  }

  /* check if there are elements where a score can be chosen for */
  for (i=0; elements_with_counter[i].element != -1; i++)
  {
    if (elements_with_counter[i].element == properties_element)
    {
      int counter_id = ED_COUNTER_ID_ELEMENT_SCORE;

      counterbutton_info[counter_id].value = elements_with_counter[i].value;
      counterbutton_info[counter_id].text_right= elements_with_counter[i].text;
      MapCounterButtons(counter_id);

      break;
    }
  }

  if (HAS_CONTENT(properties_element))
  {
    /* draw stickybutton gadget */
    i = ED_CHECKBUTTON_ID_STICK_ELEMENT;
    checkbutton_info[i].y = ED_COUNTER_YPOS(4);
    MapCheckbuttonGadget(i);

    if (IS_AMOEBOID(properties_element))
      MapDrawingArea(ED_DRAWING_ID_AMOEBA_CONTENT);
    else
      DrawElementContentAreas();
  }

  if (IS_GEM(properties_element))
    MapCheckbuttonGadget(ED_CHECKBUTTON_ID_EM_SLIPPERY_GEMS);

  if (IS_ENVELOPE(properties_element))
  {
    int counter1_id = ED_COUNTER_ID_ENVELOPE_XSIZE;
    int counter2_id = ED_COUNTER_ID_ENVELOPE_YSIZE;
    int envelope_nr = properties_element - EL_ENVELOPE_1;

    counterbutton_info[counter1_id].value = &level.envelope_xsize[envelope_nr];
    counterbutton_info[counter2_id].value = &level.envelope_ysize[envelope_nr];

    /* display counter to choose size of envelope text area */
    MapCounterButtons(ED_COUNTER_ID_ENVELOPE_XSIZE);
    MapCounterButtons(ED_COUNTER_ID_ENVELOPE_YSIZE);

    DrawEnvelopeTextArea(envelope_nr);
  }

  if (IS_CUSTOM_ELEMENT(properties_element))
  {
    /* draw stickybutton gadget */
    i = ED_CHECKBUTTON_ID_STICK_ELEMENT;
    checkbutton_info[i].y = ED_SETTINGS_YPOS(0);
    MapCheckbuttonGadget(i);

    /* draw checkbutton gadgets */
    for (i =  ED_CHECKBUTTON_ID_CUSTOM_FIRST;
	 i <= ED_CHECKBUTTON_ID_CUSTOM_LAST; i++)
      MapCheckbuttonGadget(i);

    /* draw counter gadgets */
    for (i=ED_COUNTER_ID_CUSTOM_FIRST; i<=ED_COUNTER_ID_CUSTOM_LAST; i++)
      MapCounterButtons(i);

    /* draw selectbox gadgets */
    for (i=ED_SELECTBOX_ID_CUSTOM_FIRST; i <= ED_SELECTBOX_ID_CUSTOM_LAST; i++)
      MapSelectboxGadget(i);

    /* draw drawing area gadgets */
    DrawCustomContentArea();

    /* draw text input gadgets */
    MapTextInputGadget(ED_TEXTINPUT_ID_ELEMENT_NAME);
  }
}

static void DrawPropertiesAdvancedDrawingAreas()
{
  MapDrawingArea(ED_DRAWING_ID_CUSTOM_GRAPHIC);
  MapDrawingArea(ED_DRAWING_ID_CUSTOM_CHANGE_TARGET);
  MapDrawingArea(ED_DRAWING_ID_CUSTOM_CHANGE_TRIGGER);

  DrawCustomChangeContentArea();

  redraw_mask |= REDRAW_FIELD;
}

static void DrawPropertiesAdvanced()
{
  int i;

  /* draw stickybutton gadget */
  i = ED_CHECKBUTTON_ID_STICK_ELEMENT;
  checkbutton_info[i].y = ED_SETTINGS_YPOS(0);
  MapCheckbuttonGadget(i);

  /* draw checkbutton gadgets */
  for (i =  ED_CHECKBUTTON_ID_CHANGE_FIRST;
       i <= ED_CHECKBUTTON_ID_CHANGE_LAST; i++)
    MapCheckbuttonGadget(i);

  /* draw counter gadgets */
  for (i=ED_COUNTER_ID_CHANGE_FIRST; i<=ED_COUNTER_ID_CHANGE_LAST; i++)
    MapCounterButtons(i);

  /* draw selectbox gadgets */
  for (i=ED_SELECTBOX_ID_CHANGE_FIRST; i<=ED_SELECTBOX_ID_CHANGE_LAST; i++)
    MapSelectboxGadget(i);

  /* draw textbutton gadgets */
  for (i=ED_TEXTBUTTON_ID_CHANGE_FIRST; i<=ED_TEXTBUTTON_ID_CHANGE_LAST; i++)
    MapTextbuttonGadget(i);

  /* draw graphicbutton gadgets */
  for (i =  ED_GRAPHICBUTTON_ID_CHANGE_FIRST;
       i <= ED_GRAPHICBUTTON_ID_CHANGE_LAST; i++)
    MapGraphicbuttonGadget(i);

  /* draw drawing area gadgets */
  DrawPropertiesAdvancedDrawingAreas();
}

static void DrawElementName(int x, int y, int element)
{
  char *element_name = getElementInfoText(element);
  int font_nr = FONT_TEXT_1;
  int font_width = getFontWidth(font_nr);
  int font_height = getFontHeight(font_nr);
  int max_text_width = SXSIZE - x - ED_SETTINGS_XPOS(0);
  int max_chars_per_line = max_text_width / font_width;
  char buffer[max_chars_per_line + 1];

  if (strlen(element_name) <= max_chars_per_line)
    DrawTextF(x, y, font_nr, element_name);
  else
  {
    int next_pos = max_chars_per_line;

    strncpy(buffer, element_name, max_chars_per_line);
    buffer[max_chars_per_line] = '\0';

    if (element_name[max_chars_per_line] == ' ')
      next_pos++;
    else
    {
      int i;

      for (i = max_chars_per_line - 1; i >= 0; i--)
	if (buffer[i] == ' ')
	  break;

      if (strlen(&element_name[i + 1]) <= max_chars_per_line)
      {
	buffer[i] = '\0';
	next_pos = i + 1;
      }
    }

    DrawTextF(x, y - font_height / 2, font_nr, buffer);

    strncpy(buffer, &element_name[next_pos], max_chars_per_line);
    buffer[max_chars_per_line] = '\0';

    DrawTextF(x, y + font_height / 2, font_nr, buffer);
  }
}

static void DrawPropertiesWindow()
{
  int xstart = 2;
  int ystart = 4;

  stick_element_properties_window = FALSE;

  /* make sure that previous properties edit mode exists for this element */
  if (edit_mode_properties == ED_MODE_PROPERTIES_ADVANCED &&
      !IS_CUSTOM_ELEMENT(properties_element))
    edit_mode_properties = ED_MODE_PROPERTIES_CONFIG;

  if (IS_CUSTOM_ELEMENT(properties_element))
    CopyCustomElementPropertiesToEditor(properties_element);

  UnmapLevelEditorWindowGadgets();

  SetMainBackgroundImage(IMG_BACKGROUND_EDITOR);
  ClearWindow();

  DrawText(SX + ED_SETTINGS2_XPOS, SY + ED_SETTINGS1_YPOS,
	   "Element Settings", FONT_TITLE_1);

  DrawElementBorder(SX + xstart * MINI_TILEX,
		    SY + ystart * MINI_TILEY + MINI_TILEY / 2,
		    TILEX, TILEY, FALSE);
  DrawGraphicAnimationExt(drawto,
			  SX + xstart * MINI_TILEX,
			  SY + ystart * MINI_TILEY + MINI_TILEY / 2,
			  el2img(properties_element), -1, NO_MASKING);

  FrameCounter = 0;	/* restart animation frame counter */

  DrawElementName((xstart + 3) * MINI_TILEX, (ystart + 1) * MINI_TILEY,
		  properties_element);

  DrawPropertiesTabulatorGadgets();

  if (edit_mode_properties == ED_MODE_PROPERTIES_INFO)
    DrawPropertiesInfo();
  else if (edit_mode_properties == ED_MODE_PROPERTIES_CONFIG)
    DrawPropertiesConfig();
  else	/* edit_mode_properties == ED_MODE_PROPERTIES_ADVANCED */
    DrawPropertiesAdvanced();
}

static void UpdateCustomElementGraphicGadgets()
{
  ModifyEditorElementList();
  RedrawDrawingElements();

  if (edit_mode == ED_MODE_PROPERTIES &&
      edit_mode_properties == ED_MODE_PROPERTIES_ADVANCED)
    DrawPropertiesAdvancedDrawingAreas();
}

static void DrawLineElement(int sx, int sy, int element, boolean change_level)
{
  int lx = sx + level_xpos;
  int ly = sy + level_ypos;

  DrawMiniElement(sx, sy, (element < 0 ? Feld[lx][ly] : element));

  if (change_level)
    Feld[lx][ly] = element;
}

static void DrawLine(int from_x, int from_y, int to_x, int to_y,
		     int element, boolean change_level)
{
  if (from_y == to_y)			/* horizontal line */
  {
    int x;
    int y = from_y;

    if (from_x > to_x)
      swap_numbers(&from_x, &to_x);

    for (x=from_x; x<=to_x; x++)
      DrawLineElement(x, y, element, change_level);
  }
  else if (from_x == to_x)		/* vertical line */
  {
    int x = from_x;
    int y;

    if (from_y > to_y)
      swap_numbers(&from_y, &to_y);

    for (y=from_y; y<=to_y; y++)
      DrawLineElement(x, y, element, change_level);
  }
  else					/* diagonal line */
  {
    int len_x = ABS(to_x - from_x);
    int len_y = ABS(to_y - from_y);
    int x, y;

    if (len_y < len_x)			/* a < 1 */
    {
      float a = (float)len_y / (float)len_x;

      if (from_x > to_x)
	swap_number_pairs(&from_x, &from_y, &to_x, &to_y);

      for (x=0; x<=len_x; x++)
      {
	y = (int)(a * x + 0.5) * (to_y < from_y ? -1 : +1);
	DrawLineElement(from_x + x, from_y + y, element, change_level);
      }
    }
    else				/* a >= 1 */
    {
      float a = (float)len_x / (float)len_y;

      if (from_y > to_y)
	swap_number_pairs(&from_x, &from_y, &to_x, &to_y);

      for (y=0; y<=len_y; y++)
      {
	x = (int)(a * y + 0.5) * (to_x < from_x ? -1 : +1);
	DrawLineElement(from_x + x, from_y + y, element, change_level);
      }
    }
  }
}

static void DrawBox(int from_x, int from_y, int to_x, int to_y,
		    int element, boolean change_level)
{
  DrawLine(from_x, from_y, from_x, to_y, element, change_level);
  DrawLine(from_x, to_y, to_x, to_y, element, change_level);
  DrawLine(to_x, to_y, to_x, from_y, element, change_level);
  DrawLine(to_x, from_y, from_x, from_y, element, change_level);
}

static void DrawFilledBox(int from_x, int from_y, int to_x, int to_y,
			  int element, boolean change_level)
{
  int y;

  if (from_y > to_y)
    swap_number_pairs(&from_x, &from_y, &to_x, &to_y);

  for (y=from_y; y<=to_y; y++)
    DrawLine(from_x, y, to_x, y, element, change_level);
}

static void DrawArcExt(int from_x, int from_y, int to_x2, int to_y2,
		       int element, boolean change_level)
{
  int to_x = to_x2 - (to_x2 > from_x ? +1 : -1);
  int to_y = to_y2 - (to_y2 > from_y ? +1 : -1);
  int len_x = ABS(to_x - from_x);
  int len_y = ABS(to_y - from_y);
  int radius, x, y;

  radius = (int)(sqrt((float)(len_x * len_x + len_y * len_y)) + 0.5);

  /* not optimal (some points get drawn twice) but simple,
     and fast enough for the few points we are drawing */

  for (x=0; x<=radius; x++)
  {
    int sx, sy, lx, ly;

    y = (int)(sqrt((float)(radius * radius - x * x)) + 0.5);

    sx = from_x + x * (from_x < to_x2 ? +1 : -1);
    sy = from_y + y * (from_y < to_y2 ? +1 : -1);
    lx = sx + level_xpos;
    ly = sy + level_ypos;

    if (IN_ED_FIELD(sx, sy) && IN_LEV_FIELD(lx, ly))
      DrawLineElement(sx, sy, element, change_level);
  }

  for (y=0; y<=radius; y++)
  {
    int sx, sy, lx, ly;

    x = (int)(sqrt((float)(radius * radius - y * y)) + 0.5);

    sx = from_x + x * (from_x < to_x2 ? +1 : -1);
    sy = from_y + y * (from_y < to_y2 ? +1 : -1);
    lx = sx + level_xpos;
    ly = sy + level_ypos;

    if (IN_ED_FIELD(sx, sy) && IN_LEV_FIELD(lx, ly))
      DrawLineElement(sx, sy, element, change_level);
  }
}

static void DrawArc(int from_x, int from_y, int to_x, int to_y,
		    int element, boolean change_level)
{
  int to_x2 = to_x + (to_x < from_x ? -1 : +1);
  int to_y2 = to_y + (to_y > from_y ? +1 : -1);

  DrawArcExt(from_x, from_y, to_x2, to_y2, element, change_level);
}

#define DRAW_CIRCLES_BUTTON_AVAILABLE	0
#if DRAW_CIRCLES_BUTTON_AVAILABLE
static void DrawCircle(int from_x, int from_y, int to_x, int to_y,
		       int element, boolean change_level)
{
  int to_x2 = to_x + (to_x < from_x ? -1 : +1);
  int to_y2 = to_y + (to_y > from_y ? +1 : -1);
  int mirror_to_x2 = from_x - (to_x2 - from_x);
  int mirror_to_y2 = from_y - (to_y2 - from_y);

  DrawArcExt(from_x, from_y, to_x2, to_y2, element, change_level);
  DrawArcExt(from_x, from_y, mirror_to_x2, to_y2, element, change_level);
  DrawArcExt(from_x, from_y, to_x2, mirror_to_y2, element, change_level);
  DrawArcExt(from_x, from_y, mirror_to_x2, mirror_to_y2, element,change_level);
}
#endif

static void DrawAreaBorder(int from_x, int from_y, int to_x, int to_y)
{
  int from_sx, from_sy;
  int to_sx, to_sy;

  if (from_x > to_x)
    swap_numbers(&from_x, &to_x);

  if (from_y > to_y)
    swap_numbers(&from_y, &to_y);

  from_sx = SX + from_x * MINI_TILEX;
  from_sy = SY + from_y * MINI_TILEY;
  to_sx = SX + to_x * MINI_TILEX + MINI_TILEX - 1;
  to_sy = SY + to_y * MINI_TILEY + MINI_TILEY - 1;

  DrawSimpleWhiteLine(drawto, from_sx, from_sy, to_sx, from_sy);
  DrawSimpleWhiteLine(drawto, to_sx, from_sy, to_sx, to_sy);
  DrawSimpleWhiteLine(drawto, to_sx, to_sy, from_sx, to_sy);
  DrawSimpleWhiteLine(drawto, from_sx, to_sy, from_sx, from_sy);

  if (from_x == to_x && from_y == to_y)
    MarkTileDirty(from_x/2, from_y/2);
  else
    redraw_mask |= REDRAW_FIELD;
}

static void SelectArea(int from_x, int from_y, int to_x, int to_y,
		       int element, boolean change_level)
{
  if (element == -1 || change_level)
    DrawBox(from_x, from_y, to_x, to_y, -1, FALSE);
  else
    DrawAreaBorder(from_x, from_y, to_x, to_y);
}

/* values for CopyBrushExt() */
#define CB_AREA_TO_BRUSH	0
#define CB_BRUSH_TO_CURSOR	1
#define CB_BRUSH_TO_LEVEL	2
#define CB_DELETE_OLD_CURSOR	3

static void CopyBrushExt(int from_x, int from_y, int to_x, int to_y,
			 int button, int mode)
{
  static short brush_buffer[MAX_ED_FIELDX][MAX_ED_FIELDY];
  static int brush_width, brush_height;
  static int last_cursor_x = -1, last_cursor_y = -1;
  static boolean delete_old_brush;
  int new_element = BUTTON_ELEMENT(button);
  int x, y;

  if (mode == CB_DELETE_OLD_CURSOR && !delete_old_brush)
    return;

  if (mode == CB_AREA_TO_BRUSH)
  {
    int from_lx, from_ly;

    if (from_x > to_x)
      swap_numbers(&from_x, &to_x);

    if (from_y > to_y)
      swap_numbers(&from_y, &to_y);

    brush_width = to_x - from_x + 1;
    brush_height = to_y - from_y + 1;

    from_lx = from_x + level_xpos;
    from_ly = from_y + level_ypos;

    for (y=0; y<brush_height; y++)
    {
      for (x=0; x<brush_width; x++)
      {
	brush_buffer[x][y] = Feld[from_lx + x][from_ly + y];

	if (button != 1)
	  DrawLineElement(from_x + x, from_y + y, new_element, TRUE);
      }
    }

    if (button != 1)
      CopyLevelToUndoBuffer(UNDO_IMMEDIATE);

    delete_old_brush = FALSE;
  }
  else if (mode == CB_BRUSH_TO_CURSOR || mode == CB_DELETE_OLD_CURSOR ||
	   mode == CB_BRUSH_TO_LEVEL)
  {
    int cursor_x = (mode == CB_DELETE_OLD_CURSOR ? last_cursor_x : from_x);
    int cursor_y = (mode == CB_DELETE_OLD_CURSOR ? last_cursor_y : from_y);
    int cursor_from_x = cursor_x - brush_width / 2;
    int cursor_from_y = cursor_y - brush_height / 2;
    int border_from_x = cursor_x, border_from_y = cursor_y;
    int border_to_x = cursor_x, border_to_y = cursor_y;

    if (mode != CB_DELETE_OLD_CURSOR && delete_old_brush)
      CopyBrushExt(0, 0, 0, 0, 0, CB_DELETE_OLD_CURSOR);

    if (!IN_ED_FIELD(cursor_x, cursor_y) ||
	!IN_LEV_FIELD(cursor_x + level_xpos, cursor_y + level_ypos))
    {
      delete_old_brush = FALSE;
      return;
    }

    for (y=0; y<brush_height; y++)
    {
      for (x=0; x<brush_width; x++)
      {
	int sx = cursor_from_x + x;
	int sy = cursor_from_y + y;
	int lx = sx + level_xpos;
	int ly = sy + level_ypos;
	boolean change_level = (mode == CB_BRUSH_TO_LEVEL);
	int element = (mode == CB_DELETE_OLD_CURSOR ? -1 :
		       mode == CB_BRUSH_TO_CURSOR || button == 1 ?
		       brush_buffer[x][y] : new_element);

	if (IN_ED_FIELD(sx, sy) && IN_LEV_FIELD(lx, ly))
	{
	  if (sx < border_from_x)
	    border_from_x = sx;
	  else if (sx > border_to_x)
	    border_to_x = sx;
	  if (sy < border_from_y)
	    border_from_y = sy;
	  else if (sy > border_to_y)
	    border_to_y = sy;

	  DrawLineElement(sx, sy, element, change_level);
	}
      }
    }

    if (mode != CB_DELETE_OLD_CURSOR)
      DrawAreaBorder(border_from_x, border_from_y, border_to_x, border_to_y);

    last_cursor_x = cursor_x;
    last_cursor_y = cursor_y;
    delete_old_brush = TRUE;
  }
}

static void CopyAreaToBrush(int from_x, int from_y, int to_x, int to_y,
			    int button)
{
  CopyBrushExt(from_x, from_y, to_x, to_y, button, CB_AREA_TO_BRUSH);
}

static void CopyBrushToLevel(int x, int y, int button)
{
  CopyBrushExt(x, y, 0, 0, button, CB_BRUSH_TO_LEVEL);
}

static void CopyBrushToCursor(int x, int y)
{
  CopyBrushExt(x, y, 0, 0, 0, CB_BRUSH_TO_CURSOR);
}

static void DeleteBrushFromCursor()
{
  CopyBrushExt(0, 0, 0, 0, 0, CB_DELETE_OLD_CURSOR);
}

static void FloodFill(int from_x, int from_y, int fill_element)
{
  int i,x,y;
  int old_element;
  static int check[4][2] = { {-1,0}, {0,-1}, {1,0}, {0,1} };
  static int safety = 0;

  /* check if starting field still has the desired content */
  if (Feld[from_x][from_y] == fill_element)
    return;

  safety++;

  if (safety > lev_fieldx*lev_fieldy)
    Error(ERR_EXIT, "Something went wrong in 'FloodFill()'. Please debug.");

  old_element = Feld[from_x][from_y];
  Feld[from_x][from_y] = fill_element;

  for(i=0;i<4;i++)
  {
    x = from_x + check[i][0];
    y = from_y + check[i][1];

    if (IN_LEV_FIELD(x,y) && Feld[x][y] == old_element)
      FloodFill(x, y, fill_element);
  }

  safety--;
}

/* values for DrawLevelText() modes */
#define TEXT_INIT		0
#define TEXT_SETCURSOR		1
#define TEXT_WRITECHAR		2
#define TEXT_BACKSPACE		3
#define TEXT_NEWLINE		4
#define TEXT_END		5
#define TEXT_QUERY_TYPING	6

static int DrawLevelText(int sx, int sy, char letter, int mode)
{
  static short delete_buffer[MAX_LEV_FIELDX];
  static int start_sx, start_sy;
  static int last_sx, last_sy;
  static boolean typing = FALSE;
  int letter_element = EL_CHAR_ASCII0 + letter;
  int lx = 0, ly = 0;

  /* map lower case letters to upper case and convert special characters */
  if (letter >= 'a' && letter <= 'z')
    letter_element = EL_CHAR_ASCII0 + letter + (int)('A' - 'a');
  else if (letter == '' || letter == '')
    letter_element = EL_CHAR_AUMLAUT;
  else if (letter == '' || letter == '')
    letter_element = EL_CHAR_OUMLAUT;
  else if (letter == '' || letter == '')
    letter_element = EL_CHAR_UUMLAUT;
  else if (letter == '^')
    letter_element = EL_CHAR_COPYRIGHT;
  else
    letter_element = EL_CHAR_ASCII0 + letter;

  if (mode != TEXT_INIT)
  {
    if (!typing)
      return FALSE;

    if (mode != TEXT_SETCURSOR)
    {
      sx = last_sx;
      sy = last_sy;
    }

    lx = last_sx + level_xpos;
    ly = last_sy + level_ypos;
  }

  switch (mode)
  {
    case TEXT_INIT:
      if (typing)
	DrawLevelText(0, 0, 0, TEXT_END);

      typing = TRUE;
      start_sx = last_sx = sx;
      start_sy = last_sy = sy;
      DrawLevelText(sx, sy, 0, TEXT_SETCURSOR);
      break;

    case TEXT_SETCURSOR:
      DrawMiniElement(last_sx, last_sy, Feld[lx][ly]);
      DrawAreaBorder(sx, sy, sx, sy);
      last_sx = sx;
      last_sy = sy;
      break;

    case TEXT_WRITECHAR:
      if (letter_element >= EL_CHAR_START && letter_element <= EL_CHAR_END)
      {
	delete_buffer[sx - start_sx] = Feld[lx][ly];
	Feld[lx][ly] = letter_element;

	if (sx + 1 < ed_fieldx && lx + 1 < lev_fieldx)
	  DrawLevelText(sx + 1, sy, 0, TEXT_SETCURSOR);
	else if (sy + 1 < ed_fieldy && ly + 1 < lev_fieldy)
	  DrawLevelText(start_sx, sy + 1, 0, TEXT_SETCURSOR);
	else
	  DrawLevelText(0, 0, 0, TEXT_END);
      }
      break;

    case TEXT_BACKSPACE:
      if (sx > start_sx)
      {
	Feld[lx - 1][ly] = delete_buffer[sx - start_sx - 1];
	DrawMiniElement(sx - 1, sy, Feld[lx - 1][ly]);
	DrawLevelText(sx - 1, sy, 0, TEXT_SETCURSOR);
      }
      break;

    case TEXT_NEWLINE:
      if (sy + 1 < ed_fieldy - 1 && ly + 1 < lev_fieldy - 1)
	DrawLevelText(start_sx, sy + 1, 0, TEXT_SETCURSOR);
      else
	DrawLevelText(0, 0, 0, TEXT_END);
      break;

    case TEXT_END:
      CopyLevelToUndoBuffer(UNDO_IMMEDIATE);
      DrawMiniElement(sx, sy, Feld[lx][ly]);
      typing = FALSE;
      break;

    case TEXT_QUERY_TYPING:
      break;

    default:
      break;
  }

  return typing;
}

static void SetTextCursor(int unused_sx, int unused_sy, int sx, int sy,
			  int element, boolean change_level)
{
  int lx = sx + level_xpos;
  int ly = sy + level_ypos;

  if (element == -1)
    DrawMiniElement(sx, sy, Feld[lx][ly]);
  else
    DrawAreaBorder(sx, sy, sx, sy);
}

static void CopyLevelToUndoBuffer(int mode)
{
  static boolean accumulated_undo = FALSE;
  boolean new_undo_buffer_position = TRUE;
  int last_border_element;
  int x, y;

  switch (mode)
  {
    case UNDO_IMMEDIATE:
      accumulated_undo = FALSE;
      break;

    case UNDO_ACCUMULATE:
      if (accumulated_undo)
	new_undo_buffer_position = FALSE;
      accumulated_undo = TRUE;
      break;

    default:
      break;
  }

  if (new_undo_buffer_position)
  {
    /* new position in undo buffer ring */
    undo_buffer_position = (undo_buffer_position + 1) % NUM_UNDO_STEPS;

    if (undo_buffer_steps < NUM_UNDO_STEPS - 1)
      undo_buffer_steps++;
  }

  for(x=0; x<lev_fieldx; x++)
    for(y=0; y<lev_fieldy; y++)
      UndoBuffer[undo_buffer_position][x][y] = Feld[x][y];

  /* check if drawing operation forces change of border style */
  last_border_element = BorderElement;
  SetBorderElement();
  if (BorderElement != last_border_element)
    DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos, level_ypos);
}

static void RandomPlacement(int new_element)
{
  static boolean free_position[MAX_LEV_FIELDX][MAX_LEV_FIELDY];
  int num_free_positions;
  int num_percentage;
  int num_elements;
  int x, y;

  /* determine number of free positions for the new elements */
  /* (maybe this statement should be formatted a bit more readable...) */
  num_free_positions = 0;
  for (x=0; x<lev_fieldx; x++)
    for (y=0; y<lev_fieldy; y++)
      if ((free_position[x][y] =
	   ((random_placement_background_restricted &&
	     Feld[x][y] == random_placement_background_element) ||
	    (!random_placement_background_restricted &&
	     Feld[x][y] != new_element))) == TRUE)
	num_free_positions++;

  /* determine number of new elements to place there */
  num_percentage = num_free_positions * random_placement_value / 100;
  num_elements = (random_placement_method == RANDOM_USE_PERCENTAGE ?
		  num_percentage : random_placement_value);

  /* if not more free positions than elements to place, fill whole level */
  if (num_elements >= num_free_positions)
  {
    for (x=0; x<lev_fieldx; x++)
      for (y=0; y<lev_fieldy; y++)
	Feld[x][y] = new_element;

    DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos, level_ypos);
    CopyLevelToUndoBuffer(UNDO_IMMEDIATE);
    return;
  }

  while (num_elements > 0)
  {
    x = RND(lev_fieldx);
    y = RND(lev_fieldy);

    /* don't place element at the same position twice */
    if (free_position[x][y])
    {
      free_position[x][y] = FALSE;
      Feld[x][y] = new_element;
      num_elements--;
    }
  }

  DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos, level_ypos);
  CopyLevelToUndoBuffer(UNDO_IMMEDIATE);
}

void WrapLevel(int dx, int dy)
{
  int wrap_dx = lev_fieldx - dx;
  int wrap_dy = lev_fieldy - dy;
  int x, y;

  for(x=0; x<lev_fieldx; x++)
    for(y=0; y<lev_fieldy; y++)
      FieldBackup[x][y] = Feld[x][y];

  for(x=0; x<lev_fieldx; x++)
    for(y=0; y<lev_fieldy; y++)
      Feld[x][y] =
	FieldBackup[(x + wrap_dx) % lev_fieldx][(y + wrap_dy) % lev_fieldy];

  DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos, level_ypos);
  CopyLevelToUndoBuffer(UNDO_ACCUMULATE);
}

static void HandleDrawingAreas(struct GadgetInfo *gi)
{
  static boolean started_inside_drawing_area = FALSE;
  int id = gi->custom_id;
  boolean button_press_event;
  boolean button_release_event;
  boolean inside_drawing_area = !gi->event.off_borders;
  boolean draw_level = (id == GADGET_ID_DRAWING_LEVEL);
  int actual_drawing_function;
  int button = gi->event.button;
  int new_element = BUTTON_ELEMENT(button);
  int sx = gi->event.x, sy = gi->event.y;
  int min_sx = 0, min_sy = 0;
  int max_sx = gi->drawing.area_xsize - 1, max_sy = gi->drawing.area_ysize - 1;
  int item_xsize = gi->drawing.item_xsize, item_ysize = gi->drawing.item_ysize;
  int lx = 0, ly = 0;
  int min_lx = 0, min_ly = 0;
  int max_lx = lev_fieldx - 1, max_ly = lev_fieldy - 1;
  int x, y;

  /* handle info callback for each invocation of action callback */
  gi->callback_info(gi);

  button_press_event = (gi->event.type == GD_EVENT_PRESSED);
  button_release_event = (gi->event.type == GD_EVENT_RELEASED);

  /* make sure to stay inside drawing area boundaries */
  sx = (sx < min_sx ? min_sx : sx > max_sx ? max_sx : sx);
  sy = (sy < min_sy ? min_sy : sy > max_sy ? max_sy : sy);

  if (draw_level)
  {
    /* get positions inside level field */
    lx = sx + level_xpos;
    ly = sy + level_ypos;

    if (!IN_LEV_FIELD(lx, ly))
      inside_drawing_area = FALSE;

    /* make sure to stay inside level field boundaries */
    lx = (lx < min_lx ? min_lx : lx > max_lx ? max_lx : lx);
    ly = (ly < min_ly ? min_ly : ly > max_ly ? max_ly : ly);

    /* correct drawing area positions accordingly */
    sx = lx - level_xpos;
    sy = ly - level_ypos;
  }

  if (button_press_event)
    started_inside_drawing_area = inside_drawing_area;

  if (!started_inside_drawing_area)
    return;

  if (!button && !button_release_event)
    return;

  /* automatically switch to 'single item' drawing mode, if needed */
  actual_drawing_function =
    (draw_level || drawing_function == GADGET_ID_PICK_ELEMENT ?
     drawing_function : GADGET_ID_SINGLE_ITEMS);

  /* clicking into drawing area with pressed Control key picks element */
  if (GetKeyModState() & KMOD_Control)
    actual_drawing_function = GADGET_ID_PICK_ELEMENT;

  switch (actual_drawing_function)
  {
    case GADGET_ID_SINGLE_ITEMS:
      if (draw_level)
      {
	if (button_release_event)
	{
	  CopyLevelToUndoBuffer(UNDO_IMMEDIATE);

	  if (edit_mode == ED_MODE_DRAWING && draw_with_brush &&
	      !inside_drawing_area)
	    DeleteBrushFromCursor();
	}

	if (!button)
	  break;

	if (draw_with_brush)
	{
	  if (!button_release_event)
	    CopyBrushToLevel(sx, sy, button);
	}
	else if (new_element != Feld[lx][ly])
	{
	  if (new_element == EL_PLAYER_1)
	  {
	    /* remove player at old position */
	    for(y=0; y<lev_fieldy; y++)
	    {
	      for(x=0; x<lev_fieldx; x++)
	      {
		if (Feld[x][y] == EL_PLAYER_1)
		{
		  Feld[x][y] = EL_EMPTY;
		  if (x - level_xpos >= 0 && x - level_xpos < ed_fieldx &&
		      y - level_ypos >= 0 && y - level_ypos < ed_fieldy)
		    DrawMiniElement(x - level_xpos, y - level_ypos,
				    EL_EMPTY);
		}
	      }
	    }
	  }

	  Feld[lx][ly] = new_element;
	  DrawMiniElement(sx, sy, new_element);
	}
      }
      else
      {
	if (item_xsize == MINI_TILEX && item_ysize == MINI_TILEY)
	  DrawMiniGraphicExt(drawto,
			     gi->x + sx * MINI_TILEX,
			     gi->y + sy * MINI_TILEY,
			     el2edimg(new_element));
	else
	  DrawGraphicExt(drawto,
			 gi->x + sx * TILEX,
			 gi->y + sy * TILEY,
			 el2img(new_element), 0);

	if (id == GADGET_ID_AMOEBA_CONTENT)
	  level.amoeba_content = new_element;
	else if (id == GADGET_ID_CUSTOM_GRAPHIC)
	{
	  new_element = GFX_ELEMENT(new_element);
	  custom_element.gfx_element = new_element;

	  CopyCustomElementPropertiesToGame(properties_element);

	  UpdateCustomElementGraphicGadgets();

	  FrameCounter = 0;	/* restart animation frame counter */
	}
	else if (id == GADGET_ID_CUSTOM_CONTENT)
	{
	  custom_element.content[sx][sy] = new_element;

	  CopyCustomElementPropertiesToGame(properties_element);
	}
	else if (id == GADGET_ID_CUSTOM_CHANGE_TARGET)
	{
	  custom_element_change.target_element = new_element;

	  CopyCustomElementPropertiesToGame(properties_element);
	}
	else if (id == GADGET_ID_CUSTOM_CHANGE_CONTENT)
	{
	  custom_element_change.content[sx][sy] = new_element;

	  CopyCustomElementPropertiesToGame(properties_element);
	}
	else if (id == GADGET_ID_CUSTOM_CHANGE_TRIGGER)
	{
	  custom_element_change.trigger_element = new_element;

	  CopyCustomElementPropertiesToGame(properties_element);
	}
	else if (id == GADGET_ID_RANDOM_BACKGROUND)
	  random_placement_background_element = new_element;
	else if (id >= GADGET_ID_ELEMENT_CONTENT_0 &&
		 id <= GADGET_ID_ELEMENT_CONTENT_7)
	  level.yamyam_content[id - GADGET_ID_ELEMENT_CONTENT_0][sx][sy] =
	    new_element;
      }
      break;

    case GADGET_ID_CONNECTED_ITEMS:
      {
	static int last_sx = -1;
	static int last_sy = -1;

	if (button_release_event)
	  CopyLevelToUndoBuffer(UNDO_IMMEDIATE);

	if (button)
	{
	  if (!button_press_event)
	    DrawLine(last_sx, last_sy, sx, sy, new_element, TRUE);

	  last_sx = sx;
	  last_sy = sy;
	}
      }
      break;

    case GADGET_ID_LINE:
    case GADGET_ID_ARC:
    case GADGET_ID_RECTANGLE:
    case GADGET_ID_FILLED_BOX:
    case GADGET_ID_GRAB_BRUSH:
    case GADGET_ID_TEXT:
      {
	static int last_sx = -1;
	static int last_sy = -1;
	static int start_sx = -1;
	static int start_sy = -1;
	void (*draw_func)(int, int, int, int, int, boolean);

	if (drawing_function == GADGET_ID_LINE)
	  draw_func = DrawLine;
	else if (drawing_function == GADGET_ID_ARC)
	  draw_func = DrawArc;
	else if (drawing_function == GADGET_ID_RECTANGLE)
	  draw_func = DrawBox;
	else if (drawing_function == GADGET_ID_FILLED_BOX)
	  draw_func = DrawFilledBox;
	else if (drawing_function == GADGET_ID_GRAB_BRUSH)
	  draw_func = SelectArea;
	else /* (drawing_function == GADGET_ID_TEXT) */
	  draw_func = SetTextCursor;

	if (button_press_event)
	{
	  draw_func(sx, sy, sx, sy, new_element, FALSE);
	  start_sx = last_sx = sx;
	  start_sy = last_sy = sy;

	  if (drawing_function == GADGET_ID_TEXT)
	    DrawLevelText(0, 0, 0, TEXT_END);
	}
	else if (button_release_event)
	{
	  draw_func(start_sx, start_sy, sx, sy, new_element, TRUE);
	  if (drawing_function == GADGET_ID_GRAB_BRUSH)
	  {
	    CopyAreaToBrush(start_sx, start_sy, sx, sy, button);
	    CopyBrushToCursor(sx, sy);
	    ClickOnGadget(level_editor_gadget[GADGET_ID_SINGLE_ITEMS],
			  MB_LEFTBUTTON);
	    draw_with_brush = TRUE;
	  }
	  else if (drawing_function == GADGET_ID_TEXT)
	    DrawLevelText(sx, sy, 0, TEXT_INIT);
	  else
	    CopyLevelToUndoBuffer(UNDO_IMMEDIATE);
	}
	else if (last_sx != sx || last_sy != sy)
	{
	  draw_func(start_sx, start_sy, last_sx, last_sy, -1, FALSE);
	  draw_func(start_sx, start_sy, sx, sy, new_element, FALSE);
	  last_sx = sx;
	  last_sy = sy;
	}
      }
      break;

    case GADGET_ID_FLOOD_FILL:
      if (button_press_event && Feld[lx][ly] != new_element)
      {
	FloodFill(lx, ly, new_element);
	DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos, level_ypos);
	CopyLevelToUndoBuffer(UNDO_IMMEDIATE);
      }
      break;

    case GADGET_ID_PICK_ELEMENT:
      if (button_release_event)
	ClickOnGadget(level_editor_gadget[last_drawing_function],
		      MB_LEFTBUTTON);
      else if (draw_level)
	PickDrawingElement(button, Feld[lx][ly]);
      else if (id == GADGET_ID_AMOEBA_CONTENT)
	PickDrawingElement(button, level.amoeba_content);
      else if (id == GADGET_ID_CUSTOM_GRAPHIC)
	PickDrawingElement(button, custom_element.gfx_element);
      else if (id == GADGET_ID_CUSTOM_CONTENT)
	PickDrawingElement(button, custom_element.content[sx][sy]);
      else if (id == GADGET_ID_CUSTOM_CHANGE_TARGET)
	PickDrawingElement(button, custom_element_change.target_element);
      else if (id == GADGET_ID_CUSTOM_CHANGE_CONTENT)
	PickDrawingElement(button, custom_element_change.content[sx][sy]);
      else if (id == GADGET_ID_CUSTOM_CHANGE_TRIGGER)
	PickDrawingElement(button, custom_element_change.trigger_element);
      else if (id == GADGET_ID_RANDOM_BACKGROUND)
	PickDrawingElement(button, random_placement_background_element);
      else if (id >= GADGET_ID_ELEMENT_CONTENT_0 &&
	       id <= GADGET_ID_ELEMENT_CONTENT_7)
      {
	int i = id - GADGET_ID_ELEMENT_CONTENT_0;

	PickDrawingElement(button, level.yamyam_content[i][sx][sy]);
      }

      break;

    default:
      break;
  }
}

static void HandleCounterButtons(struct GadgetInfo *gi)
{
  int gadget_id = gi->custom_id;
  int counter_id = gi->custom_type_id;
  int button = gi->event.button;
  int *counter_value = counterbutton_info[counter_id].value;
  int step = BUTTON_STEPSIZE(button) *
    (gadget_id == counterbutton_info[counter_id].gadget_id_down ? -1 : +1);

  if (counter_id == ED_COUNTER_ID_SELECT_LEVEL)
  {
    boolean pressed = (gi->event.type == GD_EVENT_PRESSED);
    boolean released = (gi->event.type == GD_EVENT_RELEASED);
    boolean level_changed = LevelChanged();

    if ((level_changed && pressed) || (!level_changed && released))
      return;

    if (level_changed && !Request("Level has changed! Discard changes ?",
				  REQ_ASK))
    {
      if (gadget_id == counterbutton_info[counter_id].gadget_id_text)
	ModifyEditorCounter(counter_id, *counter_value);
      return;
    }
  }

  if (gadget_id == counterbutton_info[counter_id].gadget_id_text)
    *counter_value = gi->textinput.number_value;
  else
    ModifyEditorCounter(counter_id, *counter_value + step);

  switch (counter_id)
  {
    case ED_COUNTER_ID_ELEMENT_CONTENT:
      DrawElementContentAreas();
      break;

    case ED_COUNTER_ID_ENVELOPE_XSIZE:
    case ED_COUNTER_ID_ENVELOPE_YSIZE:
      DrawEnvelopeTextArea(-1);
      break;

    case ED_COUNTER_ID_LEVEL_XSIZE:
    case ED_COUNTER_ID_LEVEL_YSIZE:
      lev_fieldx = level.fieldx;
      lev_fieldy = level.fieldy;
      break;

    case ED_COUNTER_ID_SELECT_LEVEL:
      LoadLevel(level_nr);
      TapeErase();
      ResetUndoBuffer();
      DrawEditModeWindow();
      break;

    default:
      break;
  }

  if ((counter_id >= ED_COUNTER_ID_CUSTOM_FIRST &&
       counter_id <= ED_COUNTER_ID_CUSTOM_LAST) ||
      (counter_id >= ED_COUNTER_ID_CHANGE_FIRST &&
       counter_id <= ED_COUNTER_ID_CHANGE_LAST))
    CopyCustomElementPropertiesToGame(properties_element);
}

static void HandleTextInputGadgets(struct GadgetInfo *gi)
{
  int type_id = gi->custom_type_id;

  strcpy(textinput_info[type_id].value, gi->textinput.value);

  if (type_id == ED_TEXTINPUT_ID_ELEMENT_NAME)
  {
    CopyCustomElementPropertiesToGame(properties_element);

    ModifyEditorElementList();	/* update changed button info text */
  }
}

static void HandleTextAreaGadgets(struct GadgetInfo *gi)
{
  int type_id = gi->custom_type_id;

  strcpy(textarea_info[type_id].value, gi->textarea.value);
}

static void HandleSelectboxGadgets(struct GadgetInfo *gi)
{
  int type_id = gi->custom_type_id;

  *selectbox_info[type_id].value =
    selectbox_info[type_id].options[gi->selectbox.index].value;

  if (type_id == ED_SELECTBOX_ID_SELECT_CHANGE_PAGE)
  {
    element_info[properties_element].current_change_page = gi->selectbox.index;

    DrawPropertiesWindow();
  }
  else if ((type_id >= ED_SELECTBOX_ID_CUSTOM_FIRST &&
	    type_id <= ED_SELECTBOX_ID_CUSTOM_LAST) ||
	   (type_id >= ED_SELECTBOX_ID_CHANGE_FIRST &&
	    type_id <= ED_SELECTBOX_ID_CHANGE_LAST))
    CopyCustomElementPropertiesToGame(properties_element);
}

static void HandleTextbuttonGadgets(struct GadgetInfo *gi)
{
  int type_id = gi->custom_type_id;
  int i;

  if (type_id >= ED_TEXTBUTTON_ID_PROPERTIES_FIRST &&
      type_id <= ED_TEXTBUTTON_ID_PROPERTIES_LAST)
  {
    edit_mode_properties = gi->custom_type_id;

    DrawPropertiesWindow();
  }
  else if (type_id == ED_TEXTBUTTON_ID_SAVE_AS_TEMPLATE)
  {
    boolean new_template = (!LevelFileExists(-1));

    if (new_template ||
	Request("Save this tem- plate and kill the old ?", REQ_ASK))
      SaveLevelTemplate();

    if (new_template)
      Request("Tem- plate saved !", REQ_CONFIRM);
  }
  else if (type_id == ED_TEXTBUTTON_ID_ADD_CHANGE_PAGE &&
	   custom_element.num_change_pages < MAX_CHANGE_PAGES)
  {
    struct ElementInfo *ei = &element_info[properties_element];

    setElementChangePages(ei, ei->num_change_pages + 1);

    /* set new change page to be new current change page */
    ei->current_change_page = ei->num_change_pages - 1;
    ei->change = &ei->change_page[ei->current_change_page];

    setElementChangeInfoToDefaults(ei->change);

    DrawPropertiesWindow();
  }
  else if (type_id == ED_TEXTBUTTON_ID_DEL_CHANGE_PAGE &&
	   custom_element.num_change_pages > MIN_CHANGE_PAGES)
  {
    struct ElementInfo *ei = &element_info[properties_element];

    /* copy all change pages after change page to be deleted */
    for (i = ei->current_change_page; i < ei->num_change_pages - 1; i++)
      ei->change_page[i] = ei->change_page[i + 1];

    setElementChangePages(ei, ei->num_change_pages - 1);

    DrawPropertiesWindow();
  }
}

static void HandleGraphicbuttonGadgets(struct GadgetInfo *gi)
{
  int type_id = gi->custom_type_id;

  if (type_id == ED_GRAPHICBUTTON_ID_PREV_CHANGE_PAGE ||
      type_id == ED_GRAPHICBUTTON_ID_NEXT_CHANGE_PAGE)
  {
    struct ElementInfo *ei = &element_info[properties_element];
    int step = BUTTON_STEPSIZE(gi->event.button);

    step *= (type_id == ED_GRAPHICBUTTON_ID_PREV_CHANGE_PAGE ? -1 : +1);
    ei->current_change_page += step;

    if (ei->current_change_page < 0)
      ei->current_change_page = 0;
    else if (ei->current_change_page >= ei->num_change_pages)
      ei->current_change_page = ei->num_change_pages - 1;

    DrawPropertiesWindow();
  }
}

static void HandleRadiobuttons(struct GadgetInfo *gi)
{
  *radiobutton_info[gi->custom_type_id].value =
    radiobutton_info[gi->custom_type_id].checked_value;
}

static void HandleCheckbuttons(struct GadgetInfo *gi)
{
  int type_id = gi->custom_type_id;

  *checkbutton_info[type_id].value ^= TRUE;

  if ((type_id >= ED_CHECKBUTTON_ID_CUSTOM_FIRST &&
       type_id <= ED_CHECKBUTTON_ID_CUSTOM_LAST) ||
      (type_id >= ED_CHECKBUTTON_ID_CHANGE_FIRST &&
       type_id <= ED_CHECKBUTTON_ID_CHANGE_LAST &&
       type_id != ED_CHECKBUTTON_ID_CUSTOM_USE_TEMPLATE))
  {
    CopyCustomElementPropertiesToGame(properties_element);
  }

  if (type_id == ED_CHECKBUTTON_ID_CUSTOM_USE_GRAPHIC)
  {
    UpdateCustomElementGraphicGadgets();
  }
  else if (type_id == ED_CHECKBUTTON_ID_CUSTOM_USE_TEMPLATE)
  {
    if (level.use_custom_template && !LevelFileExists(-1))
    {
      Request("No level tem- plate found !", REQ_CONFIRM);

      level.use_custom_template = FALSE;
      ModifyGadget(gi, GDI_CHECKED, FALSE, GDI_END);

      return;
    }

    LoadLevelTemplate(level.use_custom_template ? -1 : level_nr);

    DrawEditModeWindow();
  }
}

static void HandleControlButtons(struct GadgetInfo *gi)
{
  int id = gi->custom_id;
  int button = gi->event.button;
  int step = BUTTON_STEPSIZE(button);
  int new_element = BUTTON_ELEMENT(button);
  int x, y;

  if (edit_mode == ED_MODE_DRAWING && drawing_function == GADGET_ID_TEXT)
    DrawLevelText(0, 0, 0, TEXT_END);

  if (id < ED_NUM_CTRL1_BUTTONS && id != GADGET_ID_PROPERTIES &&
      id != GADGET_ID_PICK_ELEMENT && edit_mode != ED_MODE_DRAWING &&
      drawing_function != GADGET_ID_PICK_ELEMENT &&
      !(GetKeyModState() & KMOD_Control))
  {
    DrawDrawingWindow();
    edit_mode = ED_MODE_DRAWING;
  }

  switch (id)
  {
    case GADGET_ID_SCROLL_LEFT:
      if (level_xpos >= 0)
      {
	if (lev_fieldx < ed_fieldx - 2)
	  break;

	level_xpos -= step;
	if (level_xpos < -1)
	  level_xpos = -1;
	if (button == 1)
	  ScrollMiniLevel(level_xpos, level_ypos, ED_SCROLL_RIGHT);
	else
	  DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos, level_ypos);

	ModifyGadget(level_editor_gadget[GADGET_ID_SCROLL_HORIZONTAL],
		     GDI_SCROLLBAR_ITEM_POSITION, level_xpos + 1, GDI_END);
      }
      break;

    case GADGET_ID_SCROLL_RIGHT:
      if (level_xpos <= lev_fieldx - ed_fieldx)
      {
	if (lev_fieldx < ed_fieldx - 2)
	  break;

	level_xpos += step;
	if (level_xpos > lev_fieldx - ed_fieldx + 1)
	  level_xpos = lev_fieldx - ed_fieldx + 1;
	if (button == 1)
	  ScrollMiniLevel(level_xpos, level_ypos, ED_SCROLL_LEFT);
	else
	  DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos, level_ypos);

	ModifyGadget(level_editor_gadget[GADGET_ID_SCROLL_HORIZONTAL],
		     GDI_SCROLLBAR_ITEM_POSITION, level_xpos + 1, GDI_END);
      }
      break;

    case GADGET_ID_SCROLL_UP:
      if (level_ypos >= 0)
      {
	if (lev_fieldy < ed_fieldy - 2)
	  break;

	level_ypos -= step;
	if (level_ypos < -1)
	  level_ypos = -1;
	if (button == 1)
	  ScrollMiniLevel(level_xpos, level_ypos, ED_SCROLL_DOWN);
	else
	  DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos, level_ypos);

	ModifyGadget(level_editor_gadget[GADGET_ID_SCROLL_VERTICAL],
		     GDI_SCROLLBAR_ITEM_POSITION, level_ypos + 1, GDI_END);
      }
      break;

    case GADGET_ID_SCROLL_DOWN:
      if (level_ypos <= lev_fieldy - ed_fieldy)
      {
	if (lev_fieldy < ed_fieldy - 2)
	  break;

	level_ypos += step;
	if (level_ypos > lev_fieldy - ed_fieldy + 1)
	  level_ypos = lev_fieldy - ed_fieldy + 1;
	if (button == 1)
	  ScrollMiniLevel(level_xpos, level_ypos, ED_SCROLL_UP);
	else
	  DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos, level_ypos);

	ModifyGadget(level_editor_gadget[GADGET_ID_SCROLL_VERTICAL],
		     GDI_SCROLLBAR_ITEM_POSITION, level_ypos + 1, GDI_END);
      }
      break;

    case GADGET_ID_SCROLL_HORIZONTAL:
      level_xpos = gi->event.item_position - 1;
      DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos, level_ypos);
      break;

    case GADGET_ID_SCROLL_VERTICAL:
      level_ypos = gi->event.item_position - 1;
      DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos, level_ypos);
      break;

    case GADGET_ID_SCROLL_LIST_UP:
    case GADGET_ID_SCROLL_LIST_DOWN:
    case GADGET_ID_SCROLL_LIST_VERTICAL:
      if (id == GADGET_ID_SCROLL_LIST_VERTICAL)
	element_shift = gi->event.item_position * ED_ELEMENTLIST_BUTTONS_HORIZ;
      else
      {
	step *= (id == GADGET_ID_SCROLL_LIST_UP ? -1 : +1);
	element_shift += step * ED_ELEMENTLIST_BUTTONS_HORIZ;

	if (element_shift < 0)
	  element_shift = 0;
	if (element_shift > num_editor_elements - ED_NUM_ELEMENTLIST_BUTTONS)
	  element_shift = num_editor_elements - ED_NUM_ELEMENTLIST_BUTTONS;

	ModifyGadget(level_editor_gadget[GADGET_ID_SCROLL_LIST_VERTICAL],
		     GDI_SCROLLBAR_ITEM_POSITION,
		     element_shift / ED_ELEMENTLIST_BUTTONS_HORIZ, GDI_END);
      }

      ModifyEditorElementList();

      break;

    case GADGET_ID_WRAP_LEFT:
      WrapLevel(-step, 0);
      break;

    case GADGET_ID_WRAP_RIGHT:
      WrapLevel(step, 0);
      break;

    case GADGET_ID_WRAP_UP:
      WrapLevel(0, -step);
      break;

    case GADGET_ID_WRAP_DOWN:
      WrapLevel(0, step);
      break;

    case GADGET_ID_SINGLE_ITEMS:
    case GADGET_ID_CONNECTED_ITEMS:
    case GADGET_ID_LINE:
    case GADGET_ID_ARC:
    case GADGET_ID_TEXT:
    case GADGET_ID_RECTANGLE:
    case GADGET_ID_FILLED_BOX:
    case GADGET_ID_FLOOD_FILL:
    case GADGET_ID_GRAB_BRUSH:
    case GADGET_ID_PICK_ELEMENT:
      if (drawing_function != GADGET_ID_PICK_ELEMENT)
	last_drawing_function = drawing_function;
      drawing_function = id;
      draw_with_brush = FALSE;
      break;

    case GADGET_ID_RANDOM_PLACEMENT:
      RandomPlacement(new_element);
      break;

    case GADGET_ID_PROPERTIES:
      if (edit_mode != ED_MODE_PROPERTIES)
      {
	properties_element = new_element;
	DrawPropertiesWindow();
	edit_mode = ED_MODE_PROPERTIES;
      }
      else
      {
	DrawDrawingWindow();
	edit_mode = ED_MODE_DRAWING;
      }
      break;

    case GADGET_ID_UNDO:
      if (undo_buffer_steps == 0)
      {
	Request("Undo buffer empty !", REQ_CONFIRM);
	break;
      }

      if (edit_mode != ED_MODE_DRAWING)
      {
	DrawDrawingWindow();
	edit_mode = ED_MODE_DRAWING;
      }

      undo_buffer_position =
	(undo_buffer_position - 1 + NUM_UNDO_STEPS) % NUM_UNDO_STEPS;
      undo_buffer_steps--;

      for(x=0; x<lev_fieldx; x++)
	for(y=0; y<lev_fieldy; y++)
	  Feld[x][y] = UndoBuffer[undo_buffer_position][x][y];
      DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos,level_ypos);
      break;

    case GADGET_ID_INFO:
      if (edit_mode != ED_MODE_INFO)
      {
	DrawLevelInfoWindow();
	edit_mode = ED_MODE_INFO;
      }
      else
      {
	DrawDrawingWindow();
	edit_mode = ED_MODE_DRAWING;
      }
      break;

    case GADGET_ID_CLEAR:
      if (edit_mode != ED_MODE_DRAWING)
      {
	DrawDrawingWindow();
	edit_mode = ED_MODE_DRAWING;
      }

      for(x=0; x<MAX_LEV_FIELDX; x++) 
	for(y=0; y<MAX_LEV_FIELDY; y++) 
	  Feld[x][y] = (button == 1 ? EL_EMPTY : new_element);
      CopyLevelToUndoBuffer(GADGET_ID_CLEAR);

      DrawMiniLevel(ed_fieldx, ed_fieldy, level_xpos, level_ypos);
      break;

    case GADGET_ID_SAVE:
      if (leveldir_current->readonly)
      {
	Request("This level is read only !", REQ_CONFIRM);
	break;
      }

      if (!LevelContainsPlayer)
	Request("No Level without Gregor Mc Duffin please !", REQ_CONFIRM);
      else
      {
	boolean new_level = (!LevelFileExists(level_nr));

	if (new_level ||
	    Request("Save this level and kill the old ?", REQ_ASK))
	{
	  CopyPlayfield(Feld, level.field);

	  SaveLevel(level_nr);
	}

	if (new_level)
	  Request("Level saved !", REQ_CONFIRM);
      }
      break;

    case GADGET_ID_TEST:
      if (!LevelContainsPlayer)
	Request("No Level without Gregor Mc Duffin please !", REQ_CONFIRM);
      else
      {
	if (LevelChanged())
	  level.game_version = GAME_VERSION_ACTUAL;

	CopyPlayfield(level.field, FieldBackup);
	CopyPlayfield(Feld, level.field);

	UnmapLevelEditorGadgets();
	UndrawSpecialEditorDoor();

	CloseDoor(DOOR_CLOSE_ALL);

	DrawCompleteVideoDisplay();

	if (setup.autorecord)
	  TapeStartRecording();

	level_editor_test_game = TRUE;
	game_status = GAME_MODE_PLAYING;

	InitGame();
      }
      break;

    case GADGET_ID_EXIT:
      RequestExitLevelEditor(TRUE);	/* if level has changed, ask user */
      break;

    default:
      if (id >= GADGET_ID_ELEMENTLIST_FIRST &&
	  id <= GADGET_ID_ELEMENTLIST_LAST)
      {
	int element_position = id - GADGET_ID_ELEMENTLIST_FIRST;
	int new_element = editor_elements[element_position + element_shift];

	PickDrawingElement(button, new_element);

	if (!stick_element_properties_window &&
	    drawing_function != GADGET_ID_PICK_ELEMENT &&
	    !(GetKeyModState() & KMOD_Control))
	{
	  properties_element = new_element;
	  if (edit_mode == ED_MODE_PROPERTIES)
	    DrawPropertiesWindow();
	}

	if (drawing_function == GADGET_ID_PICK_ELEMENT)
	  ClickOnGadget(level_editor_gadget[last_drawing_function],
			MB_LEFTBUTTON);
      }
#ifdef DEBUG
      else if (gi->event.type == GD_EVENT_PRESSED)
	printf("default: HandleControlButtons: GD_EVENT_PRESSED(%d)\n", id);
      else if (gi->event.type == GD_EVENT_RELEASED)
	printf("default: HandleControlButtons: GD_EVENT_RELEASED(%d)\n", id);
      else if (gi->event.type == GD_EVENT_MOVING)
	printf("default: HandleControlButtons: GD_EVENT_MOVING(%d)\n", id);
      else
	printf("default: HandleControlButtons: ? (id == %d)\n", id);
#endif
      break;
  }
}

void HandleLevelEditorKeyInput(Key key)
{
  char letter = getCharFromKey(key);
  int button = MB_LEFTBUTTON;

  if (drawing_function == GADGET_ID_TEXT &&
      DrawLevelText(0, 0, 0, TEXT_QUERY_TYPING) == TRUE)
  {
    if (letter)
      DrawLevelText(0, 0, letter, TEXT_WRITECHAR);
    else if (key == KSYM_Delete || key == KSYM_BackSpace)
      DrawLevelText(0, 0, 0, TEXT_BACKSPACE);
    else if (key == KSYM_Return)
      DrawLevelText(0, 0, 0, TEXT_NEWLINE);
    else if (key == KSYM_Escape)
      DrawLevelText(0, 0, 0, TEXT_END);
  }
  else if (button_status == MB_RELEASED)
  {
    int i, id = GADGET_ID_NONE;

    switch (key)
    {
      case KSYM_Left:
	id = GADGET_ID_SCROLL_LEFT;
	break;
      case KSYM_Right:
	id = GADGET_ID_SCROLL_RIGHT;
	break;
      case KSYM_Up:
	id = GADGET_ID_SCROLL_UP;
	break;
      case KSYM_Down:
	id = GADGET_ID_SCROLL_DOWN;
	break;
      case KSYM_Page_Up:
	id = GADGET_ID_SCROLL_LIST_UP;
	button = MB_RIGHTBUTTON;
	break;
      case KSYM_Page_Down:
	id = GADGET_ID_SCROLL_LIST_DOWN;
	button = MB_RIGHTBUTTON;
	break;

      case KSYM_Escape:
        if (edit_mode == ED_MODE_DRAWING)
	{
	  RequestExitLevelEditor(setup.ask_on_escape);
	}
        else
	{
	  DrawDrawingWindow();
	  edit_mode = ED_MODE_DRAWING;
	}
        break;

      default:
	break;
    }

    if (id != GADGET_ID_NONE)
      ClickOnGadget(level_editor_gadget[id], button);
    else if (letter == '.')
      ClickOnGadget(level_editor_gadget[GADGET_ID_SINGLE_ITEMS], button);
    else if (key == KSYM_Return || key == setup.shortcut.toggle_pause)
      ClickOnGadget(level_editor_gadget[GADGET_ID_TEST], button);
    else
      for (i=0; i<ED_NUM_CTRL_BUTTONS; i++)
	if (letter && letter == control_info[i].shortcut)
	  if (!anyTextGadgetActive())
	    ClickOnGadget(level_editor_gadget[i], button);
  }
}

void HandleLevelEditorIdle()
{
  static unsigned long action_delay = 0;
  unsigned long action_delay_value = GameFrameDelay;
  int xpos = 1, ypos = 2;

  if (edit_mode != ED_MODE_PROPERTIES)
    return;

  if (!DelayReached(&action_delay, action_delay_value))
    return;

  DrawGraphicAnimationExt(drawto,
			  SX + xpos * TILEX,
			  SY + ypos * TILEY + MINI_TILEY / 2,
			  el2img(properties_element), -1, NO_MASKING);

  MarkTileDirty(xpos, ypos);
  MarkTileDirty(xpos, ypos + 1);

  FrameCounter++;	/* increase animation frame counter */
}

void ClearEditorGadgetInfoText()
{
  DrawBackground(INFOTEXT_XPOS, INFOTEXT_YPOS, INFOTEXT_XSIZE, INFOTEXT_YSIZE);
}

void HandleEditorGadgetInfoText(void *ptr)
{
  struct GadgetInfo *gi = (struct GadgetInfo *)ptr;
  char infotext[MAX_OUTPUT_LINESIZE + 1];
  char shortcut[MAX_OUTPUT_LINESIZE + 1];
  int max_infotext_len = getMaxInfoTextLength();

  if (game_status != GAME_MODE_EDITOR)
    return;

  ClearEditorGadgetInfoText();

  if (gi->event.type == GD_EVENT_INFO_LEAVING)
    return;

  /* misuse this function to delete brush cursor, if needed */
  if (edit_mode == ED_MODE_DRAWING && draw_with_brush)
    DeleteBrushFromCursor();

  if (gi == NULL || gi->info_text == NULL)
    return;

  strncpy(infotext, gi->info_text, max_infotext_len);
  infotext[max_infotext_len] = '\0';

  if (gi->custom_id < ED_NUM_CTRL_BUTTONS)
  {
    int key = control_info[gi->custom_id].shortcut;

    if (key)
    {
      if (gi->custom_id == GADGET_ID_SINGLE_ITEMS)	/* special case 1 */
	sprintf(shortcut, " ('.' or '%c')", key);
      else if (gi->custom_id == GADGET_ID_PICK_ELEMENT)	/* special case 2 */
	sprintf(shortcut, " ('%c' or 'Ctrl')", key);
      else if (gi->custom_id == GADGET_ID_TEST)		/* special case 3 */
	sprintf(shortcut, " ('Enter' or 'Shift-%c')", key);
      else						/* normal case */
	sprintf(shortcut, " ('%s%c')",
		(key >= 'A' && key <= 'Z' ? "Shift-" : ""), key);

      if (strlen(infotext) + strlen(shortcut) <= max_infotext_len)
	strcat(infotext, shortcut);
    }
  }

  DrawText(INFOTEXT_XPOS, INFOTEXT_YPOS, infotext, FONT_TEXT_2);
}

static void HandleDrawingAreaInfo(struct GadgetInfo *gi)
{
  static int start_lx, start_ly;
  char *infotext;
  int id = gi->custom_id;
  int sx = gi->event.x;
  int sy = gi->event.y;
  int lx = sx + level_xpos;
  int ly = sy + level_ypos;
  int min_sx = 0, min_sy = 0;
  int max_sx = gi->drawing.area_xsize - 1;
  int max_sy = gi->drawing.area_ysize - 1;
  int actual_drawing_function = drawing_function;

  /* pressed Control key: simulate picking element */
  if (GetKeyModState() & KMOD_Control)
    actual_drawing_function = GADGET_ID_PICK_ELEMENT;

  ClearEditorGadgetInfoText();

  if (gi->event.type == GD_EVENT_INFO_LEAVING)
    return;

  /* make sure to stay inside drawing area boundaries */
  sx = (sx < min_sx ? min_sx : sx > max_sx ? max_sx : sx);
  sy = (sy < min_sy ? min_sy : sy > max_sy ? max_sy : sy);

  if (id == GADGET_ID_DRAWING_LEVEL)
  {
    if (button_status)
    {
      int min_lx = 0, min_ly = 0;
      int max_lx = lev_fieldx - 1, max_ly = lev_fieldy - 1;

      /* get positions inside level field */
      lx = sx + level_xpos;
      ly = sy + level_ypos;

      /* make sure to stay inside level field boundaries */
      lx = (lx < min_lx ? min_lx : lx > max_lx ? max_lx : lx);
      ly = (ly < min_ly ? min_ly : ly > max_ly ? max_ly : ly);

      /* correct drawing area positions accordingly */
      sx = lx - level_xpos;
      sy = ly - level_ypos;
    }

    if (IN_ED_FIELD(sx,sy) && IN_LEV_FIELD(lx, ly))
    {
      if (button_status)	/* if (gi->state == GD_BUTTON_PRESSED) */
      {
	if (gi->event.type == GD_EVENT_PRESSED)
	{
	  start_lx = lx;
	  start_ly = ly;
	}

	switch (actual_drawing_function)
	{
	  case GADGET_ID_SINGLE_ITEMS:
	    infotext = "Drawing single items";
	    break;
      	  case GADGET_ID_CONNECTED_ITEMS:
	    infotext = "Drawing connected items";
	    break;
      	  case GADGET_ID_LINE:
	    infotext = "Drawing line";
	    break;
      	  case GADGET_ID_ARC:
	    infotext = "Drawing arc";
	    break;
      	  case GADGET_ID_TEXT:
	    infotext = "Setting text cursor";
	    break;
      	  case GADGET_ID_RECTANGLE:
	    infotext = "Drawing rectangle";
	    break;
      	  case GADGET_ID_FILLED_BOX:
	    infotext = "Drawing filled box";
	    break;
      	  case GADGET_ID_FLOOD_FILL:
	    infotext = "Flood fill";
	    break;
      	  case GADGET_ID_GRAB_BRUSH:
	    infotext = "Grabbing brush";
	    break;
      	  case GADGET_ID_PICK_ELEMENT:
	    infotext = "Picking element";
	    break;

	  default:
	    infotext = "Drawing position";
	    break;
	}

	if (actual_drawing_function == GADGET_ID_PICK_ELEMENT)
	  DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2,
		    "%s: %d, %d", infotext, lx, ly);
	else
	  DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2,
		    "%s: %d, %d", infotext,
		    ABS(lx - start_lx) + 1, ABS(ly - start_ly) + 1);
      }
      else if (actual_drawing_function == GADGET_ID_PICK_ELEMENT)
	DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2,
		  "%s", getElementInfoText(Feld[lx][ly]));
      else
	DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2,
		  "Level position: %d, %d", lx, ly);
    }

    /* misuse this function to draw brush cursor, if needed */
    if (edit_mode == ED_MODE_DRAWING && draw_with_brush && !button_status)
    {
      if (IN_ED_FIELD(sx, sy) && IN_LEV_FIELD(lx, ly))
	CopyBrushToCursor(sx, sy);
      else
	DeleteBrushFromCursor();
    }
  }
  else if (actual_drawing_function == GADGET_ID_PICK_ELEMENT)
  {
    if (id == GADGET_ID_AMOEBA_CONTENT)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2, "%s",
		getElementInfoText(level.amoeba_content));
    else if (id == GADGET_ID_CUSTOM_GRAPHIC)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2, "%s",
		getElementInfoText(custom_element.gfx_element));
    else if (id == GADGET_ID_CUSTOM_CONTENT)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2, "%s",
		getElementInfoText(custom_element.content[sx][sy]));
    else if (id == GADGET_ID_CUSTOM_CHANGE_TARGET)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2, "%s",
		getElementInfoText(custom_element_change.target_element));
    else if (id == GADGET_ID_CUSTOM_CHANGE_CONTENT)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2, "%s",
		getElementInfoText(custom_element_change.content[sx][sy]));
    else if (id == GADGET_ID_CUSTOM_CHANGE_TRIGGER)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2, "%s",
		getElementInfoText(custom_element_change.trigger_element));
    else if (id == GADGET_ID_RANDOM_BACKGROUND)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2, "%s",
		getElementInfoText(random_placement_background_element));
    else if (id >= GADGET_ID_ELEMENT_CONTENT_0 &&
	     id <= GADGET_ID_ELEMENT_CONTENT_7)
    {
      int i = id - GADGET_ID_ELEMENT_CONTENT_0;

      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2, "%s",
		getElementInfoText(level.yamyam_content[i][sx][sy]));
    }
  }
  else
  {
    if (id == GADGET_ID_AMOEBA_CONTENT)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2,
		"Amoeba content");
    else if (id == GADGET_ID_CUSTOM_GRAPHIC)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2,
		"Custom graphic element");
    else if (id == GADGET_ID_CUSTOM_CONTENT)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2,
		"Custom element content position: %d, %d", sx, sy);
    else if (id == GADGET_ID_CUSTOM_CHANGE_TARGET)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2,
		"New element after change");
    else if (id == GADGET_ID_CUSTOM_CHANGE_CONTENT)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2,
		"New extended elements after change");
    else if (id == GADGET_ID_CUSTOM_CHANGE_TRIGGER)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2,
		"Other element triggering change");
    else if (id == GADGET_ID_RANDOM_BACKGROUND)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2,
		"Random placement background");
    else if (id >= GADGET_ID_ELEMENT_CONTENT_0 &&
	     id <= GADGET_ID_ELEMENT_CONTENT_7)
      DrawTextF(INFOTEXT_XPOS - SX, INFOTEXT_YPOS - SY, FONT_TEXT_2,
		"Content area %d position: %d, %d",
		id - GADGET_ID_ELEMENT_CONTENT_0 + 1, sx, sy);
  }
}

void RequestExitLevelEditor(boolean ask_if_level_has_changed)
{
  if (!ask_if_level_has_changed ||
      !LevelChanged() ||
      Request("Level has changed! Exit without saving ?",
	      REQ_ASK | REQ_STAY_OPEN))
  {
#if 1
    CloseDoor(DOOR_CLOSE_1);
    SetDoorState(DOOR_CLOSE_2);
#else
    CloseDoor(DOOR_CLOSE_ALL);
#endif
    game_status = GAME_MODE_MAIN;
    DrawMainMenu();
  }
  else
  {
    CloseDoor(DOOR_CLOSE_1);
    BlitBitmap(bitmap_db_door, bitmap_db_door,
	       DOOR_GFX_PAGEX2, DOOR_GFX_PAGEY1, DXSIZE,DYSIZE,
	       DOOR_GFX_PAGEX1, DOOR_GFX_PAGEY1);
    OpenDoor(DOOR_OPEN_1);
  }
}
